PROGRAM SISH
**========================================================================================
**  FUNCTION
**    SImount Shell (Beta)
**    
**    Operate like Unix Shell and modern Screen Editor
**
**    See. https://github.com/simount/SISH
**
**    Please read the "README.adoc" for more information
**
**  VERSION
**    v0.42.3
**  DATE
**    2018/04/06
**  AUTHOR
**    Kazuya Kosaku <kosaku@simount.com>
**  LICENSE
**    Copyright (C) 2017  SImount <info@simount.com>
**    MIT License
**========================================================================================
$MODE DEBUG.EQUATES
Equ SISH.VERSION To "[ SISH v0.42.3 ]"

$IFDEF U2__UNIVERSE
	!! For UniVerse
	$INCLUDE UNIVERSE.INCLUDE TERMINFO
	$INCLUDE UNIVERSE.INCLUDE ATFUNCTIONS.H
	
	EQU ACCOUNT.FILE To "UV.ACCOUNT"
	EQU SAVEDLISTS.FILE To "&SAVEDLISTS&"
	EQU STACK.FILE To "stacks"
	
	EQU IS.CONSOLE Lit "@TTY = 'console'"
$ELSE
	!! For OpenQM compatibility
	
	$CATALOGUE SISH GLOBAL

	$MODE CASE.SENSITIVE,CONDITIONAL.STATEMENTS,UV.LOCATE
	$MODE DEBUG.EQUATES
	
	$INCLUDE SYSCOM KEYS.H
	$INCLUDE SYSCOM TERMINFO.H
	
	!! 関数名の単純の置換
	EQU FMTDP Lit "FMTDW"
	EQU LenDP Lit "DISPLAY.WIDTH"
	EQU LenSDP Lit "DISPLAY.WIDTHS"
	EQU UniSeq Lit "Seq"
	
	EQU KEY.MOVE.CURSOR.UP To TermInfo(T$KEY.UP)
	EQU KEY.MOVE.CURSOR.DOWN To TermInfo(T$KEY.DOWN)
	EQU KEY.MOVE.CURSOR.LEFT To TermInfo(T$KEY.LEFT)
	EQU KEY.MOVE.CURSOR.RIGHT To TermInfo(T$KEY.RIGHT)
	EQU KEY.MOVE.CURSOR.TO.HOME To TermInfo(T$KEY.HOME)
	EQU KEY.MOVE.CURSOR.TO.LAST.LINE To TermInfo(T$KEY.END)
	EQU KEY.FUNCTION.1 To TermInfo(T$KEY.F1)
	EQU KEY.FUNCTION.2 To TermInfo(T$KEY.F2)
	EQU KEY.FUNCTION.3 To TermInfo(T$KEY.F3)
	EQU KEY.FUNCTION.4 To TermInfo(T$KEY.F4)
	EQU KEY.FUNCTION.5 To TermInfo(T$KEY.F5)
	EQU KEY.FUNCTION.6 To TermInfo(T$KEY.F6)
	EQU KEY.FUNCTION.7 To TermInfo(T$KEY.F7)
	EQU KEY.FUNCTION.8 To TermInfo(T$KEY.F8)
	EQU KEY.FUNCTION.9 To TermInfo(T$KEY.F9)
	EQU KEY.FUNCTION.10 To TermInfo(T$KEY.F10)
	EQU KEY.FUNCTION.11 To TermInfo(T$KEY.F11)
	EQU KEY.FUNCTION.12 To TermInfo(T$KEY.F12)
	EQU KEY.INSERT.LINE To TermInfo(T$KEY.IL)
	
	EQU ACCOUNT.FILE To "QM.ACCOUNTS"
	EQU SAVEDLISTS.FILE To "$SAVEDLISTS"
	EQU STACK.FILE To "stacks"
	
	EQU IS.CONSOLE Lit "@TTY = 'console' AND @TERM.TYPE # 'msvt'"
$ENDIF

*
* 定数定義
*

!! 論理定数
EQU True To 1
EQU False To 0
EQU BIG To 999
EQU HUGE To 9999999

!! キーコード
EQU BEL To Char(7)
EQU LF To Char(10)
EQU CR To Char(13)
EQU ESC To Char(27)
EQU CS.DEL to char(127)
EQU CTRL.A To Char(1)
EQU CTRL.B To Char(2)
EQU CTRL.C To Char(3)
EQU CTRL.D To Char(4)
EQU CTRL.E To Char(5)
EQU CTRL.F To Char(6)
EQU CTRL.G To Char(7)
EQU CTRL.H To Char(8)
EQU CTRL.I To Char(9)
EQU CTRL.J To Char(10)
EQU CTRL.K To Char(11)
EQU CTRL.L To Char(12)
EQU CTRL.M To Char(13)
EQU CTRL.N To Char(14)
EQU CTRL.O To Char(15)
EQU CTRL.P To Char(16)
EQU CTRL.Q To Char(17)
EQU CTRL.R To Char(18)
EQU CTRL.S To Char(19)
EQU CTRL.T To Char(20)
EQU CTRL.U To Char(21)
EQU CTRL.V To Char(22)
EQU CTRL.W To Char(23)
EQU CTRL.X To Char(24)
EQU CTRL.Y To Char(25)
EQU CTRL.Z To Char(26)
EQU CRLF To CR:LF

!! 制御シーケンス
Equ CSI To ESC:'['
Equ ESC.CUR.TOP To CSI:"1;2H" ;** カーソルを画面のトップに持ってくる制御
Equ ESC.CRT.MOVE_NEXT_LINE To CRLF

!! スクロール高速描画に切り替えるスクロール行数
!Equ SCROLL.DRAW.NUM To Int(Depth/2) ;** Winodows Consoleだとなぜかちらつく
Equ SCROLL.DRAW.NUM To 1 ;** 1行以外は全描画した方がなぜかレスポンスが良い
!Equ SCROLL.DRAW.NUM To 0

!! OS Switch
Equ OS.GATES To SYSTEM(91)

* Actions
* 組み込みアクションが追加されるなら必ずメンテナンスする
*
	Equ A.LEFT To 1
	Equ A.RIGHT To 2
	Equ A.UP To 3
	Equ A.DOWN To 4
	Equ A.HOME To 5
	Equ A.END To 6
	Equ A.NEXTPAGE To 7
	Equ A.PREVPAGE To 8
	Equ A.NEXTHALF To 9
	Equ A.PREVHALF To 10
	Equ A.NEXTWORD To 11
	Equ A.PREVWORD To 12
	Equ A.NEXTSTMT To 13
	Equ A.PREVSTMT To 14
	Equ A.NEXTCHAR To 15
	Equ A.PREVCHAR To 16
	Equ A.TOP To 17
	Equ A.BOTTOM To 18
	Equ A.SEL_LEFT To 19
	Equ A.SEL_RIGHT To 20
	Equ A.SEL_UP To 21
	Equ A.SEL_DOWN To 22
	Equ A.SEL_HOME To 23
	Equ A.SEL_END To 24
	Equ A.SEL_NEXTWORD To 25
	Equ A.SEL_PREVWORD To 26
	Equ A.SEL_NEXTSTMT To 27
	Equ A.SEL_PREVSTMT To 28
	Equ A.SEL_NEXTPAGE To 29
	Equ A.SEL_PREVPAGE To 30
	Equ A.SEL_NEXTHALF To 31
	Equ A.SEL_PREVHALF To 32
	Equ A.SEL_NEXTCHAR To 33
	Equ A.SEL_PREVCHAR To 34
	Equ A.SEL_TOP To 35
	Equ A.SEL_BOTTOM To 36
	Equ A.SCROLL_MID To 37
	Equ A.NEWLINE To 38
	Equ A.INSCHAR To 39
	Equ A.DELETELINE To 40
	Equ A.BACKSPACE To 41
	Equ A.DELETECHAR To 42
	Equ A.CUT To 43
	Equ A.COPY To 44
	Equ A.SEND_PASTE To 45
	Equ A.PASTE To 46
	Equ A.PASTE_LOCAL To 47
	Equ A.UNDO To 48
	Equ A.REDO To 49
	Equ A.SEL_ALL To 50
  Equ A.SEL_EXPAND To 51
  Equ A.DELETE_BACKWORD To 52
  Equ A.DELETE_NEXTWORD To 53
	
	** 共通入力アクションの追加ポイント
	Equ ENUM.INPUT.ACTION.LAST To 53

  Equ A.CANCEL To 54
  Equ A.TAB To 55
  Equ A.SHIFT_TAB To 56
  Equ A.THEME To 57
  Equ A.INSVMC To 58
  Equ A.INSSMC To 59
  Equ A.INSTMC To 60
  Equ A.TEMPLATE To 61
  Equ A.COMMENT To 62
  Equ A.SEARCH To 63
  Equ A.REPEAT To 64
  Equ A.REVERSE To 65
  Equ A.REPLACE To 66
  Equ A.BUFFER To 67
  Equ A.OUTLINE To 68
  Equ A.GOLINE To 69
  Equ A.GO_DECLARATION To 70
  Equ A.NEXTJUMP To 71
  Equ A.PREVJUMP To 72
  Equ A.SAVE To 73
  Equ A.HELP To 74
  Equ A.COMPILE To 75
  Equ A.RELOAD To 76
  Equ A.ACTION To 77
  Equ A.EXIT To 78
  Equ A.CLOSEBUF To 79
  Equ A.DIVE To 80
  Equ A.CASEINVERT To 81
  Equ A.FIT.TERM To 82
  Equ A.WORD_HOKAN To 83
  Equ A.NEWBUF To 84
  Equ A.RUN To 85
	Equ A.MOUSE To 86
	Equ A.WHEEL.UP To 87
	Equ A.WHEEL.DOWN To 88
* ↑ここに追加していく    
  Equ ACTION.ENUM.LAST To 88

** ================================================================================
** Shell Main
** ================================================================================
Shell.Main:

	EQU CMD.STACK.SIZE To 1000 ;** コマンドスタックのサイズ
	EQU MAXWINDOWS To 50
	EQU BUFFS To 52
	EQU CMD_BUF To BUFFS

	* セッショングローバル
	COMMON /SISH.SHELL/ ShInfo(30),has.Run.Command.Delegator,Run.Command.Delegator
	COMMON /SISH.EDITOR/ initEnvEDS,lruBuffList,jumpHistory,jumpHistoryPos,currentJumpData,CurBuf,BufInfos(BUFFS),Bufs(BUFFS),Ys(BUFFS),Xs(BUFFS),DP_Xs(BUFFS),Tops(BUFFS),XOffSets(BUFFS),RecLines(BUFFS),EditCmdStacks(BUFFS),EditCmdPoss(BUFFS),StartRecs(BUFFS),ys(BUFFS),TgtFlds(BUFFS),DIRecs(BUFFS)

	Equ cmdStack To ShInfo(1) ;** コマンドスタック
	Equ logtoStack To ShInfo(2) ;** LOGTOスタック
	Equ prevAccount To ShInfo(3)<1> ;** 前回のアカウント
	Equ prevPath To ShInfo(3)<2> ;** 前回のアカウントパス
	Equ bInvert To ShInfo(4) ;** 大文字小文字変換機能 ON/OFF
	Equ bTimer To ShInfo(5) ;** 時間計測機能 ON/OFF
	Equ theme To ShInfo(6) ;** テーマNo
	Equ HAS.PASTE.EXE To ShInfo(7) ;** paste.exe存在するか
	Equ bChain To ShInfo(8) ;** 未使用
	Equ bAutoTermSize To ShInfo(9) ;** 端末サイズ自動設定機能 ON/OFF
	Equ clipboard To ShInfo(10) ;** クリップボード
	Equ bOverlay To ShInfo(11) ;** Insert/Overlay Mode
	Equ cmdStackList.DispCnt To ShInfo(12) ;** コマンドスタックリスト表示
	Equ descIType To ShInfo(13) ;** DICT.DESKレコード
	Equ typeIType To ShInfo(14) ;** DICT.TYPEレコード
	Equ serverListIds To ShInfo(15) ;** サーバ一覧ID
	Equ serverList To ShInfo(16) ;** サーバ一覧
	Equ prevListStackCmd To ShInfo(17) ;** 直前のstack一覧コマンド
	Equ prevFileName To ShInfo(18) ;** 直前のコマンドのファイル名
	Equ bAutoCommand To ShInfo(19) ;** コマンドを実行してエディタに戻る
	Equ bAutoEditor To ShInfo(20) ;** 自動でエディタ起動
	Equ FileName To ShInfo(21) ;** 直前のエディタファイル名
	Equ ItemName To ShInfo(22) ;** 直前のエディタアイテム名
	Equ PathName To ShInfo(23) ;** 直前のエディタパス名
	Equ LRUOpenList To ShInfo(24) ;** 最近開いたファイルリスト

*--------------------------------------------------------------------------
*   Full Screen Editor System
*--------------------------------------------------------------------------
	EQU Rec To Bufs(CurBuf)                            ;** 編集対象レコード
	EQU X To Xs(CurBuf)                                ;** カーソルX位置(内部)
	EQU DP_X To DP_Xs(CurBuf)                          ;** 表示カーソルX位置
	EQU Y To Ys(CurBuf)                                ;** カーソルY位置
	EQU Top To Tops(CurBuf)                            ;** スクロールY位置
	EQU XOffSet To XOffSets(CurBuf)                    ;** スクロールX位置
	EQU Lines To RecLines(CurBuf)                      ;** 最大行数
	EQU EditCmdStack To EditCmdStacks(CurBuf)          ;** UndoRedoスタック
	EQU EditCmdPos To EditCmdPoss(CurBuf)              ;** UndoRedoスタック位置
	EQU StartRec To StartRecs(CurBuf)                  ;** 編集開始時点レコード
	EQU DIRec To DIRecs(CurBuf)                        ;** 辞書情報レコード
	EQU TgtFld To TgtFlds(CurBuf)                      ;** 編集対象フィールド
	
	!! Buffer Information
	EQU BI.USED To 1
	EQU BI.FILE To 2
	EQU BI.ITEM To 3
	EQU BI.NEW To 4
	EQU BI.CHANGED To 5
	EQU BI.BLOCKSTART To 6
	EQU BI.BLOCKEND To 7
	EQU BI.READONLY To 8
	EQU BI.BOOKMARK To 9
	EQU BI.HIWORD To 10
	EQU BI.WIDE To 11
	EQU BI.CAPTURE To 12
	EQU BI.PARSETYPE To 13
	EQU BI.ACCOUNT To 14
	EQU BI.LOCKED To 15
	EQU BI.FIELDFIX To 16
	EQU BI.VALUEFIX To 17
	EQU BI.PBUFNO To 18
	EQU BI.INDENTTYPE To 19
	EQU BI.INDENTSIZE To 20
	EQU BI.PATHNAME To 21
	EQU BI.AUTOWRAP To 22
	
	EQU BufInfo To BufInfos(CurBuf)
	EQU Changed To BufInfo<BI.CHANGED>
	EQU IsNew To BufInfo<BI.NEW>
	EQU ReadOnly To BufInfo<BI.READONLY>
	EQU BookMark To BufInfo<BI.BOOKMARK>
	EQU IndentType To BufInfo<BI.INDENTTYPE>
	EQU AutoWrap To BufInfo<BI.AUTOWRAP>
	EQU STDTAB To BufInfo<BI.INDENTSIZE>
	EQU STDINDENT TO STDTAB * 1        ; * other indents
	EQU STDFIRSTINDENT To 0

	EQU biInfoWide To Sum(Sum(BufInfo<11>)) ;* 情報エリア横幅
	EQU biInfoWide.lineNo To BufInfo<11,1> ;* 行数エリア横幅
	EQU biInfoWide.dict To BufInfo<11,2> ;* 辞書表示エリア横幅

	Equ Depth Lit "(@CRTHIGH - 2)"
	Equ Width Lit "(@CRTWIDE - biInfoWide)"
	
	EQU AddKeyWord Lit "KEYWORDS<-1> = "
	EQU AddFunc Lit "FUNCS<-1> = "
	
	EQU SI.NONE To '0'
	EQU SI.LABEL To '1'
	EQU SI.COMMENT To '2'
	EQU SI.NUMBER To '3'
	EQU SI.STRING To '4'
	EQU SI.KEY To '5'
	EQU SI.OPERATOR To '6'
	EQU SI.FUNCTION To '7'
	EQU SI.DIRECTIVE To '8'
	EQU SI.SELECTION To '9'
	EQU SI.SEARCH To 'a'
	EQU SI.DOC To 'b'
	EQU SI.VMK To 'c'
	EQU SI.SMK To 'd'
	EQU SI.KAKKO To 'e'
	
	EQU PARSE.DATA To "Item"
	EQU PARSE.BASIC To "Basic"
	EQU PARSE.PROC To "Proc"
	EQU PARSE.PARA To "PA"
	EQU PARSE.PDUMP To "PDUMP"
	EQU PARSE.RAW To "Raw"

	MY_COMMAND = Trim(@COMMAND[' ',1,1]) ;** 自コマンド名(SISH)
	EQU KAKKO.CHAR.LIST1 To (\([<{'"\:"\") ;** 対応する開き括弧定義
	EQU KAKKO.CHAR.LIST2 To (\)]>}'"\:"\") ;** 対応する閉じ括弧定義

	EQU PY Lit "@CRTHIGH - 2"
	EQU LISTDEPTH Lit "Depth - 2"

	If initEnvEDS Else
		!! 初回起動時にのみ処理するもの
		
		initEnvEDS = @TRUE
		lruBuffList = "" ; !! バッファの直近順List
		jumpHistory = "" ; !! ジャンプ履歴
		jumpHistoryPos = 0 ; !! ジャンプ履歴位置
		currentJumpData = "" ;** 現在のジャンプデータ
		CurBuf = 1
		Mat BufInfos = ""
		Mat Bufs = ""
		Mat Xs = 0
		Mat DP_Xs = 0
		Mat Ys = 0
		Mat Tops = 0
		Mat XOffSets = 1
		Mat EditCmdStacks = ""
		Mat EditCmdPoss = 1
		Mat StartRecs = ""
		Mat DIRecs = ""
		Mat TgtFlds = ""
		
		cmdStack = ""
		logtoStack = "" ;** LOGTOの履歴を保持
		bAutoTermSize = @TRUE
		bInvert = @FALSE ;** デフォルト反転モード
		bTimer = @FALSE
		clipboard = ""        ;** ローカルクリップボードバッファ
		bOverlay = @FALSE
		cmdStackList.DispCnt = "2":@FM:"19" ;** コマンドスタックリスト表示のデフォルト値
		prevListStackCmd = ".L" ;** 直前のstack一覧コマンド
		prevFileName = "" ;** 直前のコマンドのファイル名
		FileName = ""
		ItemName = ""
		PathName = ""
		DP_Y = 0
		
		Crt SISH.VERSION
		
		!! paste.exeを探す
$IFNDEF U2__UNIVERSE
		HAS.PASTE.EXE = ""
		If @TTY = 'console' Then
			OS.Execute 'where /q win32yank.exe'
			If OS.Error() = 0 Then
				HAS.PASTE.EXE = "win32yank.exe -o"
			End
		End
$ENDIF
		theme = @FALSE
		
		!! Check for run.command.delegator
		Run.Command.Delegator = "SISH.RUN.COMMAND.DELEGATOR"
$IFDEF U2__UNIVERSE
		EXECUTE "SISH.RUN.COMMAND.DELEGATOR" CAPTURING OUT
		has.Run.Command.Delegator = @SYSTEM.RETURN.CODE#-1
$ELSE
		EXECUTE "SISH.RUN.COMMAND.DELEGATOR" CAPTURING OUT
		has.Run.Command.Delegator = @SYSTEM.RETURN.CODE#-1
$ENDIF
	End
	
	GoSub InitTerminal
	
!! 外部設定の読み込み
$INCLUDE SISH.SETTING.H

	GoSub Load.Theme
	If theme Then
		GoSub Act.SwitchTheme
		theme = Not(theme)
	End
	
	GoSub SetupDefKeyBindings
	GoSub SetupTokens
	
	!! Query for support Brackets Paste Mode
	Crt CSI:"?2004$p":

	prevPath = "" ;** 前回のアカウントパスは一度クリアする
	prevAccount = "" ;** 前回のアカウント
	
	** VOCファイルを開く
	Open 'VOC' To VOC Else Abort
$IFDEF U2__UNIVERSE
	** UV.ACCOUNTを見れるようにする
	ReadV dummy From VOC,'UV.ACCOUNT',0 Else
		rec = "Q"
		rec<2> = "UV"
		rec<3> = "UV.ACCOUNT"
		Write rec To VOC,'UV.ACCOUNT' On Error Abort
	End
$ENDIF

$IFNDEF U2__UNIVERSE
	!! SERVER一覧を取得
	serverListIds = ""
	serverList = ""
	Execute "LIST.SERVERS" CAPTURING out
	out = out[@FM,2,999]
	For Each line In out
		line = Trim(line)
		serverListIds<-1> = line[' ',1,1]
		serverList<-1> = line[' ',5,1]:"@":line[' ',2,1] ;** user@host
	Next line
$ENDIF

	bAutoCommand = @FALSE
	bAutoEditor = @FALSE
	dispType = ""
	
	!! 大文字小文字変換の初期化
	Perform "PTERM CASE ":If bInvert Then "INVERT" Else "NOINVERT"
	
	** DICT.DESCの取得
	Open 'DICT', 'VOC' To fpD.VOC Else Stop "Cannot Open 'DICT.VOC'"
	Read descIType From fpD.VOC,'DESC' Else Stop "Cannot Read 'DESC' in 'DICT.VOC'"
	Read typeIType From fpD.VOC,'TYPE' Else Stop "Cannot Read 'TYPE' in 'DICT.VOC'"
	Close fpD.VOC

	!! 共通のテンポラリ変数
	inputBox = ""         ;** １行入力用バッファ
	crtBuff = ""
	moveChar = "" ;** Move To Char モード
	filter = ""
	choiceParse = @False
	
	EQU REDRAW.ALL To -1
	Redraw = 0

	!! Editor用変数の初期化
	FldInfo = ""
	DiveValuePos = ""
	ParentBufNo = ""
	StatusMessage = ""
	ignoreCase = False

$IFDEF U2__UNIVERSE
	PROMPT.STR = ">"
$ELSE
	PROMPT.STR = ":"
$ENDIF

Shell.Input.Begin:

	bFirstCurTop = @TRUE ;** カーソルを画面の最上部に初めての移動か

	** Ctrl+C のIntruputを @28(Ctrl+\ or Break) に変更
	** 自動ページングをON
$IFDEF U2__UNIVERSE
	Perform "PTERM INTR ^Q"
	assign 0 to system(1005)
$ELSE
	x = PTERM(3,28)
	x = PTERM(4,@FALSE)
	
	!! COMO中ならコマンド入力中はサスペンドにする
	IF SYSTEM(1033) AND NOT(SYSTEM(1034)) THEN
		EXECUTE "COMO SUSPEND" SILENT
		isComoActive = @TRUE
	END ELSE
		isComoActive = @FALSE
	END
$ENDIF

	candidateMode = ""
	candidateFilter = ""
	slistCacheType = ""
	pageNum = 0
	
	dictName = ""

	cmdStackPos = 1
	cmdStackPage = ""
	
	curPos = 1 ;** cmdline上のカーソル位置
	cmdline = ""
	prev.dispRows = 0
	
	selCurStart = 0
	selCurEnd = 0
	bIncSearch = "" ;** インクリメンタルサーチモード
	iSearchText = ""
	
	!!
	!! 表示の初期化
	!!
	
	** 端末のウィンドウタイトルを変更する
	If prevPath >< @PATH Then
		
		!! アカウントをスタックする(LRU)
		If prevPath Then
			Find prevPath In logtoStack Setting f Then
				Del logtoStack<f>
			End
			Ins prevAccount:@VM:prevPath Before logtoStack<1>
		End
		
		** 前のパスと違っている時のみ実施する
		prevPath = @PATH
		prevAccount = @ACCOUNT
		account = prevAccount
		logname = @LOGNAME
$IFNDEF U2__UNIVERSE
		logname = @HOSTNAME:"\":logname
$ENDIF
		act.title = "QM [":@TTY:"] ":account['/',DCount(account,'/'),1]:" @ ":logname:" (":System(18):")"
		
		** コマンドスタック保存ファイルから復元を試みる
		logFile = @LOGNAME:"$":MY_COMMAND
$IFDEF U2__UNIVERSE
		OpenPath STACK.FILE To fpStack Then
$ELSE
		OpenPath STACK.FILE ENCODING "UTF8" To fpStack Then
$ENDIF
			LRUOpenList = ""
			cmdStack = "<NEWLINE>"
			cmdStack.cnt = 0
			Read stack From fpStack,logFile Then
				stack.cnt = DCount(stack,@FM)
				If stack.cnt > 10000 Then
					!! 10000件までにする
					Write stack[@FM,stack.cnt-10000,10000] To fpStack,logFile On Error Print "Cannot Write Stack Log -> ":STACK.FILE:"/":logFile
				End
				Loop
					line = stack<stack.cnt>
					cnt = DCount(line,@VM)
					cmdline = Field(line,@VM,1,cnt-1)[21,999999]
					retCode = Field(line,@VM,cnt)
$IFDEF U2__UNIVERSE
					cond = (cmdline And cmdline[1,1] <> ' ')
$ELSE
					!! OpenQM版は取り込むコマンドの精度を上げる
					cond = (cmdline And cmdline[1,1] <> ' ' And (retCode >= 0 Or retCode = -15 Or retCode = -7))
$ENDIF
					If cond Then
						cmdline = Convert(@VM,CHAR(10),Trim(cmdline))
						Find cmdline In cmdStack Setting pos Then
						End Else
							cmdStack<-1> = cmdline ;** 重複を省いて追加
							cmdStack.cnt += 1
							If cmdline[1,11]="READ.BUFFER" Then
								LRUOpenList<-1> = "0":TrimF(cmdline[" ",2,999])
							End
						End
					End
				While stack.cnt >= 0 And cmdStack.cnt <= CMD.STACK.SIZE
					stack.cnt -= 1
				Repeat
			End Else
				Write "" To fpStack,logFile On Error Print "Cannot Write Stack Log -> ":STACK.FILE:"/":logFile
			End
		End
		Close fpStack
	End

	stackPath = STACK.FILE:"/":logFile
	OpenSeq stackPath To fpStack Then
		stackPath = FileInfo(fpStack,2) ;** フルパスを取得
		closeSeq fpStack
	End
	
	cmdline = ""
	CurBuf = CMD_BUF
	BufInfo<BI.INDENTSIZE> = DEFAULT.INDENT

	crtBuff = ""
	C = "" ;** 入力文字
	MOUSE = "" ;** マウスデータ
	nowC = ""
	AutoWrap = @CRTWIDE+1 ;** コマンド編集は自動折り返しモード

	Y = 1
	prevY = 1
	prevDP_Y = 1
	prevX = 1
	GoSub CMDLINE2REC
	prevRec = Rec
	keepSelection	=@False
	
	!! 実行完了後にエディタを開く
	If bAutoEditor Then
		bAutoEditor = @FALSE
		GoTo Launch.Editor
	End
	
*
* キータイプのループ
*
Shell.KeyLoop.Start:
	Loop
		
		If bAutoCommand Then
			crtBuff = ""
			GoSub Clear.Cmdline.Crt
			Crt crtBuff:
			GoTo Run.Command
		End
		
		If Rec="" Then
			crtBuff = @(0):@(IT$CLEOS)
			Crt crtBuff:
			GoTo Shell.Input.Begin
		End
		
		Lines = DCount(Rec,@FM)
		
Set.Command.Editor:
				
		** --------------------------
		** X表示位置の計算
		** --------------------------
		moveY = prevY >< Y
		Line = Rec<Y> ;** 現在Y行
		If moveY And prevX = X Then
			** X位置を表示位置から逆算する
			GoSub GetX.From.keepDPX
			X = outX
		End
		
		If X <= prmptLen Then
			!! プロンプト内にカーソルを入れない処理
			If prevY+1=Y Then
				Y -= 1
				X = Len(Rec<Y>)+1
			End Else
				X = prmptLen+1
			End
		End Else If X >= Len(Rec<Y>)+1 Then
			X = Len(Rec<Y>)+1
		End
		
		!! 選択範囲の調整
		If keepSelection Then
			** 選択終了位置の設定
			If Not(BufInfo<BI.BLOCKEND>) Then
				BufInfo<BI.BLOCKEND> = Y:@VM:X
			End
			If BufInfo<BI.BLOCKSTART>=BufInfo<BI.BLOCKEND> Then
				BufInfo<BI.BLOCKSTART> = ""
				BufInfo<BI.BLOCKEND> = ""
			End
		End Else
			BufInfo<BI.BLOCKSTART> = ""
			BufInfo<BI.BLOCKEND> = ""
		End
! logmsg BufInfo<BI.BLOCKSTART>:" # ":BufInfo<BI.BLOCKEND>
		
		!! 描画処理
		GoSub Create.CmdDraw
		
		If prevDP_Y = DP_Y And prevX <> X Then
			** X位置だけが動いた場合にkeepDP_Xを変える
			keepDP_X = DP_X
		End
		
		!!
		!! 表示
		!!
		
		!! カーソルを先頭に持ってきてクリア
		crtBuff = ""
		crtBuff := SGR.ALL.OFF2
		GoSub Clear.Cmdline.Crt
		
		If NOT(IS.CONSOLE) Then
			crtBuff := CHAR(27):"]2;":act.title:CHAR(7)
		End
		GoSub Draw.Cmdline
		GoSub Draw.Cmdline.Cursor
		GoSub CRT.BUFF.FLUSH
		
Shell.KeyLoop.Bef.GetKey:
		
		!! 前回位置として保存しておく
		prevY = Y
		prevX = X
		prevDP_Y = DP_Y
		prev.dispRows = dispRows
		
		NokoriKouho = @FALSE
		bFirstTab = @TRUE
		
		prevC = nowC ;** 前回の入力文字を保持
		
		!! キー入力待ち
		GoSub GetKey
		
		nowC = C
		
		Changed = False ;** コマンドラインの編集を感知する為
		
		keepSelection = @FALSE
		
		If bIncSearch Then
INC.SEARCH.MODE:
			!! インクリメンタル検索モード
			BEGIN CASE
				CASE actNo = A.TAB
					GoSub CmdHist.Candidate
					GoTo Shell.KeyLoop.End
				CASE actNo = A.INSCHAR
					iSearchText := C
					stackPos = cmdStackPos
					GoSub ACTION.CMDSTACK.INC.SEARCH
					GoTo Set.Command.Editor
				CASE actNo = A.BACKSPACE
					If Len(iSearchText) > 0 Then
						iSearchText = iSearchText[1,Len(iSearchText)-1]
						stackPos = cmdStackPos
						GoSub ACTION.CMDSTACK.INC.SEARCH
						GoTo Set.Command.Editor
					End
					GoTo Shell.KeyLoop.End
				CASE C = CTRL.R
					!! コマンド履歴逆順インクリメンタルサーチ
					If bIncSearch <> "R" Then
						If bIncSearch = "" Then
							GoSub GET.SELECTION.STRING
							iSearchText = selString
						End
						bIncSearch = "R"
						stackPos = cmdStackPos
					End Else
						stackPos = cmdStackPos
						If bIncSearch#"" Then
							cmdStackPos += 1
						End
					End
					GoSub ACTION.CMDSTACK.INC.SEARCH
					GoTo Shell.KeyLoop.End
				CASE C = CTRL.F
					!! コマンド履歴正順インクリメンタルサーチ
					If bIncSearch <> "F" Then
						If bIncSearch = "" Then
							GoSub GET.SELECTION.STRING
							iSearchText = selString
						End
						bIncSearch = "F"
						stackPos = cmdStackPos
					End Else
						stackPos = cmdStackPos
						If bIncSearch#"" Then
							cmdStackPos -= 1
						End
					End
					GoSub ACTION.CMDSTACK.INC.SEARCH
					GoTo Shell.KeyLoop.End
				Case actNo = A.NEWLINE
				CASE 1
					bIncSearch = ""
					iSearchText = ""
					GoTo Shell.KeyLoop.End
			End Case
		End 
		
		!!
		!! キーハンドリング
		!!
		Begin Case
			Case actNo = A.UP
				GoSub Act.Up
				If Y<1 Then
					!! 上の履歴に切り替える
					GoSub GET.CMDLINES
					GoSub Upd.CmdStackPage
					GoSub ACTION.CMDSTACK.NEXT
					GoSub CMDLINE2REC
				End
			Case actNo = A.SEL_UP
				If BufInfo<BI.BLOCKSTART,2>=1 Or BufInfo<BI.BLOCKEND,2>=1 Then
					keepSelection = @TRUE
					Y -= 1
				End Else
					BufInfo<BI.BLOCKEND> = ""
					GoSub Act.SelUp
				End
				If prevY#Y Then
					!! 行選択モード
					GoSub CmdRow.Inc.Up
				End
			Case actNo = A.PREVSTMT Or actNo = A.SEL_PREVSTMT
				If BufInfo<BI.BLOCKSTART,2>=1 Or BufInfo<BI.BLOCKEND,2>=1 Then
					If actNo = A.PREVSTMT Then
						!! 行選択中なら選択行と上の行を入れ替え
						GoSub Act.SwapUp
					End Else
						!! コマンド行を上に5つ広げる
						For ii=1 To 5
							If Y = 1 Then Y = -1 Else Y-=1
							GoSub CmdRow.Inc.Up
						Next ii
					End
				End Else
					If actNo = A.PREVSTMT Then
						If BufInfo<BI.BLOCKSTART> Then
							!! 現状行内の入れ替えは非対応
							BufInfo<BI.BLOCKSTART> = Y:@VM:1
							BufInfo<BI.BLOCKEND> = (Y+1):@VM:1
							GoSub Act.SwapUp
							GoTo Shell.KeyLoop.Start
						End
						GoSub Act.Up
					End Else
						GoSub Act.SelUp
					End
					If prevY=Y Then
						!! 行内移動
						Loop
						While tmpDY>1
							If actNo = A.PREVSTMT Then GoSub Act.Up Else GoSub Act.SelUp
						Repeat
					End Else
						If Y<1 Then
							If actNo = A.PREVSTMT Then
								Y = 1
								!! 履歴を5つ戻る
								GoSub GET.CMDLINES
								GoSub Upd.CmdStackPage
								For ii=1 To 5
									GoSub ACTION.CMDSTACK.NEXT
								Next ii
								GoSub CMDLINE2REC
							End Else
								!! コマンド行を上に5つ広げる
								For ii=1 To 5
									Y = -1
									GoSub CmdRow.Inc.Up
								Next ii
							End
						End Else
							For ii=1 To 4
								If Y<=1 Then
									Y = 1
									Exit
								End
								If actNo = A.PREVSTMT Then
									GoSub Act.Up
								End Else
									Y -= 1
									GoSub CmdRow.Inc.Up
								End
							Next ii
						End
					End
				End
			Case actNo = A.DOWN
				GoSub Act.Down
				If Y>Lines Then
					!! 下の履歴に切り替える
					If 1<cmdStackPos Then
						GoSub GET.CMDLINES
						GoSub Upd.CmdStackPage
						GoSub ACTION.CMDSTACK.BACK
						GoSub CMDLINE2REC
						Y = Lines
						X = Len(Rec(Y))+1
						keepDP_X = 999
					End Else
						Y = Lines
					End
				End
			Case actNo = A.SEL_DOWN
				If BufInfo<BI.BLOCKSTART,2>=1 Or BufInfo<BI.BLOCKEND,2>=1 Then
					keepSelection = @TRUE
					Y += 1
				End Else
					BufInfo<BI.BLOCKEND> = ""
					GoSub Act.SelDown
				End
				If prevY#Y Then
					!! 行選択モード
					GoSub CmdRow.Inc.Down
				End
			Case actNo = A.NEXTSTMT Or actNo = A.SEL_NEXTSTMT
				If BufInfo<BI.BLOCKSTART,2>=1 Or BufInfo<BI.BLOCKEND,2>=1 Then
					If actNo = A.NEXTSTMT Then
						!! 行選択中なら選択行と上の行を入れ替え
						GoSub Act.SwapDown
					End Else
						!! コマンド行を下に5つ広げる
						For ii=1 To 5
							Lines = DCount(Rec,@FM)
							If Y>Lines Then Y = Lines+1 Else Y += 1
							GoSub CmdRow.Inc.Down
						Next ii
					End
				End Else
					If actNo = A.NEXTSTMT Then
						If BufInfo<BI.BLOCKSTART> Then
							!! 現状行内の入れ替えは非対応
							BufInfo<BI.BLOCKSTART> = Y:@VM:1
							BufInfo<BI.BLOCKEND> = (Y+1):@VM:1
							GoSub Act.SwapDown
							GoTo Shell.KeyLoop.Start
						End
						GoSub Act.Down
					End Else
						GoSub Act.SelDown
					End
					If prevY=Y Then
						nextDX = ""
						
						Line = Rec<Y>
						Line.len = Len(Line)
						tmpDX = 1
						For i=1 To Line.len
							c = Line[i,1]
							dispLen = LenDP(c)
							
							If i = X Then
								!! 現在位置
								nextDX = Max(tmpDX,keepDP_X)
							End Else
								If nextDX>=tmpDX Then
									X = i
								End
							End
							
							If c = @VM Or tmpDX+dispLen > AutoWrap Then
								* 改行
								tmpDX = 1
								If c = @VM Then dispLen = 0
							End
							
							tmpDX += dispLen
							
						Next i
					End Else
						If Y>Lines Then
							If actNo = A.NEXTSTMT Then
								!! 履歴を5つ進む
								GoSub GET.CMDLINES
								GoSub Upd.CmdStackPage
								For ii=1 To 5
									Y = 2
									GoSub ACTION.CMDSTACK.BACK
								Next ii
								GoSub CMDLINE2REC
							End Else
								!! コマンド行を下に5つ広げる
								For ii=1 To 5
									Y = Lines
									GoSub CmdRow.Inc.Down
								Next ii
							End
						End Else
							For ii=1 To 4
								If Y>=Lines Then Exit
								If actNo = A.NEXTSTMT Then
									GoSub Act.Down
								End Else
									Y += 1
									GoSub CmdRow.Inc.Down
								End
							Next ii
						End
					End
				End
			Case actNo = A.TOP
				GoSub GET.CMDLINES
				GoSub Upd.CmdStackPage
				Loop
					GoSub ACTION.CMDSTACK.NEXT
					If cmdStackPos = DCount(cmdStack,@FM) - 1 Then Exit
				Repeat
				GoSub CMDLINE2REC
			Case actNo = A.BOTTOM
				GoSub GET.CMDLINES
				GoSub Upd.CmdStackPage
				cmdStackPos = 1
				no = cmdStackPos
				GoSub Get.Cmdline.From.StackPage
				GoSub CMDLINE2REC
				Y = Lines
				X = Len(Rec(Y))+1
				keepDP_X = 999
			Case actNo = A.SEL_TOP ;** 無効
			Case actNo = A.SEL_BOTTOM ;** 無効
			Case actNo = A.COPY
				If BufInfo<BI.BLOCKSTART,2>=1 Or BufInfo<BI.BLOCKEND,2>=1 Then
					!! 行選択モード
					GoSub GET.CMDLINES
					cmdline = cmdline[@FM,blockStart<1>,blockEnd<1>-blockStart<1>]
					cmdline = Convert(@FM:@VM,CHAR(13):CHAR(13),cmdline)
					selString = cmdline
					GoSub Act.Copy.Impl
				End Else
					GoSub Act.Copy
				End
			Case actNo = A.SEL_ALL
				keepSelection = @True
				A = Y:@VM:prmptLen+1
				B = Y:@VM:Len(Rec<Y>)+1
				If BufInfo<BI.BLOCKSTART>=A  And BufInfo<BI.BLOCKEND>=B  Then
					!! 全行選択
					BufInfo<BI.BLOCKSTART,1> = 1
					BufInfo<BI.BLOCKSTART,2> = 1
					BufInfo<BI.BLOCKEND,1> = Lines+1
					BufInfo<BI.BLOCKEND,2> = 1
				End Else
					!! 1行内全選択
					BufInfo<BI.BLOCKSTART> = A
					BufInfo<BI.BLOCKEND> = B
				End
				
		** 文字入力系  
			Case actNo = A.TAB
				candidateMode = "FLATREC"
				filter = ""
				GoSub TAB.HOKAN
				
			Case actNo = A.HELP
				GoSub COMMAND.HELP
				
			Case C = CTRL.S
				If BufInfo<BI.BLOCKSTART> Then
					GoSub GetSelBlock
					If blockStart<2>=1 Then
						!! 行選択中のものを保存
						GoSub GET.CMDLINES
						cmdline = cmdline[@FM,blockStart<1>,blockEnd<1>-blockStart<1>]
						GoSub DoNew
						Rec = "PA Created at ":OConv(Date(),"D-YMD"):" ":OConv(Time(),"MTS"):" by ":@LOGNAME:"@":@ACCOUNT
						Rec<-1> = cmdline
						FileName = "VOC"
						GoSub StartBuf
						GoTo Launch.Editor
					End
				End
				
			Case C = CTRL.T
				GoSub ACTION.INPUT.PREV.FILENAME
				
			Case C = CTRL.N
				GoSub ACTION.INPUT.PREV.EDITITEM
				
			Case C = CTRL.P
				GoSub ACTION.INPUT.PREV.EDITPATH
				
			Case C = CTRL.R
				GoTo INC.SEARCH.MODE
				
			Case C = CTRL.F
				GoTo INC.SEARCH.MODE
				
			Case C = CTRL.L
				If cmdStackPos = 1 Then
					!! 前回の.Lを実行
					cmdline = prevListStackCmd
				End Else
					cmdline = ".L"
				End
				bAutoCommand = @TRUE
				
			Case actNo = A.NEWLINE
				If C # CTRL.M Then ;** Ctrl+Enterでコマンドを改行する
					editCmd = ""
					If BufInfo<BI.BLOCKSTART> Then
						** 選択中
						editCmd<1> = BufInfo<BI.BLOCKEND, 1>
						editCmd<2> = BufInfo<BI.BLOCKEND, 2>
						editCmd<3> = BufInfo<BI.BLOCKSTART, 1>
						editCmd<4> = BufInfo<BI.BLOCKSTART, 2>
					End Else
						editCmd<1> = Y
						editCmd<2> = X
						editCmd<3> = Y
						editCmd<4> = Len(Rec<Y>)+1
					End
					editCmd<5> = CHAR(10):FMT(":",prmptLen:"R"):(If Rec<Y>[X,1] >< "" Then Rec<Y>[X,HUGE] Else "")
					editCmd<6> = ""
					GoSub StackEditCmd
				End Else
					GoSub GET.CMDLINES
					If BufInfo<BI.BLOCKSTART> Then
						GoSub GetSelBlock
						If blockStart<2>=1 Then
							cmdline = cmdline[@FM,blockStart<1>,blockEnd<1>-blockStart<1>]
						End Else
							cmdline = cmdline<blockStart<1>>
						End
					End
					bAutoCommand = @TRUE
				End
				
			Case C = "@J"
				
			Case actNo = A.CASEINVERT
				GoSub Act.ToggleCaseInvert
			
		** イベント
			Case actNo = A.THEME
				GoSub Act.SwitchTheme
				CRT SGR.ALL.OFF2:

			Case actNo = A.FIT.TERM
				!! 端末サイズ自動設定
				GoSub AutoTermSize
				
			Case actNo = A.EXIT
				!! エディタ起動
				If Not(bFirstCurTop) Then
					** 代替画面バッファ開いてる場合は閉じる
					crtBuff = ""
					GoSub BackAltScreenBuf
					Crt crtBuff:
					bFirstCurTop = @TRUE
				End
				!! 強制的に端末サイズに合わせる
				If @TTY = 'console' Then
					A = "TERM ":@CRTWIDE:",":@CRTHIGH
					IF @TERM.TYPE = 'msvt' THEN A:=" qmterm":@FM:"TERM msvt"
					Execute A
				END ELSE
					Crt CSI:"8;":@CRTHIGH:";":@CRTWIDE:"t":
				END
Launch.Editor:
				GoSub Editor.Main
				prevY = Y
			
			Case actNo = A.CANCEL
				If Not(bFirstCurTop) Then
					** 代替画面バッファ開いてる場合は閉じる
					crtBuff = ""
					GoSub BackAltScreenBuf
					Crt crtBuff:
					bFirstCurTop = @TRUE
				End
				
			Case 1
				!! 共通処理
				
				!! 大文字小文字反転処理
				If actNo = A.INSCHAR And bInvert And n <> -1 And Len(C) = 1 Then
					C = Convert("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz","abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ",C)
				End
				
				If actNo = A.BACKSPACE Or actNo = A.DELETE_BACKWORD Then
					If BufInfo<BI.BLOCKSTART,2>#1 Then
						If X <= prmptLen+1 Then
							If Y>1 Then
								!! 行頭なら行の削除を行う
								BufInfo<BI.BLOCKEND> = Y:@VM:X
								Y -= 1
								X = Len(Rec<Y>)+1
								BufInfo<BI.BLOCKSTART> = Y:@VM:X
								GoSub Act.DelBackCh
							End
						End Else
							If actNo = A.DELETE_BACKWORD Then
								GoSub Act.DelBackWord
							End Else
								GoSub Act.DelBackCh
							End
						End
					End
				End Else
					GoSub Input.Actions
!						If actNo = A.LEFT Or actNo = A.RIGHT Or actNo = A.PREVWORD Or actNo = A.NEXTWORD Then
!							!! カーソル移動なら描画高速化
!							DP_X = X
!							GoSub Draw.Cmdline.Cursor
!							GoSub CRT.BUFF.FLUSH
!							GoTo Shell.KeyLoop.Bef.GetKey
!						End
!						End Else If actNo = A.INSCHAR And UniSeq(C) < 127 And BufInfo<BI.BLOCKSTART> = "" Then
!						If actNo = A.INSCHAR And UniSeq(C) < 127 And BufInfo<BI.BLOCKSTART> = "" Then
!							!! 半角文字なら描画高速化
!							CRT (IF IS.CONSOLE AND @TERM.TYPE # 'msvt' THEN @(-19) ELSE CSI:"1@"):C:
!							GoTo Shell.KeyLoop.Bef.GetKey
!						End
				End
			
		End Case
		
		prevActNo = actNo
		
Shell.KeyLoop.End:
	Repeat
	
GoTo Shell.KeyLoop.Start; * キー入力待ちに戻る

GET.PROMPTLEN:
	prmptLen = 3
	If cmdStackPos>1 Then
		prmptLen += Maximum(Len(cmdStackPos-1):@FM:2)
	End
	If System(11) Then prmptLen += 1
	Return

GET.CMDLINES:
	Lines = DCount(Rec,@FM)
	cmdline = Rec<1>[":",2,999]
	If cmdline[1,1]=":" Then cmdline = cmdline[2,BIG]
	For i=2 To Lines
		a = Rec<i>[":",2,999]
		If a[1,1]=":" Then a = a[2,BIG]
		cmdline<-1> = a
	Next i
	
	Return

* ---------------------------
* コマンド行を上に１つ広げる
* ---------------------------
CmdRow.Inc.Up:
	keepSelection = @True
	If Y<1 Then
		!! 枠を増やす
		cmdStackPos += 1
		prev.prmptLen = prmptLen
		GoSub GET.PROMPTLEN
		If prev.prmptLen # prmptLen Then
			!! Cancel
			cmdStackPos -= 1
			prmptLen = prev.prmptLen
			Return
		End
		Y = 1
		X = 1
		no = cmdStackPos
		GoSub Get.Cmdline.From.StackPage
		GoSub CMDLINE2TEMP
		InsBuffer = Temp:@FM
		tmpY = BufInfo<BI.BLOCKSTART,1>+cnt
		BufInfo<BI.BLOCKSTART> = ""
		GoSub InsertLines
		If tmpY=1 Then tmpY = 2
		BufInfo<BI.BLOCKSTART> = tmpY:@VM:2
		Y = 1
	End
	If BufInfo<BI.BLOCKSTART,1> <= Y Then
		BufInfo<BI.BLOCKEND> = Y+1:@VM:1
		IF BufInfo<BI.BLOCKSTART,2>#1 Then
			BufInfo<BI.BLOCKSTART> = BufInfo<BI.BLOCKSTART,1>:@VM:1
		End
	End Else
		BufInfo<BI.BLOCKEND> = Y:@VM:1
		IF BufInfo<BI.BLOCKSTART,2>#1 Then
			BufInfo<BI.BLOCKSTART> = (BufInfo<BI.BLOCKSTART,1>+1):@VM:1
		End
	End
	Return
	
* ---------------------------
* コマンド行を下に１つ広げる
* ---------------------------
CmdRow.Inc.Down:
	keepSelection = @True
	If Y>Lines Then
		!! 下の枠を増やす
		If cmdStackPos<=1 Then Return
		cmdStackPos -= 1
		prev.prmptLen = prmptLen
		GoSub GET.PROMPTLEN
		If prev.prmptLen # prmptLen Then
			!! Cancel
			cmdStackPos += 1
			prmptLen = prev.prmptLen
			Return
		End
		no = cmdStackPos
		GoSub Get.Cmdline.From.StackPage
		GoSub CMDLINE2TEMP
		Rec<-1> = Temp
	End
	If BufInfo<BI.BLOCKSTART,1> <= Y Then
		BufInfo<BI.BLOCKEND> = Y+1:@VM:1
		IF BufInfo<BI.BLOCKSTART,2>#1 Then
			BufInfo<BI.BLOCKSTART> = BufInfo<BI.BLOCKSTART,1>:@VM:1
		End
	End Else
		BufInfo<BI.BLOCKEND> = Y:@VM:1
		IF BufInfo<BI.BLOCKSTART,2>#1 Then
			BufInfo<BI.BLOCKSTART> = (BufInfo<BI.BLOCKSTART,1>+1):@VM:1
		End
	End
	Return

*---------------------------
* ターミナルサイズの自動設定
*---------------------------
AutoTermSize:
	Crt CSI:"18;;t": ;** 端末サイズ教えて
	GoSub GetKey
	If C Matches "'":ESC:"[8'...'t'" Then
		** DECSLPP -> CSI Ps1 ; Ps2 ; Ps3 t
		csiPrm = C[3,HUGE]['t',1,1]
		** 端末サイズを指定のサイズにする
		wide = csiPrm[';',3,1]
		high = csiPrm[';',2,1]
	End Else
		Return
	End
	
	If @CRTWIDE:@CRTHIGH >< wide:high Then
		!! サイズが変わった
		cmdline = "TERM ":wide:",":high
		bAutoCommand = @TRUE
	End
	
	Return

*---------------------
* コマンドライン描画
*---------------------
Create.CmdDraw:
	
	cmdDraw = "" ;** 描画構築済み
	
	If BufInfo<BI.BLOCKSTART> Then
		GoSub GetSelBlock
	End
	
	!! 対応する括弧情報を取得
	kakko1 = "" ;** 開き括弧情報(必ず1回は初期化される)
	OldLine = Rec<Y>
	stCh = OldLine[X,1] ;** 現在カーソル文字の再取得
	If stCh >< "" Then
		ki = Index(KAKKO.CHAR.LIST1,stCh,1) 
		If ki Then
			If ki < 5 Or (ki >= 5 And Rem(Count(OldLine[1,X],stCh),2)=1) Then
				Mask = ""
				iX = X
				moveDir = 1
				enCh = KAKKO.CHAR.LIST2[ki,1]
				GoSub Get.kakko
				kakko1 = kakko
			End
		End
	End
	kakko2 = "" ;** 閉じ括弧情報(必ず1回は初期化される)
	stCh = OldLine[X-1,1] ;** 現在カーソル文字の再取得
	If stCh >< "" Then
	!! 閉じ括弧調査
		ki = Index(KAKKO.CHAR.LIST2,stCh,1) 
		If ki Then
			If ki < 5 Or (ki >= 5 And Rem(Count(OldLine[1,X],stCh),2)=0) Then
				Mask = ""
				iX = X-1
				moveDir = -1
				enCh = KAKKO.CHAR.LIST1[ki,1]
				GoSub Get.kakko
				kakko2 = kakko
			End
		End
	End
	
	in.selection = @False
	tmpDY=1
	For Row=1 To Lines
		If Row>1 Then cmdDraw := ESC.CRT.MOVE_NEXT_LINE
		If BufInfo<BI.BLOCKSTART> Then
			!! 行選択モードの反転表示
			cmdDraw := If blockStart<2>=1 And blockStart<1> <= Row And blockEnd<1> > Row Then CSI:"7m" Else CSI:"27m"
		End
		Line = Rec<Row>
		Line.len = Len(Line)
		tmpDX = Index(Line,":")
		wrapDiffDX = 0
		
		If Row=1 Then
			If bIncSearch Then
				cmdDraw := HI.SHELL.ON
				cmdDraw := If bIncSearch="R" Then "↑" Else "↓"
				cmdDraw := SGR.ALL.OFF2
				cmdDraw := @(2):" ":iSearchText:" "
				wrapDiffDX += 4 + LenDP(iSearchText)
			End
			cmdDraw := HI.SHELL.ON
			If System(11) Then
				cmdDraw := "#"
				wrapDiffDX += 1
			End
			cmdDraw := If bInvert Then UpCase("si") Else "si"
			cmdDraw := MatchField(Line[1,tmpDX],"...0N:",2)
		End Else
			If bIncSearch Then
				cmdDraw := Str(" ",Len(iSearchText)+4)
			End
			cmdDraw := HI.SHELL.ON
			cmdDraw := Line[1,tmpDX-1]
		End
		cmdDraw := PROMPT.STR
		cmdDraw := HI.SHELL.OFF
		tmpDX += 1
		For i=tmpDX To Line.len+1
			c = Line[i,1]
			dispLen = LenDP(c)
			If tmpDX+dispLen+wrapDiffDX > AutoWrap Then
				!! 自動折り返し
				cmdDraw := ESC.CRT.MOVE_NEXT_LINE
				tmpDX = 1
				tmpDY += 1
			End
			
			IF Row = Y Then
				If i = X Or (i = Line.len+1 And i < X) Then
					DP_X = tmpDX
					DP_Y = tmpDY
				End
			End
			
			If BufInfo<BI.BLOCKSTART> Then
				!! 選択範囲の描画
				A = Row:@FM:i
				If blockStart = A Then
					cmdDraw := HI.SELECT.ON
					in.selection = @True 
				End Else If blockEnd = A Then
					cmdDraw := SGR.ALL.OFF2
					in.selection = @False
				End
			End Else
				If kakko1 Then
					!! 対応する括弧を強調
					If c#"\" And Row = Y And (i=kakko1<1> Or i=kakko1<2>) Then
						cmdDraw := HI.KAKKO.ON
					End
				End
				If kakko2 Then
					!! 対応する括弧を強調
					If c#"\" And Row = Y And (i=kakko2<1> Or i=kakko2<2>) Then
						cmdDraw := HI.KAKKO.ON
					End
				End
			End
			
			If c = @VM Then
				!! 改行
				If in.selection Then
					cmdDraw := NEWLINE.DISP:ESC.CRT.MOVE_NEXT_LINE
				End Else
					cmdDraw := FG.BASE1:NEWLINE.DISP:FG.DEFAULT:ESC.CRT.MOVE_NEXT_LINE
				End
				tmpDX = 1
				tmpDY += 1
			End Else
				If c=Char(9) Then
					A = STDTAB-1-REM((If tmpDX=1 Then 2 Else tmpDX-1),STDTAB)
					cmdDraw := " ":Space(A)
					tmpDX += 1+A
				End Else
					cmdDraw := c
					tmpDX += dispLen
				End
			End
			
			If Not(BufInfo<BI.BLOCKSTART>) Then
				If kakko1 Then
					!! 対応する括弧を強調
					If c#"\" And Row = Y And (i=kakko1<1> Or i=kakko1<2>) Then
						cmdDraw := SGR.ALL.OFF2
					End
				End
				If kakko2 Then
					!! 対応する括弧を強調
					If c#"\" And Row = Y And (i=kakko2<1> Or i=kakko2<2>) Then
						cmdDraw := SGR.ALL.OFF2
					End
				End
			End
			
		Next i
		tmpDY += 1
	Next Row
	
	If BufInfo<BI.BLOCKSTART> Then cmdDraw := CSI:"27m"
	
	dispRows = tmpDY-1
	
!	logmsg Y:",":X:" # ":DP_Y:",":DP_X:"(":keepDP_X:") <--- ":prevY:",":prevX:" # ":prevDP_Y
	Return

Draw.Cmdline:
	
	crtBuff := cmdDraw
	
Return

Draw.Cmdline.Cursor:
	* カーソル表示
	If IS.CONSOLE Then
		If Lines - Y > 0 Then
			crtBuff := @(-10,Lines - Y)
		End
		crtBuff := @(0)
		If bIncSearch Then
			crtBuff := @(3+Len(iSearchText))
		End Else
			If DP_X > 1 Then crtBuff := @(DP_X-1)
		End
	End Else
		* @(IT$CUU)が正しいエスケープシーケンスを出力しないので、VT100のシーケンス直書き
		If dispRows - DP_Y > 0 Then
			crtBuff := CSI:(dispRows - DP_Y):'A'
		End
		crtBuff := CSI:"G"
		If bIncSearch Then
			crtBuff := CSI:3+Len(iSearchText):"C"
		End Else
			If DP_X > 1 Then crtBuff := CSI:(DP_X-1):"C"
		End
	End
Return

*---------------------
* コマンドラインクリア
*---------------------
Clear.Cmdline.Crt:
	If bFirstCurTop Then
		a = prev.dispRows
	End Else
		a = Max(prev.dispRows,dispRows)
	End
	If IS.CONSOLE Then
		crtBuff := @(0)
		If prevDP_Y > 1 Then
			crtBuff := @(-10,prevDP_Y-1)
		End
		crtBuff := @(-4)
		If a > 1 Then
			For i = 2 To a
				crtBuff := @(33):@(-4)
			Next i
			crtBuff := @(-10,a-1)
		End
	End Else
		crtBuff := CSI:'G'
		If prevDP_Y > 1 Then
			crtBuff := CSI:(prevDP_Y-1):'A'
		End
		crtBuff := CSI:'2K'
		If a > 1 Then
			For i = 2 To a
				crtBuff := CSI:'1B':CSI:'2K'
			Next i
			crtBuff := CSI:(a-1):'A'
		End
	End
Return

*---------------------
* コマンド実行
*---------------------
Run.Command:
	
	bAutoCommand = @FALSE
	
	crtBuff = ""
	If Not(bFirstCurTop) Then
		** 補完候補表示していたらアプリケーションモードから戻す
		GoSub BackAltScreenBuf
	End
	crtBuff := @(0):@(IT$CLEOS)
	Crt crtBuff:
	
	cmdlines = "" ;** 複数コマンド
	If Count(cmdline,@FM)=0 Then
		!! 単発コマンド
		verb = UPCASE(Trim(cmdline)[' ',1,1])
		If verb="Q" or verb="QUIT" Then
			!! 終了
			GoTo QUIT.SHELL
		End Else If verb[1,1] = "." Then
			!! シェル内部コマンド
			k = verb[2,1]
			Begin Case
				Case k = "A"
					GoTo ACTION.CMDSTACK.APPEND
				Case k = "C"
					GoTo ACTION.CMDSTACK.CHANGE
				Case k = "D"
					GoTo ACTION.CMDSTACK.DELETE
				Case k = "G"
					GoTo ACTION.CMDSTACK.GOTO
				Case k = "L"
					GoTo ACTION.CMDSTACK.LIST
				Case k = "R"
					GoTo ACTION.CMDSTACK.READ
				Case k = "S"
					GoTo ACTION.CMDSTACK.SAVE
				Case k = "X"
					** コマンド実行
					cmd = Convert(' ','-',Trim(cmdline[3,9999]))
					n = cmd['-',1,1]
					m = cmd['-',2,1]
					
					If n = "" And m = "" Then n = 1
					If m = "" Then m = n ;** 1行にする
					If Num(n) And Num(m) Then
						min_no = Minimum(n:@FM:m)
						max_no = Maximum(n:@FM:m)
						For i = max_no To min_no Step -1
							cmdlines<-1> = If cmdStackPage<i+1> <> "" Then cmdStackPage<i+1> Else cmdStack<i+1>
						Next i
					End
					
				Case k = "T"
					bTimer = Not(bTimer)
					Print ""
					If bTimer Then Print "時間計測ON" Else Print "時間計測OFF"
					GoTo Run.Command.Ending
				Case k = "E"
					If UpCase(Trim(cmdline)) = ".E" Then
						If System(11) Then
							cmdline = "READ.BUFFER #0"
						End Else
							cmdline = ""
							GoTo Launch.Editor ;** 単純にエディタに切り替える
						End
					End
					!! Verbをエディタに置換
					If UpCase(Trim(cmdline)[1,3]) = ".EP" Then
						!! Private VOC
						OPEN "PVOC,":@USER TO PVOC Then
							a = Trim(cmdline)[' ',2,9999]
							cmdline = "READ.BUFFER PVOC,":@USER:" ":a
						End
					End Else
						a = Trim(cmdline)[' ',2,9999]
						Read rec From VOC,a Then
							cmdline = "READ.BUFFER VOC ":a
						End
					End
					If cmdline Matches "READ.BUFFER..." Else 
						cmdline = "READ.BUFFER":cmdline[3,9999]
					End
					X += 9
				Case k = "O" ;** COMO出力
					IF SYSTEM(1033) THEN
						cmdline = "COMO OFF"
					END ELSE
						cmdline = "COMO ON LOG_":OConv(Date(),'DYMD["",""]'):"_":OConv(Time(),"MTS''")
					END
				Case k = "K"
					!! KeySeq表示モード
					GoSub Keys
					cmdline = ""
			End Case
		End
		
		!! LOGTO単体の場合はLOGTO履歴選択モードにする
		If Trim(cmdline)="LOGTO" Then
			If logtoStack Then
				a = logtoStack[@FM,1,10]
				wide1 = Maximum(LenS(VSLice(a,1)))+2
				Print ""
				For i = 1 To DCount(a,@FM)
					If a<i> = "" Then Exit
					Print i:" ":FMT(a<i,1>,wide1:"L"):" ":a<i,2>
				Next i
				Print "Choice":
				Input i,1
				If i # "" And Num(i) Then
					cmdline = "LOGTO ":DQUOTE(a<i,2>)
				End
			End
		End
		
	End Else
		!! 複数コマンド
		cmdlines = TRIM(cmdline,@FM,"T")
	End
	
	If cmdlines Then
		!! 複数コマンド内に制御文があればパラグラフとしてまとめて実行に変更する
		flg = @False
		cmd.cnt = DCount(cmdlines,@FM)
		For cmd.i=1 To cmd.cnt
			cmdline = cmdlines<cmd.i>
			a = UpCase(TrimF(cmdline)[" ",1,1])
			Find a In Convert(",",@FM,"LOOP,REPEAT,GO,$ECHO") Then
				flg = @True ;** 制御文
				Exit
			End
			If a[1]=":" Or cmdline[1]="_" Then
				flg = @True ;** ラベルか複数行コマンド
				Exit
			End
		Next cmd.i
		cmdline = cmdlines
		If flg Then
			!! パラグラフに変換
			cmdlines = ""
		End
	End
	!! 先頭が空文字でなければコマンドスタックの更新
	If cmdline#'' And cmdline[1,1] <> ' ' Then
		GoSub CmdStack.Push
	End
	
	bFirstCurTop = @TRUE
	
$IFNDEF U2__UNIVERSE
	IF isComoActive THEN
		!! COMOを実行前に復帰させる
		EXECUTE "COMO RESUME"
	END
$ENDIF

	** Ctrl+C のIntruputを戻す
	** 自動ページングをON
$IFDEF U2__UNIVERSE
	Perform "PTERM INTR ^C"
	assign 1 to system(1005)
$ELSE
	x = PTERM(3,3)
	x = PTERM(4,@TRUE)
$ENDIF

	@USER.RETURN.CODE = 999999999

	** VOCファイル一度閉じる
	Close VOC

	If cmdlines Then
		cmd.cnt = DCount(cmdlines,@FM)
		For cmd.i=1 To cmd.cnt
			cmdline = cmdlines<cmd.i>
			GoSub Run.Command.One
		Next
		cmdline = cmdlines
	End Else
		GoSub Run.Command.One
		If cmdline[1,11]="READ.BUFFER" AND @USER.RETURN.CODE=0 Then
			!! 単発の場合は実行後にエディタ画面に遷移
			bAutoEditor = @TRUE
		End
	End
	
	If cmdline#'' Then
		GoSub Write.Stack.log
	End
	
	** VOCファイルを開く
	Open 'VOC' To VOC Else Abort
	
	** 直前のファイル名を格納(2つ目の単語をファイル名とみなす単純実装)
	tmp = Trim(cmdline)[' ',2,1]
	If tmp >< "" Then
		Read rec From VOC,tmp[',',1,1] Then
			type = rec[1,1]
			If type = "F" OR type = "Q" Then prevFileName = tmp
		End
	End
	
Run.Command.Ending:
	cmdline = ""
	
!! 非同期メッセージの表示
$IFNDEF U2__UNIVERSE
	msgs = GET.MESSAGES()
	If msgs THEN PRINT CONVERT(@FM,CHAR(10),msgs)
$ENDIF

	GoTo Shell.Input.Begin ;* キーループに戻る


*---------------------
* コマンドを1行実行する
*---------------------
Run.Command.One:

	** コマンド行を出力(ECHO)
	If Index(cmdline,@FM)=0 Then
		crtBuff = BG.BASE2:HI.SHELL.ON:PROMPT.STR:HI.SHELL.OFF:Change(cmdline,@VM,CRLF)
	End Else
		crtBuff = ""
	End
	
	Crt crtBuff ;** 改行
	
	** 空コマンドは無視
	If cmdline = "" Then
		Return
	End

	verb = TRIMF(cmdline[" ",1,1])
	Begin Case
		Case verb = "READ.BUFFER"
			!! ファイルをバッファにリードする
			GoSub READ.BUFFER
			Return
		Case verb = "WRITE.BUFFER"
			!! バッファの内容をファイルにライトする
			GoSub WRITE.BUFFER
			Return
		Case verb = "TERM"
			IF @TERM.TYPE = 'msvt' AND cmdline MATCHES "...1N0N..." THEN
				Execute cmdline : " qmterm":@FM:"TERM msvt"
			END	
	End Case

	!! 普通のコマンド起動
		
	!! 実行前の端末サイズ
	prevCrt = @CRTHIGH:@CRTWIDE

	If bTimer Then
		!! 時間計測開始
		startTime = Time()
		startTimeCpu = System(9)
	End

	!!
	!! ##### 実行 ######
	!!
	
	If has.Run.Command.Delegator Then
		cl = "SISH.RUN.COMMAND.DELEGATOR ":Convert(@FM,@IM,cmdline)
	End Else
		cl = Convert(@VM," ",cmdline)
	End
$IFDEF U2__UNIVERSE
	Perform cl
$ELSE
	Execute cl TRAPPING ABORTS
	If @ABORT.CODE Then
		IF @EXCEPTION = "SYS.PROGRAM.RESIZE_ERROR" THEN
			!! unnamed common missmatch error
			!! unnamed common をクリアするため自身を再起動して再実行
			Print ""
			Print FG.RED:"'Unnamed Common' has already been cleared, please re-run the same command.":FG.BASE03
			Print ""
		END
	End
$ENDIF

	If bTimer Then
		!! 時間計測開終了
		endTime = Time()
		endTimeCpu = System(9)
		Crt "実行時間  " : (endTime - startTime) : "s  (CPU時間  " : (endTimeCpu - startTimeCpu)/1000 : "s)":ESC.CRT.MOVE_NEXT_LINE:
	End
	
	!! 端末サイズ自動追従
	If Not(IS.CONSOLE) And prevCrt <> @CRTHIGH:@CRTWIDE Then
		Crt CSI:"8;":@CRTHIGH:";":@CRTWIDE:"t":
	End
	
	Return

Write.Stack.log:
	** コマンドスタックのファイル保存
$IFDEF U2__UNIVERSE
	OpenSeq stackPath To fpStack Then
$ELSE
	OpenSeq stackPath ENCODING "UTF8" To fpStack Then
$ENDIF
		retCode = (If @USER.RETURN.CODE = 999999999 Then @SYSTEM.RETURN.CODE Else @USER.RETURN.CODE)
		Seek fpStack, 0, 2 Else Abort "Seek Stack Log Error"
		dt = OConv(Date(),"D-YMD"):" ":OConv(Time(),"MTS")
		line = dt:" ":Convert(@FM,@VM,cmdline):@VM:retCode
		WriteSeq line To fpStack On Error Print "Cannot Write Stack Log -> ":stackPath Else ;
		CloseSeq fpStack
	End

	Return

*---------------------
* コマンドヘルプ表示
*---------------------
COMMAND.HELP:
	
	!! 候補なし
	dispType = ""

	!! TODO ヘルプファイルがあればヘルプ表示する
$IFNDEF U2__UNIVERSE
	@ID = Field(Trim(cmdline),' ',1)
	Read @RECORD From VOC,@ID Then
		!! Verb決定済み
		dispType = "Help"
		lines = ""
		type = @RECORD[1,1]
		If type Matches "P":@VM:"S" Then
			!! PH PQ S
			maxCnt = DCount(@RECORD,@FM)
			maxLen = Len(maxCnt)
			For i = 2 To maxCnt
 					lines<-1> = "  ":Fmt(i,"R%":maxLen):": ":@RECORD<i>
			Next i
		End Else If type = "V" Then
			!! Localカタログ
			srcPath = Change(Convert("\","/",@RECORD<3>),".OUT/","/")
			id = Last(srcPath,'/')
			path = srcPath[1,Len(srcPath)-Len(id)]
			rec = ""
			OpenPath path Encoding "UTF8.AD" To fp Then
				Read rec From fp,id Then
					maxCnt = DCount(rec,@FM)
					bDoc = @FALSE
					For i = 1 To maxCnt
						line = rec<i>
						If line Matches "...**...==..." Then ;** "** ==========" ~ "** ==========" まで
							lines<-1> = "  ":line[Index(line,"**",1)+2,999] ;** 先頭の"**"を省く
							If Not(bDoc) Then bDoc = @TRUE Else Exit
						End Else
							line = line[Index(line,"**",1)+2,999] ;** 先頭の"**"を省く
							xpos = Index(line,"**",1)
							If xpos Then
								line = line[1,xpos-1] ;** 次の"**"移行はコメントとして省く
							End
							line = Change(line,CHAR(9),Space(DEFAULT.INDENT)) ;** Tab -> space
							If bDoc Then lines<-1> = "  ":line
						End
					Next i
				End
				Close fp
			End Else
				Open "SW_HANYO" To fp Then
					Read rec From fp,id:".TXT" Then
						lines = rec
					End
					Close fp
				End
				IF lines="" And @RECORD<2> = "CA" Then
					lines<2> = "  コマンドの詳細は以下を参照"
					lines<3> = "  http://downloads.openqm.com/help/":DownCase(Convert('.','_',@ID)):".htm"
				End
			End
		End
		
		!! 描画
		GoSub CUR.TOP.OF.SCREEN
		
		crtBuff = ""
		crtBuff := SGR.ALL.OFF2
		GoSub Create.CmdDraw
		GoSub Clear.Cmdline.Crt
		GoSub Draw.Cmdline
		GoSub CRT.BUFF.FLUSH
		
		!! 候補リスト表示処理
		choiceNo = 1
		choiceList = lines
		title = dispType
		choiceOrgY = Lines
		filter = ""
		GoSub InitChoiceList
		
		Loop
			
			!! 選択リストボックス処理共通
			GoSub ProcChoiceList
			
			!! キー入力待ち
			GoSub GetKey
			Begin Case
				Case actNo = A.CANCEL ;** 抜ける
					!! 選択を非表示にして画面を残す
					choiceActive = @False
					GoSub ProcChoiceList
					Exit
				Case actNo = A.NEWLINE ;** 決定
					!! 選択行を中心にしてフィルターを外す
					actNo = A.DELETELINE
				Case actNo = A.TAB ;** モード切替
					candidateMode = "FLATREC"
					Crt @(winX,0):
					GoTo TAB.HOKAN
			End Case
			
		Repeat
		Crt @(winX,0):
		
	End
$ENDIF

Return

*---------------------
* TAB補完 Action
*---------------------
TAB.HOKAN:
	
	A = Rec<Y>
	cmdline = A[":",2,999]
	curPos = X - Len(A[":",1,1]) - 1 ;** プロンプト分減らす
	cmdline = Convert(CHAR(10)," ",cmdline)
	
	GoSub Setting.WordInfo
	
	fpTgtAccVOC = VOC
	tgtAccVOC = "VOC"
	tgtAccFile = ACCOUNT.FILE
	
$IFNDEF U2__UNIVERSE
	!! OSディレクトリ補完
	path = Convert('\"','/',nowWord)
	If (Count(path,'/') AND Count(path,":")=0) Or nowWord[1,5] = "PATH:" Or path[1,2] Matches "1A:" Then
		If path[1,5] = "PATH:" Then
			path = path[6,99]
			nowWord = nowWord[6,99]
		End
		filter = UpCase(Last(path,'/'))
		filter.len = Len(filter)
		parent = path[1,Len(path)-filter.len]
		dirPath = parent
		If dirPath = "" Then dirPath = "./"
		GoSub GetDirList
		
		If list#"" Then
			slist = ""
			slistU = ""
			dlist = ""
			a = Index(nowWord,'/')
			If a = 0 Then a = 9999
			b = Index(nowWord,'\')
			If b = 0 Then b = 9999
			pdelim = If a < b Then '/' Else '\'
			For Each line In list Delimiter @FM
				If UpCase(line[1,filter.len]) = filter Then
					id = line<1,1>:(If line<1,2>="D" Then pdelim Else " ")
					slist<-1> = id
					slistU<-1> = UpCase(id)
					dlist<-1> = ""
				End
			Next line
			
			nowWord = path[Len(parent)+1,99]
			GoSub Setting.WordInfo2
			GoSub Prev.Match.Filter
			If slist#"" Then
				candidateMode = ""
				dispType = "OS Path"
				GoTo Complate.Common
			End
		End
		Return
	End
$ENDIF

	If nowWordPos <= 1 Then
		
		* Verbの補完
		
		tgtVocTypes = "V,R,S,PA,PQ,M"
		GoSub Get.SList.From.Voc
		
		!! SISH専用コマンド
		id = ""
		desc = ""
		id<-1> = ".A"
		desc<-1> = ".An text | コマンドの末尾にテキストを追記"
		id<-1> = ".C"
		desc<-1> = ".Cn/old/new/G | コマンドの文字列置換"
		id<-1> = ".E "
		desc<-1> = ".E file item | エディタ起動"
		id<-1> = ".G"
		desc<-1> = ".Gn | 指定位置のコマンド履歴に移動"
		id<-1> = ".K"
		desc<-1> = ".K | キーシーケンス確認モード"
		id<-1> = ".L"
		desc<-1> = ".Ln filter | コマンド履歴の一覧表示"
		id<-1> = ".O"
		desc<-1> = ".O | COMO ON/OFF"
		id<-1> = ".R"
		desc<-1> = ".Rs-e | コマンドを履歴の先頭に読み込む"
		id<-1> = ".S "
		desc<-1> = ".Ss-e name | コマンド履歴をVOCにPAとして保存"
		id<-1> = ".T"
		desc<-1> = ".T | 時間計測モードON/OFF"
		id<-1> = ".X"
		desc<-1> = ".Xs-e | コマンド履歴を実行"
		idU = UpCase(id)
		
		Locate idU<1> In slistU By "AL" Setting no Else
			Ins id Before slist<no>
			Ins idU Before slistU<no>
			Ins desc Before dlist<no>
		End
		
		id = "READ.BUFFER"
		desc = "エディタのバッファに指定のファイルを読み込む(SISH内部コマンド)"
		idU = UpCase(id)
		Locate idU In slistU By "AL" Setting no Else
			Ins id Before slist<no>
			Ins idU Before slistU<no>
			Ins desc Before dlist<no>
		End
		
		id = "WRITE.BUFFER"
		desc = "エディタのバッファの内容をファイルを書き出す(SISH内部コマンド)"
		idU = UpCase(id)
		Locate idU In slistU By "AL" Setting no Else
			Ins id Before slist<no>
			Ins idU Before slistU<no>
			Ins desc Before dlist<no>
		End

		GoSub Prev.Match.Filter
		candidateMode = ""
		dispType = "Verb"
		GoTo Complate.Common
		
	End Else
	
		* Verbは決定済み
		words = Convert(", ",@FM:@FM,cmdline)
		
		** 初めの単語がLOGTOならアカウント補完
		If UpCase(words<1>)="LOGTO" Then
			
Account.Hokan:
			slist = ""
			slistU = ""
			dlist = ""
			Open tgtAccFile TO fpACCOUNT Then
				SelectV fpACCOUNT To sp
				Loop
					ReadNext @ID From sp Else Exit
					id = @ID
					If tgtAccFile <> ACCOUNT.FILE Then
						id := ":"
					End
					idU = UpCase(id)
					Locate idU In slistU By "AL" Setting no Else
						Ins idU Before slistU<no>
						Ins id Before slist<no>
						Read @RECORD From fpACCOUNT,@ID Then
$IFDEF U2__UNIVERSE
							desc = "===> ":@RECORD<11>:" ":@RECORD<15>
$ELSE
							desc = "===> ":@RECORD<1>:" ":@RECORD<2>
$ENDIF
							Ins desc Before dlist<no>
						End
					End
				Repeat
				Close fpACCOUNT
			End
			
			If slist#"" Then
				GoSub Prev.Match.Filter
				candidateMode = ""
				dispType = "ACCOUNT"
				GoTo Complate.Common
			End
			Return
		End
		
		** -- 特殊補完の前処理 --
		
		!! 対象の辞書を確定する
		dictType = "DICT";
		dictName = "";
		fpDICT = 0;
		Find "USING" In words Setting idx Then
			* USING使用
			If UpCase(words<idx+1>)="DICT" Then word = words<idx+2> Else word = words<idx+1>; dictType="";
			If word><nowWord Then
				Open dictType,word To fpDICT Then
					dictName = word
				End
			End
		End Else
			For i = 1 To 999
				word = Remove(words, sep);
				If word = "DICT" Then
					Open "DICT.DICT" To fpDICT Then
						dictName = "DICT.DICT"
						Exit
					End
				End Else If word >< nowWord Then
					Open dictType,word To fpDICT Then
						dictName = word
						Exit
					End
				End
				If sep=0 Then Exit;
			Next i
		End
		
$IFNDEF U2__UNIVERSE
		If Count(nowWord,"%") Then
			!! Linkフィールドか確認する(OpenQM)
			lastId = ""
			linkDictName = dictName
			
			lTypeFld = Convert("%",@FM,nowWord)
			Loop
				lastId = Remove(lTypeFld,sep)
				rec = Raise(Trans("DICT ":linkDictName,lastId,-1,"X"))
				If rec[1,1] = "L" Then
					linkDictName = rec<3>
					Read rec From VOC,linkDictName Then
						If rec[1,1] = "F" And rec<3> Then
							Continue
						End
					End
				End
			While sep
			Repeat
			
			If linkDictName <> dictName Then
				!! Linkの辞書ファイルに差し替える
				Open "DICT",linkDictName To fpDICT Then
					dictName = linkDictName
					nowWord = lastId
					GoSub Setting.WordInfo2
					candidateMode = "FIELD"
				End Else
					Open "DICT",dictName To fpDICT Then ;
				End
			End

			If prevC # CHAR(9) Then
				GoSub Get.SList.FIELD
				GoSub Prev.Match.Filter
				GoSub AUTO.COMPLATE
				dispType = dictType:" ":dictName:" "
				GoSub Disp.NokoriKouho
				Return
			End
			
		End
$ENDIF
		
		!! ファイルの検索先ターゲットアカウント情報
		
$IFNDEF U2__UNIVERSE
		If Count(nowWord,":") Then
			!! 拡張ファイルフォーマットか確認する(OpenQM)
			cnt = Count(nowWord,":")
			If cnt = 1 Then
				tmpName = nowWord[":",1,1]:":VOC"
				Open tmpName To fpTemp Then
					!! 対象のVOCをすり替える
					fpTgtAccVOC = fpTemp
					tgtAccVOC = tmpName
					nowWord = nowWord[":",2,9999]
					GoSub Setting.WordInfo2
				End Else
					!! サーバ名か確認する
					tmpName = nowWord[":",1,1]
					Locate tmpName In serverListIds<1> By "AL" Then
						!! アカウントのみ補完する特殊モード
						nowWord = nowWord[":",2,9999]
						tgtAccFile = tmpName:":QMSYS:QM.ACCOUNTS"
						GoSub Setting.WordInfo2
						GoTo Account.Hokan
					End
				End
			End Else If cnt => 2 Then
				tmpName = nowWord[":",1,2]:":VOC"
				Open tmpName To fpTemp Then
					!! 対象のVOCをすり替える
					fpTgtAccVOC = fpTemp
					tgtAccVOC = tmpName
					nowWord = nowWord[":",3,9999]
					GoSub Setting.WordInfo2
				End
			End
		End
$ENDIF
		
!		IF dictName="" Then
!			candidateMode="FILE" ;** 辞書未決定
!		End
		
		* 補完候補表示
		* オートコンプリート
		GoSub Get.SList.VOC
		GoSub Prev.Match.Filter
		slistAll = slist
		
		GoSub Get.SList.FILE
		GoSub Marge.SlistAll
		
		GoSub Get.SList.RECID
		GoSub Marge.SlistAll
		
		GoSub Get.SList.FIELD
		GoSub Marge.SlistAll
		
		GoSub Get.SList.FLATFILE
		GoSub Marge.SlistAll
		
		* オートコンプリート
		slist = slistAll
		
Complate.Common:
		If slist="" Then GoTo TAB.HOKAN.END
		
		GoSub AUTO.COMPLATE
		If bComprate And commonWord[1]#" " Then
			If candidateMode#"" Then
				prevC = ""
				GoTo TAB.HOKAN ;** 続きあり
			End
		End Else
			If bFirstCurTop Then
				If nowWord=commonWord Then
					If nowWord#"" Then
						GoSub Disp.NokoriKouho
					End Else
						GoSub CUR.TOP.OF.SCREEN
						prevC = CHAR(9)
						GoTo TAB.HOKAN ;** 続きあり
					End
				End
			End Else
				If prevC = CHAR(9) Then
					If nowWord#commonWord Then
						GoSub Setting.WordInfo
					End
					
					* 状態別候補表示処理
					Begin Case
					
					** 特殊補完
					Case candidateMode="FLATREC"
						
						GoSub Get.SList.FLATFILE
						
						dispType = "Directory ":flatFile
						
					* フィールド補完
					Case candidateMode="FIELD"
						
						GoSub Get.SList.FIELD
						
						dispType = dictType:" ":dictName
						
					** @ID補完
					Case candidateMode="RECID"
						
						GoSub Get.SList.RECID
						
						dispType = "@ID ":flatFile
						
					* FILE補完
					Case candidateMode="FILE"

						** 直前の単語がマルチパートファイルか調べる
						prevWord = words<nowWordPos-1>
						Read rec From VOC,prevWord Then
$IFNDEF U2__UNIVERSE
							If rec<1>[1,1] = "Q" Then
								!! QFileを辿る
								Loop
									rec = RTRANS(rec<2>:":VOC",rec<3>,-1,"X")
								While rec<1>[1,1] = "Q"
								Repeat
							End
$ENDIF
							If rec<1>[1,1] = "F" And rec<4> >< "" Then
								slist = ""
								slistU = ""
								dlist = ""
$IFDEF U2__UNIVERSE
								list = Convert(@VM,@FM,rec<7>)
$ELSE
								list = Convert(@VM,@FM,rec<4>)
$ENDIF
								Loop
									v = Remove(list,sep)
									slist<-1> = v:" "
									slistU<-1> = UpCase(v):" "
								While sep Do Repeat
								
								dispType = "MultiPart ":prevWord
								GoSub DispCandidate.Common
								
								GoTo TAB.HOKAN.END
							End
						End
						
						GoSub Get.SList.FILE
						
						dispType = "FILE"
						
					* VOC補完
					Case candidateMode="VOC"
						
						GoSub Get.SList.VOC
						
						dispType = "VOC"
						
					End Case
				
					GoSub DispCandidate.Common
					
				End Else
					If nowWord#"" Then
						GoSub Disp.NokoriKouho
					End
				End
			End
		End
		Close fpDICT
	End

TAB.HOKAN.END:

Return

Disp.NokoriKouho:
	If slist#"" Then
		!! 残りの候補を画面出力
		GoSub CUR.TOP.OF.SCREEN
		nowWord = commonWord
		GoSub Setting.WordInfo2
		choiceNo = 0
		choiceList = slist
		title = dispType
		choiceOrgY = Lines
		crtBuff = ""
		GoSub InitChoiceList
		choiceActive = @False
		GoSub ProcChoiceList
		Crt @(winX,0):
	End
Return

Marge.SlistAll:
	Loop
		id = Remove(slist,sep)
		idU = Remove(slistU,sep)
		If idU[1,nowWord.len] = nowWordU Then
			Locate id In slistAll By "AL" Setting i Else Ins id Before slistAll<i>
		End
	While sep
	Repeat
Return

CmdHist.Candidate:
	
	!! 描画
	GoSub CUR.TOP.OF.SCREEN
	
	filter = iSearchText
	bIncSearch = ""
	iSearchText = ""
	
	crtBuff = ""
	crtBuff := SGR.ALL.OFF2
	GoSub Create.CmdDraw
	GoSub Clear.Cmdline.Crt
	GoSub Draw.Cmdline
	GoSub CRT.BUFF.FLUSH

	!! 候補リスト表示処理
	choiceList = ""
	cmdStack.len = DCount(cmdStack,@FM)
	no.fmt = Len(cmdStack.len):"R"
	For i = cmdStack.len To 2 Step -1
		choiceList<-1> = Fmt((i-1),no.fmt):"  ":Change(Change(cmdStack<i>,"_":CHAR(10)," "),CHAR(10)," :"):@VM:i
	Next i
	choiceNo = cmdStack.len - cmdStackPos + 1
	title = "Cmd Hist"
	choiceOrgY = dispRows
	GoSub InitChoiceList
	Loop
		
		!! 選択リストボックス処理共通
		GoSub ProcChoiceList
		
		!! キー入力待ち
		GoSub GetKey
		Begin Case
			Case actNo = A.CANCEL ;** 抜ける
				!! 選択を非表示にして画面を残す
				choiceActive = @False
				GoSub ProcChoiceList
				Exit
			Case actNo = A.NEWLINE ;** 決定
				GoSub CUR.TOP.OF.SCREEN
				Crt @(winX,0):
				topos = choiceSelection<1,2>-1
				GoTo ACTION.CMDSTACK.GOTO.impl
		End Case
		
	Repeat
	Crt @(winX,0):
	GoTo Shell.KeyLoop.Start
	
Return

DispCandidate.Common:

	GoSub Prev.Match.Filter	

	!! 0件なら次のモードを試してみる
	If slist = "" Then
		If candidateMode = "FIELD" Then
			candidateMode = "RECID"
			GoTo TAB.HOKAN
		End Else If candidateMode = "RECID" Then
			candidateMode = "FILE"
			GoTo TAB.HOKAN
		End Else If candidateMode = "FILE" Then
			candidateMode = "VOC"
			GoTo TAB.HOKAN
		End Else
			candidateMode = "FIELD"
			GoTo TAB.HOKAN
		End
	End
	
	!! 描画
	GoSub CUR.TOP.OF.SCREEN
	
	crtBuff = ""
	crtBuff := SGR.ALL.OFF2
	GoSub Create.CmdDraw
	GoSub Clear.Cmdline.Crt
	GoSub Draw.Cmdline
	GoSub CRT.BUFF.FLUSH

	!! 候補リスト表示処理
	choiceNo = 1
	col1 = Maximum(LenSDP(slist))
	slist.cnt = DCount(slist,@FM)
	choiceList = ""
	For i=1 To slist.cnt
		choiceList<-1> = FMTDP(slist<i>,col1+2:"T"):dlist<i>:@VM:slist<i>
	Next i
	title = dispType
	choiceOrgY = dispRows
	GoSub InitChoiceList
	Loop
		
		!! 選択リストボックス処理共通
		GoSub ProcChoiceList
		
		!! キー入力待ち
		GoSub GetKey
		Begin Case
			Case actNo = A.CANCEL ;** 抜ける
				!! 選択を非表示にして画面を残す
				choiceActive = @False
				GoSub ProcChoiceList
				Crt @(winX,0):
				GoTo Shell.KeyLoop.Start
			Case actNo = A.NEWLINE ;** 決定
				slist = choiceSelection<1,2>
				GoSub AUTO.COMPLATE
				If C # CTRL.M Then ;** Ctrl+Enterで連続選択
					C = ""
					fullWord.st = X
					fullWord.Len = 0
					crtBuff = ""
					Crt @(winX,0):
					crtBuff := SGR.ALL.OFF2
					GoSub Create.CmdDraw
					GoSub Clear.Cmdline.Crt
					GoSub Draw.Cmdline
					GoSub CRT.BUFF.FLUSH
				END ELSE
					If bComprate And commonWord[1]#" " Then
						Crt @(winX,0):
						GoTo TAB.HOKAN ;** 続きあり
					End
					C = ""
					choiceActive = @False
					GoSub ProcChoiceList
					Exit
				END
			Case actNo = A.TAB ;** モード切替
				If dispType # "OS Path" Then
					If candidateMode = "FLATREC" Then
						candidateMode = "FIELD"
					End Else If candidateMode = "FIELD" Then
						candidateMode = "RECID"
					End Else If candidateMode = "RECID" Then
						candidateMode = "FILE"
					End Else If candidateMode = "FILE" Then
						candidateMode = "VOC"
					End Else If candidateMode = "VOC" Then
						candidateMode = "FLATREC"
					End
					Crt @(winX,0):
					GoTo TAB.HOKAN
				End
			Case actNo = A.SHIFT_TAB
				If dispType # "OS Path" Then
					If candidateMode = "FIELD" Then
						candidateMode = "FLATREC"
					End Else If candidateMode = "RECID" Then
						candidateMode = "FIELD"
					End Else If candidateMode = "FILE" Then
						candidateMode = "RECID"
					End Else If candidateMode = "VOC" Then
						candidateMode = "FILE"
					End Else If candidateMode = "FLATREC" Then
						candidateMode = "VOC"
					End
					Crt @(winX,0):
					GoTo TAB.HOKAN
				End
		End Case
		
	Repeat
	Crt @(winX,0):
	
Return

Setting.WordInfo:
	fullLine = Convert(',',' ',cmdline)
	words = ""
	If actNo = A.INSCHAR And C = Char(32) Then
		nowLine = fullLine[1,curPos-2]
	End Else
		nowLine = fullLine[1,curPos-1]		
	End
	a = nowLine
	b = fullLine
	Loop
		epos = If a[1,1]='"' Then Index(a,'"',2) Else Index(a,' ')-1
		If epos<=0 or a[epos+1,1]="" Then
			nowWord = a[1,9999]
			epos = If b[1,1]='"' Then Index(b,'"',2) Else Index(b,' ')-1
			words<-1> = If epos<=0 Then b[1,9999] Else b[1,epos]
			Exit ;** 最後
		End
		words<-1> = a[1,epos]
		a = TRIMF(a[epos+2,9999])
		b = TRIMF(b[epos+2,9999])
	Repeat
	
	nowWordPos = DCount(words,@FM)
	fullWord = IF nowWord="" Then "" Else words<nowWordPos>
	fullWord.st = X - Len(nowWord)
	fullWord.Len = Len(fullWord)
!	logmsg "curPos:":curPos:",nowWord:":dquote(nowWord):",fullWord:":dquote(fullWord):",fullWord.st:":fullWord.st:",fullWord.Len:":fullWord.Len

	If actNo = A.INSCHAR And C = Char(32) Then
		nowWord := " "
	End
Setting.WordInfo2:
	nowWordU = UpCase(nowWord)             ;** カーソル上の単語大文字（カーソル位置まで）
	nowWord.len = Len(nowWord)             ;** カーソル上の単語長（カーソル位置まで）
Return

ExecCmd:
$IFDEF U2__UNIVERSE
	Execute cmd, OUT>NULL
$ELSE
	Execute cmd SILENT STACKLIST
$ENDIF
Return

Prev.Match.Filter:
	If Len(nowWordU) = 0 Then Return
	slistU.old = slistU
	slist.old = slist
	dlist.old = dlist
	slistU = ""
	slist = ""
	dlist = ""
	Loop
		idU = Remove(slistU.old,sep)
		id = Remove(slist.old,s)
		desc = Remove(dlist.old,s)
		If idU[1,nowWord.len] = nowWordU Then
			!! NO.CASEで前方一致
			slistU<-1> = idU
			slist<-1> = id
			dlist<-1> = desc
		End
	While sep
	Repeat
Return

Match.CancidateFilter:
	filterU = UpCase(candidateFilter)
	slistU.old = slistU
	slist.old = slist
	dlist.old = dlist
	slistU = ""
	slist = ""
	dlist = ""
	Loop
		id = Remove(slist.old,sep)
		idU = Remove(slistU.old,s)
		desc = Remove(dlist.old,s)
		If Index(Trim(idU):@FM:UpCase(desc),filterU,1) Or Trim(id) Matches candidateFilter Or desc Matches candidateFilter Then
			slist<-1> = id
			slistU<-1> = idU
			dlist<-1> = desc
		End
	While sep
	Repeat
Return

Get.SList.From.Voc.Common:
	SelectV FP.TMP To sp
	Loop
		ReadNext @ID From sp Else Exit
		Read @RECORD From FP.TMP,@ID Then
			type = iType(typeIType)
			m1 = type<1,1> Matches tgt
			m2 = type<1,2> Matches tgt
			If m1 Or m2 Then
				id = @ID:" "
				idU = UpCase(id)
				Locate idU In slistU By "AL" Setting no Else
					Ins id Before slist<no>
					Ins idU Before slistU<no>
					desc = iType(descIType)
					If m2 Then
						desc = If m1 Then desc<1,1>:" ":desc<1,2> Else desc<1,2>
					End
					Ins desc Before dlist<no>
				End
			End
		End
	Repeat
Return

Get.SList.From.Voc:
	slist = ""
	slistU = ""
	dlist = ""
	tgt = Convert(',',@VM,tgtVocTypes)
	FP.TMP = VOC
	GoSub Get.SList.From.Voc.Common
	OPEN "PVOC,":@USER TO PVOC THEN
		FP.TMP = PVOC
		GoSub Get.SList.From.Voc.Common
	END
Return

Get.SList.From.Voc2:
	slist = ""
	slistU = ""
	dlist = ""
	tgt = Convert(',',@VM,tgtVocTypes)
	FP.TMP = fpTgtAccVOC
	GoSub Get.SList.From.Voc.Common
Return

Get.SList.VOC:
	tgtVocTypes = "V,R,S,K,PA,PQ,PH,M,D"
	GoSub Get.SList.From.Voc
Return

Get.SList.FILE:

	If slistCacheType = "F ":tgtAccVOC Then
		slist = slistCache
		slistU = slistUCache
		dlist = dlistCache
	End Else
		tgtVocTypes = "F,Q"
		GoSub Get.SList.From.Voc2
		slistCache = slist
		slistUCache = slistU
		dlistCache = dlist
		slistCacheType = "F ":tgtAccVOC
	End
	
$IFNDEF U2__UNIVERSE
	If tgtAccVOC = "VOC" Then
		** ACCOUNTファイル
		Open ACCOUNT.FILE TO fpACCOUNT Then
			SelectV fpACCOUNT To sp
			Loop
				ReadNext @ID From sp Else Exit
				Read @RECORD From fpACCOUNT,@ID Then
					@ID := ":"
					idU = UpCase(@ID)
					Locate idU In slistU By "AL" Setting no Else
						Ins idU Before slistU<no>
						Ins @ID Before slist<no>
						Ins @RECORD<1>:" ":@RECORD<2> Before dlist<no>
					End
				End
			Repeat
			Close fpACCOUNT
		End
		** $SERVERSファイル
		cnt = DCount(serverListIds,@FM)
		For i = 1 To cnt
			@ID = serverListIds<i>:":"
			idU = UpCase(@ID)
			desc = serverList<i>
			Locate idU In slistU By "AL" Setting no Else
				Ins idU Before slistU<no>
				Ins @ID Before slist<no>
				Ins desc Before dlist<no>
			End
		Next i
	End
$ENDIF

Return

Get.SList.FIELD:
	slist = ""
	slistU = ""
	dlist = ""
	If dictName Then
		SelectV fpDICT To sp
		Loop
			ReadNext @ID From sp Else Exit
			Read @RECORD From fpDICT,@ID Then
				If Count("DILPCEASC",@RECORD[1,1]) Then
					If @RECORD[1,1] = "L" Then
						@ID := "%"
						!! ---> Ref Table
						desc = "---> ":@RECORD<3>
					End Else
						@ID := " "
						If Count("DIEC",@RECORD[1,1]) Then
							!! Type S/M Assoc Description
							desc = FMT(@RECORD[1,1],"4L"):FMT(@RECORD<6>,"3L"):@RECORD<7>:"  ":@RECORD<4>
						End Else If @RECORD[1,2] = "PH" Then
							desc = FMT("PH","4L"):@RECORD<2>
						End
					End
					idU = UpCase(@ID)
					Locate idU In slistU By "AL" Setting no Else
						Ins idU Before slistU<no>
						Ins @ID Before slist<no>
						Ins Convert(Char(10):@FM:@VM:@SVM,"    ",desc) Before dlist<no>
					End
				End
			End
		Repeat
	End
Return

Get.SList.FLATFILE:

	** 単語を遡ってフラットファイルか調べる
	flatFile = ""
	For wordPos = nowWordPos - 1 To 1 Step -1
		Open words<wordPos> To fpFlat Then
			fileType = FileInfo(fpFlat,3)
			If fileType = 4 Then
				flatFile = words<wordPos>
				Exit
			End
		End
	Next
	
	If flatFile = "" Then
		If UpCase(words<1>) Matches Convert(" ",@VM,"RUN BASIC CATALOG DELETE.CATALOG CATALOGUE DELETE.CATALOGUE") Then
			!! VerbがBasic系でフラットファイル指定がない場合は BP.OUT を候補に入れる
			Open "BP.OUT" To fpFlat Then
				fileType = FileInfo(fpFlat,3)
				If fileType = 4 Then
					flatFile = "BP.OUT"
				End
			End
		End Else If UpCase(words<1>) Matches Convert(" ",@VM,"GET.LIST SAVE.LIST COPY.LIST SORT.LIST EDIT.LIST") Then
			!! VerbがSaved.List系でフラットファイル指定がない場合は $SAVEDLIST に入れる
			Open SAVEDLISTS.FILE To fpFlat Then
				fileType = FileInfo(fpFlat,3)
				If fileType = 4 Then
					flatFile = SAVEDLISTS.FILE
				End
			End
		End
	End
	
	slist = ""
	slistU = ""
	dlist = ""
	If flatFile Then
!! 		showDesc = Not(flatFile[4] = ".OUT")
		SelectV fpFlat To sp
		Loop
			ReadNext @ID From sp Else Exit
			idU = UpCase(@ID)
			Locate idU In slistU By "AL" Setting no Else
				Ins idU Before slistU<no>
				Ins @ID:" " Before slist<no>
!! 重くなる時があるのでやめる
!! 				If showDesc Then
!! 					ReadV f1 From fpFlat,@ID,1 Then
!! 						Ins f1 Before dlist<no>
!! 					End Else
!! 						Ins "-" Before dlist<no>
!! 					End
!! 				End
			End
		Repeat
	End
	Close fpFlat
Return

Get.SList.RECID:
	
	** 1000件未満のファイルを補完対象とする
	flatFile = ""
	For wordPos = nowWordPos - 1 To 1 Step -1
		IF words<wordPos-1> = "DICT" THEN
			B = "DICT ":words<wordPos>
		END ELSE
			B = words<wordPos>
		END
		Open B To fpFlat Then
			a = FileInfo(fpFlat,1015)
			If a > 0 And a < 2000 Then
				flatFile = B
				Exit
			End
		End
	Next
	
	slist = ""
	slistU = ""
	dlist = ""
	If flatFile Then
		SelectV fpFlat To sp
		Loop
			ReadNext @ID From sp Else Exit
			idU = UpCase(@ID)
			Locate idU In slistU By "AL" Setting no Else
				Ins idU Before slistU<no>
				Ins @ID:" " Before slist<no>
			End
		Repeat
	End
	Close fpFlat
Return

*--------------------------------
* シェルの終了
*--------------------------------
QUIT.SHELL:

	** Brackets Paste Mode off
	Crt CSI:"?2004l":

	** 反転入力モードに戻す
$IFDEF U2__UNIVERSE
	Ttyget ttys Then
		If ttys<1,1> = 3 Then; * EMULATE mode
			ttys<4,4> = @TRUE; * Invert
			Ttyset ttys Else Null
		End
	End
$ELSE
	x = PTERM(3,3)
	x = PTERM(2,@TRUE)
$ENDIF

	If Not(IS.CONSOLE) Then
		If Not(bFirstCurTop) Then
			** 代替画面バッファ開いてる場合は閉じる
			Crt ESC:"[?1049l"
		End
		
		** テーマをリセット
		Crt ESC:"]R":ESC:"[?69l"
	End

$IFNDEF U2__UNIVERSE
	IF @TERM.TYPE = 'msvt' THEN
		EXECUTE "TERM qmterm"
	END
$ENDIF
	
	** Shellを抜ける
	Stop

CMDLINE2REC:
	GoSub GET.PROMPTLEN
	no = cmdStackPos
	GoSub CMDLINE2TEMP
	Rec = Temp
	Lines = cnt
	GoSub InitBuf
	Return

CMDLINE2TEMP:
	a = Convert(CHAR(10),@FM,cmdline)
	If no=1 Then
		Temp = Fmt("si:",prmptLen:"R"):a<1>
	End Else
		Temp = Fmt(no-1,prmptLen:"R%":Maximum(Len(no-1):@FM:2):":"):a<1>
	End
	cnt = DCount(a,@FM)
	For i=2 To cnt
		Temp := @FM:Str(" ",prmptLen-1):":":a<i>
	Next i
	Return

Upd.CmdStackPage:
	no = cmdStackPos
	If Trim(cmdline)[1,1] <> "." Then
		cnt = DCount(Rec,@FM)
		For i=1 To cnt
			Line = Rec<i>
			If cmdStackPos=1 Then
				cmdStackPage<1> = Convert(@FM,CHAR(10),cmdline<i>)
			End Else
				a = MatchField(Line,"...0N:...",2)
				If a#"" Then
					no = Int(a)+1
					cmdStackPage<no> = cmdline<i>
				End Else
					cmdStackPage<no> := CHAR(10):cmdline<i>
				End
			End
		Next i
	End
	Return

Get.Cmdline.From.StackPage:
	If DCount(cmdStackPage,@FM) < no Then
		If cmdStackPage<no> = "" Then
			cmdStackPage<no> = cmdStack<no>
		End
	End
	cmdline = cmdStackPage<no>
	Return

*--------------------------------
* コマンドスタック進む Action
*--------------------------------
ACTION.CMDSTACK.NEXT:
	
	If DCount(cmdStack,@FM) > cmdStackPos Then
		cmdStackPos += 1
		no = cmdStackPos
		GoSub Get.Cmdline.From.StackPage
	End
	
	Return

*--------------------------------
* コマンドスタック戻る Action
*--------------------------------
ACTION.CMDSTACK.BACK:
	
	If 1<cmdStackPos Then
		cmdStackPos = no-1
		no = cmdStackPos
		GoSub Get.Cmdline.From.StackPage
	End
	
	Return

*--------------------------------
* コマンドスタック一覧表示 Action
*--------------------------------
ACTION.CMDSTACK.LIST:
	
	!! 範囲パラメータの習得
	f1 = MatchField(UpCase(cmdline),"'.L'0N...",2)
	f2 = MatchField(UpCase(cmdline),"'.L'0N,0N...",4)
	If f2 Then
		If f1 Then cmdStackList.DispCnt<1> = f1 + 1
		cmdStackList.DispCnt<2> = f2 - 1
	End Else If f1 Then
		cmdStackList.DispCnt<1> = If cmdStackPos = 1 Then 2 Else cmdStackPos
		cmdStackList.DispCnt<2> = f1 - 1
	End Else If Trim(cmdline) = ".L" Then
		!! 前回のパラメータを利用
		If cmdStackPos > 1 Then
			cmdStackList.DispCnt<1> = cmdStackPos
		End
	End Else
		!! List VOC
		id = Trim(cmdline[' ',2,999])
		Read rec From VOC,id Then
			cmdline = "CT VOC ":id
			bAutoCommand = @TRUE
			GoTo Shell.KeyLoop.Start
		End Else
			OPEN "PVOC,":@USER TO PVOC Then
				Read rec From PVOC,id Then
					cmdline = "CT PVOC,":@USER:" ":id
					bAutoCommand = @TRUE
					GoTo Shell.KeyLoop.Start
				End
			End
		End
	End
	
	!! 最大値チェック
	cmdStackList.DispCnt<2> = Minimum(cmdStackList.DispCnt<2>:@FM:(@CRTHIGH-2))
	
	filterWord = cmdline[' ',2,999]
	Dim filterWordU(9)
	MatParse filterWordU From Trim(UpCase(filterWord))," " Setting filterCnt
	
	result = ""
	cnt = 0
	cmdStack.len = DCount(cmdStack,@FM)
	For i = cmdStackList.DispCnt<1> To cmdStack.len
		If cmdStackPage<i> <> "" Then
			cmd = cmdStackPage<i>
			modify = If cmd <> cmdStack<i> Then "*" Else " "
		End Else 
			cmd = cmdStack<i>
			modify = " "
		End
		If cmd = "" Then Exit
		If filterWord >< "" Then
			flg = @True
			For j = 1 To filterCnt
				If Index(cmd,filterWordU(j))=0 Then
					flg = @False
					Exit ;** １つでも一致しなければ抜ける
				End
			Next j
			If Not(flg) Then Continue
		End
		result<-1> = (i-1):@VM:cmd:@VM:modify
		cnt += 1
		If cmdStackList.DispCnt<2> < cnt Then Exit
	Next
	w = Maximum(Len(i):@FM:2)
	
	!! 画面出力
	Print ""
	For i = cnt To 1 Step -1
		a = Convert(CHAR(10),@FM,result<i,2>)
		Print result<i,3>:FMT(result<i,1>,w:"R"):" ":a<1>
		cnt2 = DCount(a,@FM)
		For i2=2 To cnt2
			Print " ":Str(" ",w):" ":a<i2>
		Next i2
	Next i

	!! コマンドを保存
	prevListStackCmd = cmdline
	
	!! 現在行の調整
	GoSub GET.CMDLINES
	GoSub Upd.CmdStackPage
	GoSub ACTION.CMDSTACK.NEXT
	GoSub ACTION.CMDSTACK.BACK
	
	GoTo Shell.Input.Begin ;* キーループに戻る

*--------------------------------
* コマンドスタックジャンプ Action
*--------------------------------
ACTION.CMDSTACK.GOTO:
	topos = MatchField(UpCase(cmdline),"'.G'0N...",2)
ACTION.CMDSTACK.GOTO.impl:
	If topos <> "" And DCount(cmdStack,@FM) > topos + 1 Then
		GoSub GET.CMDLINES
		GoSub Upd.CmdStackPage
		cmdStackPos = 1
		Loop
			GoSub ACTION.CMDSTACK.NEXT
			If cmdStackPos = topos + 1 Then Exit
		Repeat
	End
	cmdline = cmdStackPage<cmdStackPos>
	GoSub CMDLINE2REC
	GoTo Set.Command.Editor

*--------------------------------
* コマンドスタックインクリ検索 Action
*--------------------------------
ACTION.CMDSTACK.INC.SEARCH:
	
	cmdline = cmdStackPage<cmdStackPos>
	GoSub CMDLINE2REC
	GoSub GET.CMDLINES
	GoSub Upd.CmdStackPage
	
	If iSearchText Then
		If bIncSearch = "R" Then
			!! 履歴遡り
			Loop
				If UpCase(cmdline) Matches "...":UpCase(iSearchText):"..." Then Exit
				If DCount(cmdStack,@FM) <= cmdStackPos Then
					!! 見つからなかった
					cmdStackPos = stackPos
					cmdline = cmdStackPage<cmdStackPos>
					Exit
				End
				GoSub ACTION.CMDSTACK.NEXT
			Repeat
		End Else
			!! 履歴遡り
			Loop
				If UpCase(cmdline) Matches "...":UpCase(iSearchText):"..." Then Exit
				If 1 >= cmdStackPos Then
					!! 見つからなかった
					cmdStackPos = stackPos
					cmdline = cmdStackPage<cmdStackPos>
					Exit
				End
				Y = 2
				GoSub ACTION.CMDSTACK.BACK
			Repeat
		End
		GoSub CMDLINE2REC
	End Else
		GoSub GET.CMDLINES
		cmdline = cmdline<Y>
		cmdStackPos = cmdStackPos+Y-1
		GoSub CMDLINE2REC
		Y = 1
	End
	
	Return

*--------------------------------
* コマンドスタック行のAPPEND Action
*--------------------------------
ACTION.CMDSTACK.APPEND:

	no = MatchField(UpCase(cmdline),"'.A'0N...",2)
	If no="" Then no=1
	
	If cmdStackPage<no+1> = "" Then cmdStackPage<no+1> = cmdStack<no+1>
	cmdStackPage<no+1> := cmdline[4+Len(no),9999]

	!! 一覧表示
	cmdline = ".L":no:",1"
	GoTo ACTION.CMDSTACK.LIST

*--------------------------------
* コマンドスタック行のSAVE Action
*--------------------------------
ACTION.CMDSTACK.SAVE:
	
	If UpCase(cmdline)[1,3]=".SP" Then
		!! PVOC
		cmd = Trim(cmdline[4,9999])
		OPEN "PVOC,":@USER TO PVOC Else
			PRINT ""
			PRINT "Cannot Open PVOC"
			GoTo Shell.KeyLoop.End
		End
		TG.VOC = PVOC
		VOCNAME = "PVOC"
	End Else
		cmd = Trim(cmdline[3,9999])
		TG.VOC = VOC
		VOCNAME = "VOC"
	End
	
	startNo = MatchField(UpCase(cmd),"0N...",1)
	endNo   = MatchField(UpCase(cmd),"0N'-'0N...",3)
	paName  = Trim(cmdline[' ',2,1])
	
	If startNo:endNo = "" Then
		startNo = cmdStackList.DispCnt<1>
		endNo = cmdStackList.DispCnt<2> + startNo
	End Else If startNo#"" And endNo = "" Then
		startNo +=1
		endNo = startNo
	End Else
		startNo += 1
		endNo += 1	
	End
	
	If startNo < endNo Then
		a = startNo
		startNo = endNo
		endNo = a
	End
	
	Print ""
	ReadU pa From TG.VOC,paName Then
		Print 'Item "':paName:'" already exists in ':VOCNAME:'.'
		Print " Overwirte (Y)":
		Input ans
		If UpCase(Trim(ans)) = "Y" Else GoTo Shell.KeyLoop.End
		pa = pa<1> ;** 1行目を残す
	End Else
		pa = "PA Created at ":OConv(Date(),"D-YMD"):" ":OConv(Time(),"MTS"):" by ":@LOGNAME:"@":@ACCOUNT
	End
	For i = startNo To endNo Step -1
		pa<-1> = If cmdStackPage<i> = "" Then cmdStack<i> Else cmdStackPage<i>
	Next
	
	If paName <> "" Then
		Write pa To TG.VOC,paName On Error Print "Cannot Write to ":VOCNAME:"."
		Print 'Item "':paName:'" Saved in ':VOCNAME:'.'
	End Else
		GoSub DoNew
		Rec = pa
		GoSub StartBuf
		GoTo Launch.Editor
	End
	
GoTo Shell.Input.Begin ;* キーループに戻る


*--------------------------------
* コマンドスタック行の読込 Action
*--------------------------------
ACTION.CMDSTACK.READ:

	cmdline = Trim(cmdline)
	
	cmdlines = ""
	cmdlines_page = ""
	If cmdline = ".R" Then
		!! Duplicate Case
		cmdlines = cmdStack<2>
		cmdlines_page = cmdlines
	End Else If cmdline[1,3] = ".R " Or cmdline[1,4] = ".RP " Then
		!! VOCからリード Case
		name = Trim(cmdline[' ',2,1])
		Read rec From VOC,name Then
			If rec[1,1] = 'P' Or rec[1,1] = 'S' Then
				GoSub Conv.rec2cmdlines
				cmdlines_page = cmdlines
			End
		End
	End Else
		n = MatchField(UpCase(cmdline),"'.R'0N...",2)
		m = MatchField(UpCase(cmdline),"'.R'0N'-'0N...",4)
		If n Then
			!! Stackからリード Case
			If m = "" Then m = n ;** 1行にする
			If Num(n) And Num(m) Then
				min_no = Minimum(n:@FM:m)
				max_no = Maximum(n:@FM:m)
				For i = max_no To min_no Step -1
					cmd = cmdStack<i+1>
					If cmdStackPage<i+1> <> "" Then
						cmdlines_page<-1> = cmdStackPage<i+1>
						Del cmdStackPage<i+1> ;** 移動の為削除
					End Else
						cmdlines_page<-1> = cmd
					End
					cmdlines<-1> = cmd
					Del cmdStack<i+1>
				Next i
			End
		End Else
			Return
		End
	End
	
	!! スタックの先頭に挿入
	cmdcnt = DCount(cmdlines,@FM)
	For i = 1 To cmdcnt
		Ins cmdlines<i> Before cmdStack<2>
		Ins cmdlines_page<i> Before cmdStackPage<2>
	Next i
	
	!! 一覧表示
	IF cmdcnt > 0 Then
		cmdline = ".L1,":cmdcnt
		GoTo ACTION.CMDSTACK.LIST
	End
	
GoTo Shell.Input.Begin ;* キーループに戻る

*--------------------------------
* コマンドスタック行の削除 Action
*--------------------------------
ACTION.CMDSTACK.DELETE:

	cmdline = Trim(cmdline)
	
	If UpCase(cmdline)[1,3] = ".D " Then
		!! VOCから削除
		name = Trim(cmdline[4,BIG])
		Read rec From VOC,name Then
			If rec[1,2] = "PA" Or rec[1,1] = "S" Then
				Delete VOC,name
				PRINT ""
				Print 'Item "':name:'" Deleted From VOC.'
			End
		End
	End Else If UpCase(cmdline)[1,4] = ".DP " Then
		!! PVOCから削除
		name = Trim(cmdline[5,BIG])
		OPEN "PVOC,":@USER TO PVOC Else
			PRINT ""
			PRINT "Cannot Open PVOC"
			GoTo Shell.KeyLoop.End
		End
		Read rec From PVOC,name Then
			If rec[1,2] = "PA" Or rec[1,1] = "S" Then
				Delete PVOC,name
				PRINT ""
				Print 'Item "':name:'" Deleted From PVOC.'
			End
		End
	End Else If n Then
		!! 番号指定で削除
		n = MatchField(UpCase(cmdline),"'.D'0N...",2)
		m = MatchField(UpCase(cmdline),"'.D'0N'-'0N...",4)
		
		If n = "" Then n = 1 ;** デフォルトはトップ位置
		If m = "" Then m = n ;** 1行にする
		If Num(n) And Num(m) Then
			min_no = Minimum(n:@FM:m)
			max_no = Maximum(n:@FM:m)
			For i = max_no To min_no Step -1
				Del cmdStack<i+1>
				Del cmdStackPage<i+1>
			Next i
		End
	End

GoTo Shell.Input.Begin ;* キーループに戻る


*--------------------------------
* コマンドスタック行の置換 Action
*--------------------------------
ACTION.CMDSTACK.CHANGE:

	no = MatchField(cmdline[3,9999],"0N...",1)
	cmd = Trim(cmdline[3+Len(no),9999])
	delim = cmd[1,1]
	If Index("/!@#$%&*\:=+-?(){}[]^'|,",delim,1)>0 Else Print " <-- valid delimiter"; GoTo Shell.Input.Begin; * 先頭に戻る

	old=cmd[delim,2,1]
	new=cmd[delim,3,1]
	opt=cmd[delim,4,1]

	If no="" Then no=1
	
	If cmdStackPage<no+1> = "" Then cmdStackPage<no+1> = cmdStack<no+1>
	If opt="G" Then
		cmdStackPage<no+1> = Change(cmdStackPage<no+1>,old,new)
	End Else
		cmdStackPage<no+1> = Change(cmdStackPage<no+1>,old,new,1,1)
	End

	!! 一覧表示
	cmdline = ".L":no:",1"
	GoTo ACTION.CMDSTACK.LIST

* コマンドスタックにつむ
CmdStack.Push:
	cmd = Convert(@FM,CHAR(10),cmdline)
	Find cmd In cmdStack Setting pos Then
		** 存在するので上位に持ってくる為に削除
		Del cmdStack<pos>
	End
	cmdStack<1> = cmd
	Ins "<NEWLINE>" Before cmdStack<1>
	cmdStack = cmdStack[@FM,1,CMD.STACK.SIZE]
	cmdStackPage = cmdStackPage[@FM,1,CMD.STACK.SIZE]
	Return

*--------------------------------
* 直前のファイル名を挿入
*--------------------------------
ACTION.INPUT.PREV.FILENAME:
	If prevFileName><"" Then
		InsBuffer = prevFileName
		head = cmdline[1,curPos]
		tail = cmdline[curPos+1,9999]
		If head[1] >< " " Then InsBuffer = " ":InsBuffer ;** headの末端が空白でないなら空白を挿入
		If tail[1,1] >< " " Then InsBuffer = InsBuffer:" " ;** tailの先頭が空白でないなら空白を挿入
		GoSub InsertLines
	End
Return

*--------------------------------
* 直前の編集アイテム名を挿入
*--------------------------------
ACTION.INPUT.PREV.EDITITEM:
	If FileName><"" Then
		InsBuffer = FileName:" ":ItemName
		head = cmdline[1,curPos]
		tail = cmdline[curPos+1,9999]
		If head[1] >< " " Then InsBuffer = " ":InsBuffer ;** headの末端が空白でないなら空白を挿入
		If tail[1,1] >< " " Then InsBuffer = InsBuffer:" " ;** tailの先頭が空白でないなら空白を挿入
		GoSub InsertLines
	End
Return

*--------------------------------
* 直前の編集アイテムのパスを挿入
*--------------------------------
ACTION.INPUT.PREV.EDITPATH:
	If PathName><"" Then
		InsBuffer = If Index(PathName," ") Then DQUOTE(PathName) Else PathName
		head = cmdline[1,curPos]
		tail = cmdline[curPos+1,9999]
		If head[1] >< " " Then InsBuffer = " ":InsBuffer ;** headの末端が空白でないなら空白を挿入
		If tail[1,1] >< " " Then InsBuffer = InsBuffer:" " ;** tailの先頭が空白でないなら空白を挿入
		GoSub InsertLines
	End
Return

*--------------------------------
* 補完処理 共通
*--------------------------------
AUTO.COMPLATE:
	
	bComprate = @FALSE
	commonWord = ""
	separator = ""
	
	* 候補なし
	If slist = "" Then Return
	
	If DCount(slist,@FM) = 1 Then
		Read rec From VOC,slist Then
			** マルチパートファイルは','で続ける
			If rec<1>[1,1]="F" And rec<4> >< "" Then
				slist = TRIMB(slist)
				separator = ","
			End
		End Else If Trans("DICT ":dictName,slist,1,'X')[1,1] = "L" Then
			** L-Typeなら'%'で続ける
			slist = TRIMB(slist)
			separator = "%"
		End
		commonWord = slist : separator ;* 候補は１つなので確定
		slist = ""
		bComprate = @true
		
	End Else
		If nowWord = slist<1> Then
			commonWord = slist<1>
		End Else
			commonWord = Remove(slist,sep);
			Loop
				verb = Remove(slist,sep);
				If verb><"" Then
					For i = 1 To Len(verb)
						If UpCase(commonWord[i,1]) >< UpCase(verb[i,1]) Then
							commonWord = commonWord[1,i-1];
							Exit;
						End
					Next i
				End
				If sep = 0 Then Exit;
			Repeat
		End
	End

	If nowWord = commonWord Then Return
	
	!! 単語置換
	BufInfo<BI.BLOCKSTART,1> = Y
	BufInfo<BI.BLOCKSTART,2> = fullWord.st
	BufInfo<BI.BLOCKEND,1> = Y
	BufInfo<BI.BLOCKEND,2> = fullWord.st + fullWord.Len
	
	If fullWord[1,1]='"' Then
		!! ""で囲む
		a = Convert('"','',fullWord)
		If commonWord[1]=" " Then
			InsBuffer = DQuote(a[1,Len(a)-Len(nowWord)]:commonWord[1,Len(commonWord)-1]):" "
		End Else
			InsBuffer = DQuote(a[1,Len(a)-Len(nowWord)]:commonWord)
		End
	End Else
		If nowWord#"" And fullWord[1,Len(nowWord)]=nowWord Then
			BufInfo<BI.BLOCKEND, 2> = fullWord.st + Len(nowWord)
			InsBuffer = commonWord
		End Else
			InsBuffer = fullWord[1,fullWord.Len-Len(nowWord)]:commonWord
		End
		If Index(Convert("()"," ",Trim(InsBuffer))," ") Then
			!! ""で囲む
			If InsBuffer[1]=" " Then
				InsBuffer = DQuote(InsBuffer[1,Len(InsBuffer)-1]):" "
			End Else
				InsBuffer = DQuote(InsBuffer)
			End
		End
		!! スペースが２つ続くのを防ぐ
		IF InsBuffer[1]=" " AND Rec<Y>[X,1]=" " THEN InsBuffer = InsBuffer[1,LEN(InsBuffer)-1]
	End
	If InsBuffer=Rec<Y>[fullWord.st,Len(InsBuffer)] Then
		!! ベースとまったく同じ場合はカーソル移動のみ
		X = fullWord.st+Len(InsBuffer)
	End Else
		GoSub InsertLines
	End
	BufInfo<BI.BLOCKSTART> = ""
	BufInfo<BI.BLOCKEND> = ""

	Loop
		GoSub GetCh.Timeout
		While ch <> ""
	Repeat
	
Return

** -----------------------------------
** カーソルを画面の最上部に移動する
** -----------------------------------
CUR.TOP.OF.SCREEN:
	
	** コマンド実行後１回目だけはクリア画面を呼ぶ
	If bFirstCurTop Then
		crtBuff = ""
		GoSub GoAltScreenBuf ;** 代替画面バッファ
		crtBuff := @(0,0):@(-1)
		Crt crtBuff:
		bFirstCurTop = @FALSE
	End Else
		If IS.CONSOLE Then
			Crt @(-1):
		End Else
			Crt ESC.CUR.TOP:@(-1):
		End
	End
	
Return

*-------------------------------------------------------------------------
*  READ.BUFFER INTERNAL COMMAND
*-------------------------------------------------------------------------
READ.BUFFER:

	@USER.RETURN.CODE = -1

	LastCapture = 0
	ItemList = ""
	FileName = ""
	ItemName = ""
	FldInfo = ""
	DiveValuePos = ""
	ParentBufNo = ""
	StatusMessage = ""

	args = Convert(' ',@FM,Trim(cmdline)[' ',2,HUGE])
	CFileName = Remove(args,s)
	Begin Case
		Case CFileName = ""
		Case CFileName Match "'#'1N":@VM:"'#'10"
			!! 選択リスト
			FileName = CFileName
			ItemName = ""
		Case 1
			IN.OSBS = CFileName
			GOSUB GET.OSBS
			OpenSeq OUT.OSBS To TFL Then
				!! パスから開く
				CloseSeq TFL
$IFNDEF U2__UNIVERSE
				FileName = "PATH:":CFileName[@DS,1,DCOUNT(CFileName,@DS)-1]
				IF FileName MATCHES "'PATH:'1A':'" THEN FileName := "\"
				ItemList = LAST(CFileName,@DS)
$ENDIF
			End Else
				CloseSeq TFL

				DICT = ""
				If CFileName="DICT" Then
					DICT = "DICT"
					CFileName = Remove(args,s)
				End
				If CFileName <> "" Then
					Open DICT,CFileName To TempFL Else
						Print "Cannot open ":CFileName
						@USER.RETURN.CODE = 1
						Return
					End
					FileName = CFileName
					If DICT><"" Then FileName = "DICT ":CFileName
				End
				
				!! アクティブな選択リストから取得      
				If System(11) Then
					ReadList tmp Then ItemList = tmp
					Print 'Read from active select list (First item ':DQuote(ItemList<1>):' of ':DCount(ItemList,@FM):')':
					Input ans
					If UpCase(Trim(ans))#"Y" Then
						FormList tmp
						@USER.RETURN.CODE = 1
						Return
					End
				End
				
				dictFileName = If DICT Then "DICT.DICT" Else "DICT ":FileName

				Loop
					arg = Trim(Remove(args,s))
					If arg = "*" Then
						Select TempFL
						ReadList tmp Then ItemList<-1> = tmp
					End Else If arg >< "" Then
						If Not(DICT) Then
							a = Trans(dictFileName,arg,-1,'X')
							If a[1,1]="D" Then
								!! Dフィールドを拾う
								FldInfo<-1> = arg
							End Else If a[1,2]="PH" Then
								!! フレーズからDフィールドを拾う
								FldInfo<-1> = arg
							End Else
								If arg Matches "F1N0N" Then
									!! F1 F2 等は特別
									FldInfo<-1> = arg
								End Else
									ItemList<-1> = arg
								End
							End
						End Else
							ItemList<-1> = arg
						End
					End
				While s Do
				Repeat
				
				Convert @FM To " " In FldInfo
				
				Close TempFL
			End
	End Case

	If FileName = "" And ItemList = "" Then
	End Else If FileName Match "'#'1N":@VM:"'#'10" Then
		buffCnt = DCount(lruBuffList,@FM)
		GoSub DoRead.Without.Jump
	End Else If FileName >< "" And ItemList = "" Then
		!! Item名がない場合はリストから選択
		GoSub DoOpen                    ; * presents a list
		If Not(Found) Then GoSub DoNew
	End Else
		Loop
			Remove ItemName From ItemList Setting s
			buffCnt = DCount(lruBuffList,@FM)
			GoSub DoRead.Without.Jump
			If Found And buffCnt#DCount(lruBuffList,@FM) Then
				Print "Read ":FileName:" ":ItemName:" (":FMT(Len(Rec),"R,"):" chars) > Buffer ":Found
			End
		While s Do
		Repeat
	End

	!! LRUオープンリスト入替
	A = TrimF(cmdline[" ",2,999])
	Find A In SubstringS(LRUOpenList,2,999) Setting f Then
		Del LRUOpenList<f>
		Ins CurBuf:A Before LRUOpenList<1>
	End

	@USER.RETURN.CODE = 0
	Return

*-------------------------------------------------------------------------
*  WRITE.BUFFER INTERNAL COMMAND
*-------------------------------------------------------------------------
WRITE.BUFFER:
	
	@USER.RETURN.CODE=-1

	a = Trim(cmdline)[" ",2,1]
	If Not(Num(a)) Or a > MAXWINDOWS Then
		Print "Arg1. Must Buffer No (1-":MAXWINDOWS:")"
		Return
	End
	CurBuf = a

	If Not(BufInfo<BI.USED>) Then
		Print "Buffer No ":CurBuf:" is not used."
		Return
	End

	If ReadOnly Then
		A = "File is marked as Read Only! - Enter ! to Force Write :"
		If AllDone Then
			Print A:
		End Else
			PromptLine = BG.CYAN:FG.BASE3:A
			GoSub PromptLine
		End
		GoSub GetKey
		Print ""
		If TrimF(C)[1,1] = "!" Else
			@USER.RETURN.CODE=0
			Return
		End
		ReadOnly = @False
	End
	

WRITE.BUFFER.impl:
	
	If BufInfo<BI.PBUFNO> Then
		!! 親バッファ保存モード
		
		!! 親が存在するかチェック
		pno = BufInfo<BI.PBUFNO>
		If Not(BufInfos(pno)<BI.USED>) Then
			A = "Parent BufferNo already closed - Cannot save"  
			If AllDone Then
				Print A
			End Else
				StatusMessage = A
			End
			Return
		End
		
	End Else
		!! 親バッファ保存モードではない
		
		a = Trim(cmdline)[" ",3,1]
		If Upcase(a)="TO" Then
			pos = 4
		End Else
			pos = 3
		End
		
		FileName = Trim(cmdline)[" ",pos,1]
		If FileName Match "'#'1N":@VM:"'#'10" Then
			!! 選択リスト
			FormList Rec To FileName['#',2,1]
			A = Dcount(Rec,@FM):" record(s) selected to select list ":FileName['#',2,1]
			If AllDone Then
				Print A
			End Else
				GoSub BackAltScreenBuf
				Print A
				GoSub GoAltScreenBuf
			End
			saveRec = Rec
			GoTo WRITE.BUFFER.ending
		End
		
		If UPCASE(FileName)="DICT" THEN pos+=1;FileName="DICT ":Trim(cmdline)[" ",pos,1]
		If FileName="" Then FileName = BufInfo<BI.FILE>
		If FileName = "" Then
			GoSub GetFile
			If FileName = "" Then Return
		End
		
		pos += 1
		ItemName = Trim(cmdline)[" ",pos,1]
		If ItemName = "" Then ItemName = BufInfo<BI.ITEM>
		If ItemName = "" Then
			A = "Item Name From '":FileName:"' ->"
			If AllDone Then
				Print A:
			End Else
				PromptLine = BG.CYAN:FG.BASE3:A
				GoSub PromptLine
			End
			Input ItemName
			If AllDone Then Print ""
			If ItemName = "" Then
				@USER.RETURN.CODE=0
				Return
			End
		End
		
		!! アカウント違いの警告
		If BufInfo<BI.ACCOUNT> >< "" Then
			If Not(BufInfo<BI.ACCOUNT> Matches Quote(@ACCOUNT):@VM:Quote(@PATH)) Then 
				A = "This Item Read from Different Account! - Save in This Account (Y) :"
				If AllDone Then
					Print A:
				End Else
					PromptLine = BG.CYAN:FG.BASE3:A
					GoSub PromptLine
				End
				GoSub GetKey
				Print ""
				If TrimF(UpCase(C))[1,1] = "Y" Else
					@USER.RETURN.CODE=0
					Return
				End
			End
		End
	
		!!
		!! 保存処理
		!!   更新ロックがかかっていたらエラー
		!!   編集前時と比較して違っていれば他のセッションで変更があったとみなす(楽観的ロック)
		!!
		GoSub Common.OpenFile
		IF FILEINFO(FL,3)=4 THEN
			IN.OSBS = ItemName
			GOSUB GET.OSBS
		END ELSE
			OUT.OSBS = ItemName
		END
		ReadU prevRec From FL,OUT.OSBS On Error Return Locked
			A = "Record previously Locked by ":Status():", Do Not Saved"
			If AllDone Then
				Print A
			End Else
				StatusMessage = BG.RED:FG.BASE3:A
			End
			GoSub Common.CloseFile
			Return
		End Then
			Convert CHAR(10):CHAR(13) To '' In Rec ;** 改行コードが残っていたら自動除外
		End Else
			prevRec = ""
		End
		GoSub Common.CloseFile
		
	End
	
	If BufInfo<BI.FIELDFIX> Then
		!! フィールド指定モード
		
		saveRec = StartRec ;** 開始時点レコードに対して上書きする

		fldCnt = Dcount(TgtFld,@FM) ;** 固定フィールド数
		
		If BufInfo<BI.VALUEFIX> Then
			!! サブバリュー編集モード
			
			!! 集める
			tmp = ""
			cnt = DCount(Rec,@FM)
			For i = 1 To cnt
				fIdx = Mod((i-1),fldCnt)+1
				svno = Int((i-1)/fldCnt)+1
				If Rec<i> Then
					tmp<fIdx,1,svno> = Rec<i>
				End
			Next

			offset = (BufInfo<BI.VALUEFIX> - 1) * fldCnt + 1

			!! バッファポインタを一時的に切り替える    
			stackCurBuf = CurBuf ;** 現在のBuffNoをスタック
			CurBuf = BufInfo<BI.PBUFNO>
			
			editCmd = ""
			For i = 1 To fldCnt
				fno = offset + (i - 1)
				cmd = ""
				cmd<1> = fno
				cmd<2> = 1
				cmd<3> = fno
				cmd<4> = Len(Rec<fno>) + 1
				cmd<5> = Convert(@IM:@FM:@VM:@SM,CHAR(31):CHAR(10):CHAR(29):CHAR(28),tmp<i>)
				cmd<6> = ""
				editCmd<-1> = cmd
			Next
	
			GoSub StackEditCmd
			
			saveRec = Rec
			
			!! バッファポインタを元に戻す
			CurBuf = stackCurBuf
			
		End Else
			!! バリュー編集モード
			!! 縦一列になっているのを2次元に戻す
			For i = 1 To fldCnt
				fno = TgtFld<i,1>
				saveRec<fno> = ""
			Next
			cnt = DCount(Rec,@FM)
			For i = 1 To cnt
				fno = TgtFld<(Mod((i-1),fldCnt)+1),1>
				vno = Int((i-1)/fldCnt)+1
				If Rec<i> Then
					saveRec<fno,vno> = Rec<i>
				End
			Next
			
			If BufInfo<BI.PBUFNO> Then
				!! 親バッファに保存
		
				flist = TgtFld
				cnt = DCount(flist,@FM)
		
				!! バッファポインタを一時的に切り替える    
				stackCurBuf = CurBuf ;** 現在のBuffNoをスタック
				CurBuf = BufInfo<BI.PBUFNO>
				
				editCmd = ""
				For i = 1 To cnt
					fno = flist<i,1>
					cmd = ""
					cmd<1> = fno
					cmd<2> = 1
					cmd<3> = fno
					cmd<4> = Len(Rec<fno>) + 1
					cmd<5> = Convert(@IM:@FM:@VM:@SM,CHAR(31):CHAR(10):CHAR(29):CHAR(28),saveRec<fno>)
					cmd<6> = ""
					editCmd<-1> = cmd
				Next
		
				GoSub StackEditCmd
				
				saveRec = Rec
				
				!! バッファポインタを元に戻す
				CurBuf = stackCurBuf
				
			End Else
				!! ファイル書き込みモード
				
				!! Conversion
				For i = 1 To fldCnt
					fno = TgtFld<i,1>
					conv = TgtFld<i,3>
					If conv Then saveRec<fno> = IConvS(saveRec<fno>,conv)
				Next
			End
			
		End
		
	End Else
		!! 通常モード
		saveRec = Rec ;** 保存対象レコード
		
		!! Conversion
		fldCnt = DCount(TgtFld,@FM)
		For i = 1 To fldCnt
			fno = TgtFld<i,1>
			conv = TgtFld<i,3>
			If conv Then saveRec<fno> = IConvS(saveRec<fno>,conv)
		Next

	End
	
	If Not(BufInfo<BI.PBUFNO>) Then
		!! ファイルに保存
		If prevRec >< saveRec Then
			!! 現在のレコード内容と違いがある場合だけ更新する
!!			If prevRec >< StartRec Then
!!				StatusMessage = "Record previously Changed by Another, Cannot Save This Modify"
!!				ReadOnly = True
!!				Return
!!			End
			GoSub Common.OpenFile
			IF FILEINFO(FL,3)=4 THEN
				IN.OSBS = ItemName
				GOSUB GET.OSBS
			END ELSE
				OUT.OSBS = ItemName
			END
$IFDEF U2__UNIVERSE
			If BufInfo<BI.LOCKED> Then
				WriteU saveRec On FL,OUT.OSBS On Error Return
			End Else
				Write saveRec On FL,OUT.OSBS On Error Return
			End
$ELSE
			Try
				If BufInfo<BI.LOCKED> Then
					WriteU saveRec On FL,OUT.OSBS
				End Else
					Write saveRec On FL,OUT.OSBS
				End
			Catch SYS$ANY
				StatusMessage = BG.RED:@ABORT.MESSAGE
				Return
			End
$ENDIF
			If AllDone Then
				Print "Write Buffer ":CurBuf:" > ":FileName:" ":ItemName:" (":FMT(Len(saveRec),"R,"):" chars) at ":OConv(Date(),"D-YMD"):" ":OConv(Time(),"MTS")
			End
			GoSub Common.CloseFile
		End
	End

WRITE.BUFFER.ending:

	!! Bufferの初期化処理  
	BufInfo<BI.FILE> = FileName
	BufInfo<BI.ITEM> = ItemName
	BufInfo<BI.CAPTURE> = ""
	GoSub Set.BI.ACCOUNT
	Changed = False
	IsNew = False
	StartRec = saveRec
	
	!! 編集スタックの調整
	If EditCmdPos > 1 Then
		EditCmdStack = EditCmdStack[@FM,EditCmdPos,HUGE]
		EditCmdPos = 1
	End
	Find "SAVED_POINT" In EditCmdStack Setting f Then Del EditCmdStack<f>
	Ins "SAVED_POINT" Before EditCmdStack<1>
	EditCmdPos = 1
	
	@USER.RETURN.CODE=0	
	
	Return
	
** ================================================================================
** Editor.Main
** ================================================================================
Editor.Main:

	!! バッファがない場合は新規で開く
	If Not(lruBuffList) Then
		GoSub DoNew
	End Else
		!! バッファがある場合は以前開いていたものを開く
		Found = lruBuffList<1> ;** 直近を開く
		GoSub ChangeBuf
		If FileName Match "'#'1N":@VM:"'#'10" Then
			!! 選択リストは必ずリロード
			GoSub ReadItem
		End
	End

	biInfoWide.lineNo = 5 ;** 行番号表示の桁数
	biInfoWide.dict = 0

	SearchString = ""
	Replacing = False
	searchReverse = False
	
	crtBuff = ""
	GoSub GoAltScreenBuf ;** 代替画面バッファ
	
	Redraw = REDRAW.ALL
	
 	** Mouse Tracking on
 	crtBuff := CSI:"?1000h":CSI:"?1006h"
	
	Crt crtBuff:
	
	GoSub DoShowDictInfo
	
	GoSub ShowWindow

	!! Editorメインループ  
	AllDone = False
	Loop
	Until AllDone Do
		GoSub Enters
	Repeat
	
	crtBuff = ""
	
 	** Mouse Tracking off
 	crtBuff := CSI:"?1006l":CSI:"?1000l"
	Crt crtBuff:
	
	GoSub BackAltScreenBuf ;** 代替画面バッファから戻る
	Crt crtBuff:
	CurBuf = CMD_BUF
	
	Return
	
GoAltScreenBuf:
	If IS.CONSOLE Then
		crtBuff := @(-1)
	End Else
		crtBuff := ESC:"[?1049h"
!		crtBuff := ESC:"[?1h"
!		crtBuff := ESC:"[?6h"
!		crtBuff := ESC:"[?69h"
!		crtBuff := ESC:"="
!		crtBuff := ESC:"[1;":@CRTHIGH:"r"
	End
	Return

BackAltScreenBuf:
	If IS.CONSOLE Then
		Crt CSI:"2"
		crtBuff := @(-1)
	End Else
!		crtBuff = ESC:"[?1l"
!		crtBuff := ESC:"[?1l"
!		crtBuff := ESC:">"
!		crtBuff := ESC:"[?12l"
!		crtBuff := ESC:"[?25h"
		crtBuff := ESC:"[?1049l"
	End
	Return

*--------------------------------------------------------------------------
* Action
*--------------------------------------------------------------------------
Action: 
	MenuLine = "Buffer Edit Ins Code Navi Tools Mark eXit or ESC :"
	GoSub MenuLine
	Menu = Upcase(C)
	Begin Case
		Case Menu = "B"
			GoSub FileMenu
		Case Menu = "E"
			GoSub EditMenu
		Case Menu = "I"
			GoSub InsMenu
		Case Menu = "C"
			GoSub CodeMenu
		Case Menu = "N"
			GoSub SearchMenu
		Case Menu = "T"
			GoSub ToolsMenu
		Case Menu = "M"
			GoSub BookMenu
		Case Menu = "X"
			GoSub Act.Exit
		End Case
	Return
*--------------------------------------------------------------------------
* BookMenu
*--------------------------------------------------------------------------
BookMenu: 
	MenuLine = "Set Go :"
	GoSub MenuLine
	C = UpCase(C)
	Begin Case
		Case C = "S"
			BookMark = Y
		Case C = "G"
			Top = BookMark
			Y = BookMark
			X = 1
			XOffSet = 1
			GoSub PrintPage
		End Case
	Return
*--------------------------------------------------------------------------
* CodeMenu
*--------------------------------------------------------------------------
CodeMenu: 
	MenuLine = "Build Run Catalog Format Words Mode Indent Help :"
	GoSub MenuLine
	C = UpCase(C)
	Begin Case
		Case C = "B"
			GoSub Act.Compile
		Case C = "R"
			GoSub Act.Run
		Case C = "C"
			GoSub Catalog
		Case C = "F"
			GoSub Format
		Case C = "W"
			GoSub Act.ShowWordHokan
		Case C = "M"
			GoSub ChangeModeMenu
		Case C = "I"
			GoSub ChangeIndentMenu
		Case C = "H"
			GoSub Act.ShowHelp
		End Case
	Return
*--------------------------------------------------------------------------
* ChangeModeMenu
*--------------------------------------------------------------------------
ChangeModeMenu: 
	MenuLine = "Basic Pragraph Item Raw pDump :"
	GoSub MenuLine
	C = UpCase(C)
	Begin Case
		Case C = "B"
			BufInfo<BI.PARSETYPE> = PARSE.BASIC
			GoSub ShowWindow
		Case C = "P"
			BufInfo<BI.PARSETYPE> = PARSE.PARA
			GoSub ShowWindow
		Case C = "I"
			BufInfo<BI.PARSETYPE> = PARSE.DATA
			GoSub DoShowDictInfo
			GoSub ShowWindow
		Case C = "R"
			BufInfo<BI.PARSETYPE> = PARSE.RAW
			GoSub DoHideDictInfo
			GoSub ShowWindow
		Case C = "D"
			BufInfo<BI.PARSETYPE> = PARSE.PDUMP
			GoSub ShowWindow
		End Case
	Return
*--------------------------------------------------------------------------
* ChangeModeMenu
*--------------------------------------------------------------------------
ChangeIndentMenu: 
	MenuLine = "Tab Spaces :"
	GoSub MenuLine
	C = UpCase(C)
	Begin Case
		Case C = "T"
			IndentType = "Tab"
		Case C = "S"
			IndentType = "Spaces"
	End Case
	PromptLine = "Input Indent Size ->"
	GoSub PromptLine
	inputBox = ""
	GoSub InputBox
	If inputBox Matches "0N" Then
		STDTAB = inputBox
	End
	GoSub ShowWindow
	Return
*--------------------------------------------------------------------------
* CheckSave
*--------------------------------------------------------------------------
CheckSave: 
	PromptLine = "Record has changed - Save changes (Y/N) :"; GoSub PromptLine
	GoSub GetKey
	Ok = TriMF(UpCase(C))[1,1] = "Y"
	If Ok Then GoSub SaveItem
Return
*--------------------------------------------------------------------------
* Catalog
*--------------------------------------------------------------------------
Catalog: 
	FileName = BufInfo<BI.FILE>
	ItemName = BufInfo<BI.ITEM>
	MenuLine = "Local, Global, Remote, Normal catalog :"
	GoSub MenuLine
	Crt @(0,0):@(-3):
	Ok = UpCase(TrimF(C))[1,1]
	Begin Case
		Case Ok = "G"
			cmdline = "CATALOG ":FileName:" *":ItemName:" ":ItemName
		Case Ok = "R"
			Write "R":@FM:FileName:@FM:ItemName On VOC, ItemName
			GoSub ShowWindow
			Return
		Case Ok = "L"
			cmdline = "CATALOG ":FileName:" ":ItemName:" LOCAL"
		Case Ok = "N"
			cmdline = "CATALOG ":FileName:" ":ItemName:" LOCAL"
		Case 1
			GoSub ShowWindow
			Return
		End Case
	cmdline<-1> = "PAUSE"
	bAutoCommand = @TRUE
	bAutoEditor = @TRUE
	GoSub Act.Exit
Return

*--------------------------------------------------------------------------
* OConv
*--------------------------------------------------------------------------
DoOConv:

	GoSub GET.SELECTION.STRING
	If selString = "" Then
		StatusMessage = "Need Selection For OConv Source Data"
		Return
	End

	PromptLine = "Input Conversion Code ->"
	GoSub PromptLine
	inputBox = ""
	GoSub InputBox
	inputVal = inputBox
	
	InsBuffer = OConvS(Convert(CHAR(10),@FM,selString),inputVal)
	GoSub InsertLines

Return
*--------------------------------------------------------------------------
* IConv
*--------------------------------------------------------------------------
DoIConv:

	GoSub GET.SELECTION.STRING
	If selString = "" Then
		StatusMessage = "Need Selection For IConv Source Data"
		Return
	End

	PromptLine = "Input Conversion Code ->"
	GoSub PromptLine
	inputBox = ""
	GoSub InputBox
	inputVal = inputBox
	
	InsBuffer = IConvS(Convert(CHAR(10),@FM,selString),inputVal)
	GoSub InsertLines
	
Return
	
*--------------------------------------------------------------------------
* Get Selection String
* OUT: selString  - 選択範囲の文字列
*      blockStart - 選択範囲の開始位置
*      blockEnd   - 選択範囲の終了位置
*--------------------------------------------------------------------------
GET.SELECTION.STRING:

	selString = ""
	blockStart = ""
	If BufInfo<BI.BLOCKSTART> Then
		blockStart = Raise(BufInfo<BI.BLOCKSTART>)
		blockEnd = Raise(BufInfo<BI.BLOCKEND>)
		If blockStart<1> > blockEnd<1> Then tmp = blockStart; blockStart = blockEnd; blockEnd = tmp
		If blockStart<1> = blockEnd<1> Then
			** １行内での選択
			If blockStart<2> > blockEnd<2> Then
				tmp = blockStart; blockStart = blockEnd; blockEnd = tmp
			End
			len = blockEnd<2> - blockStart<2>
			selString = Rec<blockStart<1>>[blockStart<2>,len]
		End Else
			
			** 開始行
			Row = blockStart<1>
			selString = Rec<Row>[blockStart<2>,HUGE]
			
			** 中行
			For Row = Row+1 To blockEnd<1> - 1
				selString := @FM:Rec<Row>
			Next
			
			** 最終行
			selString := @FM
			If blockEnd<2> > 1 Then selString := Rec<blockEnd<1>>[1,blockEnd<2>-1]
			
			selString = Convert(@FM,CHAR(10),selString)
		
		End
		
	End
	
Return

*--------------------------------------------------------------------------
* StackEditCmd
*--------------------------------------------------------------------------
StackEditCmd:
	
	** editコマンドを実行する
	GoSub DoEditCmd
	
	If EditCmdPos > 1 Then
		EditCmdStack = EditCmdStack[@FM,EditCmdPos,HUGE]
		EditCmdPos = 1
	End
	** RedoとUndoをペアでスタックに登録
	Ins Convert(@FM,@SVM,editCmd):@VM:Convert(@FM,@SVM,undoCmd) Before EditCmdStack<1>
	
!!   StatusMessage = Convert(@FM:@VM:CHAR(10),"|,\",EditCmdStack)
	
	If Changed Else Changed = True; Redraw.StatusLine = @TRUE
		
Return

*--------------------------------------------------------------------------
* DoEditCmd
*--------------------------------------------------------------------------
DoEditCmd:
	
	undoCmd = "" ;** Out : Undo用コマンド
	
	Loop
		stY = Remove(editCmd,sep)
		stX = Remove(editCmd,sep)
		endY = Remove(editCmd,sep)
		endX = Remove(editCmd,sep)
		strings = Convert(CHAR(28):CHAR(29):CHAR(31),@SM:@VM:@IM,Remove(editCmd,sep))
		A = Remove(editCmd,sep)
		curFlg = A[":",1,1]
		aftSelected = A[":",2,1]
		
		prevStrings = "" ;** 置換前の文字列
		prevCurFlg = "1"
		selected = ""
		
		If endY >< "" Then
			**
			** 選択範囲削除
			**
			
			If stY = endY Then
				** １行内での選択
				If stX > endX Then tmp = stX; stX = endX; endX = tmp; prevCurFlg=""
				
				prevStrings = Rec<stY>[stX,endX-stX]
				If stX = Len(Rec<stY>)+1 & stX + 1 = endX Then
					** 改行の削除
					prevStrings = CHAR(10)
					Rec<stY> := Rec<stY+1>
					Del Rec<stY+1>
					Redraw = REDRAW.ALL
				End Else
					Rec<stY> = Rec<stY>[1,stX-1]:Rec<stY>[endX,HUGE]
					If Redraw >< REDRAW.ALL Then Redraw<-1> = stY
				End
				
			End Else
				If stY > endY Then tmp = stY; stY = endY; endY = tmp; tmp = stX; stX = endX; endX = tmp; prevCurFlg=""
				
				** 開始行
				Row = stY
				prevStrings = Rec<Row>[stX,HUGE]
				
				** 中行
				For Row = Row+1 To endY - 1
					prevStrings := CHAR(10):Rec<Row>
				Next
				
				** 最終行
				prevStrings := CHAR(10)
				If endX > 1 Then prevStrings := Rec<endY>[1,endX-1]
				
				** 開始行と最終行つなげる
				Rec<stY> = Rec<stY>[1,stX-1]:Rec<endY>[endX,HUGE]
				
				** 中行削除
				rangeY = endY - stY
				For i = 1 To rangeY
					Del Rec<stY+1>
				Next
				
				Redraw = REDRAW.ALL
			End
		
			** 最終カーソル位置を反映する
			If curFlg Then
				prevCurFlg = Y:",":X
				If Index(curFlg,",") Then
					Y = curFlg[",",1,1]
					X = curFlg[",",2,1]
				End Else
					Y = stY
				End
			End Else
				Y = stY
			End
			If Not(curFlg & stX = endX) Then
				!! 開始X位置と終了X位置が同じ場合はXを移動させない
				X = stX
			End
			
			selected = prevStrings <> ""
			
		End
		
		endY = stY
		endX = stX
		
		cmd = ""
		cmd<1> = stY
		cmd<2> = stX
		
		If strings >< "" Then
			**
			** 文字列挿入
			**
			
			strings = Convert(CHAR(10):CHAR(13),@FM:@FM,Change(strings,CHAR(13):CHAR(10),CHAR(10)))
			If stX > 1 Then
				Rec<stY> = Rec<stY>[1,stX-1]:strings:Rec<stY>[stX,HUGE]
			End Else
				Rec<stY> = strings:Rec<stY>
			End
			stringRows = DCount(strings,@FM)
			If stringRows = 1 Then
				** 単一行
				endX += Len(strings)
				If Redraw >< REDRAW.ALL Then Redraw<-1> = stY
			End Else
				** 複数行
				endY += stringRows - 1
				endline = strings<stringRows>
				endX = Len(endline) + 1
				Redraw = REDRAW.ALL
			End
			
			If Index(curFlg,",") Then
				Y = curFlg[",",1,1]
				X = curFlg[",",2,1]
			End Else If curFlg Else
				** 最終カーソル位置を反映する
				Y = endY
				X = endX
			End
			
			cmd<3> = endY
			cmd<4> = endX
			
		End Else
			
			cmd<3> = ""
			cmd<4> = ""
			
		End
		
		cmd<5> = Convert(@IM:@FM:@VM:@SM,CHAR(31):CHAR(10):CHAR(29):CHAR(28),prevStrings)
		cmd<6> = prevCurFlg:":":selected
		Ins cmd Before undoCmd<1> ;** 逆順に追加していく
		
		!! 選択状態を元に戻す
		If aftSelected Then
			BufInfo<BI.BLOCKSTART> = undoCmd<1>:@VM:undoCmd<2>
			BufInfo<BI.BLOCKEND> = undoCmd<3>:@VM:undoCmd<4>
			keepSelection = @TRUE
		End
		
	While sep Repeat
	
Return

*--------------------------------------------------------------------------
* GetJumpData
*--------------------------------------------------------------------------
GetJumpData:
	jumpData = @PATH
	If IsNew Then
		jumpData<1,2> = "<<New>>"
		jumpData<1,3> = CurBuf
	End Else
		jumpData<1,2> = BufInfo<BI.FILE>
		jumpData<1,3> = BufInfo<BI.ITEM>
	End
	jumpData<1,4> = Y
	jumpData<1,5> = X
	jumpData<1,6> = Rec<Y>[X,1]
	jumpData<1,7> = Lines
	jumpData<1,8> = Top
	jumpData<1,9> = XOffSet
	If jumpData<1,2> = "" And jumpData<1,3> = "" Then jumpData = ""
Return

*--------------------------------------------------------------------------
* StackJumpHistory
*--------------------------------------------------------------------------
StackJumpHistory: ;** Jump履歴の蓄積
	
	jumpHistoryPos = 0
	
	!! 重複は排除してスタックに積む
	GoSub GetJumpData
	If jumpData >< "" And jumpData >< jumpHistory<1> Then
		Ins jumpData Before jumpHistory<1>
		Del jumpHistory<31> ;** Jump履歴は30個までとする
	End

Return

*--------------------------------------------------------------------------
* RestoreFromJumpData
*--------------------------------------------------------------------------
RestoreFromJumpData: ;** jumpDataからカーソル位置を復元

	If jumpData = "" Then Return
	
	!! Accountが違っていたら開くことはできない
	If jumpData<1> >< @PATH Then Return
	
	!! 現在のファイルでなかったらレコードを開く
	If Not(jumpData<2> = BufInfo<BI.FILE> And jumpData<3> = BufInfo<BI.ITEM>) Then
		If jumpData<2> = "<<New>>" Then
			!! バッファ指定
			Found = jumpData<3>
			If Not(BufInfos(Found)<BI.USED>) Then Return 
			CurBuf = Found
		End Else
			!! レコード指定
			FileName = jumpData<2>
			ItemName = jumpData<3>
			GoSub DoRead.Without.Jump
			If Not(Found) Then Return
		End
	End
	
	!! カーソル位置の整合性チェック
	tY = jumpData<4>
	tX = jumpData<5>
	If Rec<tY>[tX,1] >< jumpData<6> Then
		If Line >< jumpData<7> Then
			!! 行数の変化を補正して再チェック
			tY += Lines - jumpData<7>
			If Rec<tY>[tX,1] >< jumpData<6> Then Return
		End Else Return
	End
	
	!! カーソル移動実行
	Y = tY
	X = tX
	keepDP_X = X
	Top = jumpData<8>
	XOffSet = jumpData<9>
	
	Top = Y - Int(Depth / 2) ;** センタリング
	
	jumpData = "" ;** JumpできたらjumpDataをクリアする

Return

*---------------------------------------------------------------------------
* DoConfig - configure terminal
*---------------------------------------------------------------------------
DoConfig: 
	Return
*--------------------------------------------------------------------------
* DoInsert
*--------------------------------------------------------------------------
DoInsert: 
	GoSub GetFile
	If FileName = "" then Return
	GoSub GetItem
	If ItemName = "" Then Return
	Read Temp From TFL, ItemName Else
		StatusMessage = "Cannot Read ":FileName:" ":ItemName
		Redraw = REDRAW.ALL
		Close TFL
		Return
	End
	Close TFL
	InsBuffer = Temp
	GoSub InsertLines
Return
	
*--------------------------------------------------------------------------
* DoRead
*--------------------------------------------------------------------------
DoRead:

	!! 現在位置をJump履歴に格納
	GoSub StackJumpHistory

	GoSub DoRead.Without.Jump
	
	!! 見つからなかった場合は格納したJump履歴を消す
	If Not(Found) Then Del jumpHistory<1>
	
Return

*--------------------------------------------------------------------------
* DoRead.Without.Jump
*--------------------------------------------------------------------------
DoRead.Without.Jump:

	Found = False
	
	!! Buffer内にすでに該当のItemが存在するか調べる
	listCnt = DCount(lruBuffList,@FM)
	For I = 1 To listCnt Until Found
		no = lruBuffList<I>
		info = BufInfos(no)
		If info<BI.USED> Then
			If @PATH = info<BI.ACCOUNT> Or @WHO = info<BI.ACCOUNT> Then
				If info<BI.ITEM> = ItemName And info<BI.FILE> = FileName Then
					If info<BI.FIELDFIX> = FldInfo And info<BI.PBUFNO> = ParentBufNo And info<BI.VALUEFIX> = DiveValuePos Then
						Found = no
						GoSub ChangeBuf
						GoSub Act.Reload
						Return
					End
				End
			End
		End
	Next
	
	If FileName = "" And ItemName = "" Then
		!! 新規作成
		GoSub DoNew
		Return
	End
	
	!! 空きBuffer取得
	GoSub GetFreeBuf
	If Not(Found) Then
		StatusMessage = "Cannot Get Free Buffer"
		Return
	End
	
	CurBuf = Found ;** CurBufをセット
	IsNew = False

	!! バッファ番号を直近リストの先頭に設定
	Ins CurBuf Before lruBuffList<1>
	
	GoSub ReadItem
	
Return

** OS文字列の取得
GET.OSBS:
$IFNDEF U2__UNIVERSE
	If IS.ECS(IN.OSBS) Then
		IF SYSTEM(91) THEN
			TEMP.PATH = "TMPSISH":@USERNO
			OPENSEQ TEMP.PATH ENCODING "UTF16.BL" TO FP ELSE CREATE FP ELSE ABORT "Cannot create temp file ->":TEMP.PATH
			WRITEBLK IN.OSBS TO FP ELSE ABORT
			WEOFSeq FP
			CLOSESEQ FP
			OS.EXECUTE "type ":TEMP.PATH CAPTURING OUT.OSBS
			OSDelete TEMP.PATH
		END ELSE
			OUT.OSBS = ICONV(IN.OSBS,"XUTF8")
		END
	End Else
		OUT.OSBS = IN.OSBS
	End
	Return
$ENDIF

** ファイルを開くの共通化
Common.OpenFile:
	
$IFNDEF U2__UNIVERSE
	If Upcase(FileName[1,5]) = "PATH:" Then
		IN.OSBS = FileName
		GOSUB GET.OSBS
		!! PATH:なら READ:自動認識 WRITE:UTF8
		Open OUT.OSBS ENCODING "UTF8.ABD" To FL Else
			StatusMessage = "Cannot Open ":FileName
			Return
		End
		Return
	End
$ENDIF

	Open FileName To FL Else
		StatusMessage = "Cannot Open ":FileName
		Return
	End

Return

Common.CloseFile:
	If Not(BufInfo<BI.LOCKED>) Then Close FL
Return

*-----------------------------------------------------------------------
*  ReadItem
*-----------------------------------------------------------------------
ReadItem:
	
	PathName = ""
	If ParentBufNo Then
		!! 親バッファからコピー
		Rec = Bufs(ParentBufNo)
	End Else If FileName Match "'#'1N":@VM:"'#'10" Then
		!! 選択リストから開く
		ReadList Rec From FileName['#',2,1] Then
			FormList Rec To FileName['#',2,1] ;** KEEP
		End Else
			Rec = ""
		End
	End Else
		!! ファイルから開く
		GoSub Common.OpenFile
		IF FILEINFO(FL,3)=4 THEN
			IF FileName[1,5]="PATH:" THEN
				PathName = FileName[6,*]:(IF SYSTEM(91) THEN "\" ELSE "/"):ItemName
			END ELSE
				!! DIRECTORYファイルからパス名を取得
				PathName = FILEINFO(FL,2):(IF SYSTEM(91) THEN "\" ELSE "/"):ItemName
			END
			IN.OSBS = ItemName
			GOSUB GET.OSBS
		END ELSE
			OUT.OSBS = ItemName
		END
		Read Rec From FL,OUT.OSBS Then
			!!
			!! レコードの読み取り
			!! 更新ロックが取れるか一度試して取れなければReadOnlyにする
			!!
			RecordLockU FL,OUT.OSBS Locked
				StatusMessage = "Record previously Locked by ":Status():", Open as Read Only mode"
				ReadOnly = True 
			End
			Release FL,OUT.OSBS ;** 更新ロックは常時保持はしない
		End Else
			Rec = ""
			IsNew = True
		End
		GoSub Common.CloseFile
	End

	GoSub StartBuf

	!! 改行コードが残っていたら自動除外
	Convert CHAR(10):CHAR(13) To '' In Rec
	
	If FldInfo Then
		!! フィールド指定モード
		dictFileName = "DICT ":FileName
		list = Convert(' ',@FM,FldInfo)
		cnt = DCount(list,@FM)
		For i = 1 To cnt
			fldInfo = ""
			fldInfo<1> = ""      ;** 1:location
			fldInfo<2> = list<i> ;** 2:fieldId
			fldInfo<3> = ""      ;** 3:Conv 
			If fldInfo<2> Matches "F0N" Then
				fldInfo<1> = fldInfo<2>[2,9999]
			End Else
				dictRec = Raise(Trans(dictFileName,fldInfo<2>,-1,'X'))
				If dictRec[1,1] = "D" And dictRec<2> >= 1 Then
					fldInfo<1> = dictRec<2>  ;** location
					fldInfo<3> = dictRec<3>  ;** Conv
					fldInfo<4> = dictRec<4>  ;** 4.NAME
					fldInfo<5> = dictRec<5>  ;** 5.FMT
					fldInfo<6> = dictRec<6>  ;** 6.S/M
					fldInfo<7> = dictRec<7>  ;** 7.ASSOC
					fldInfo<8> = dictRec<12> ;** 8.CONSTRAINT
				End Else If dictRec[1,2] = "PH" Then
					!! PHraseで置き換えてもう一度
					list<i> = @FM:Convert(' ',@FM,dictRec<2>)
					cnt = DCount(list,@FM)
					Continue
				End
			End
			If fldInfo<1> Then
				!! 物理位置が存在したら登録する
				TgtFld<-1> = Lower(fldInfo)
			End
		Next
		
		TgtFld.Cnt = DCount(TgtFld,@FM)
		If TgtFld.Cnt > 0 Then	
			!! マルチバリューを行展開したレコードの構築
			tmpRec = ""
			fCnt = DCount(TgtFld,@FM)
			For f = 1 To fCnt
				If BufInfo<BI.VALUEFIX> Then
					!! バリューにダイブ
					no = f + (BufInfo<BI.VALUEFIX> - 1) * fCnt
					sep = @SVM
				End Else
					!! フィールド固定モード
					no = TgtFld<f,1>
					sep = @VM
				End
				list = Rec<no>
				
				If Not(ParentBufNo) Then
					!! 物理ファイルからの場合はConversionがあれば適応
					conv = TgtFld<f,3>
					If conv Then list = OConvS(list,conv)
				End
				
				cnt = DCount(list,sep)
				For v = 1 To cnt
					tmpRec<f + (v - 1) * fCnt> = Field(list,sep,v)
				Next
			Next
			Rec = tmpRec ;** 抽出したレコードに置き換え
			
		End
	
	End Else
		GoSub DoShowDictInfo
		If TgtFld Then
			For i=1 To DCount(TgtFld,@FM)
				If TgtFld<i,3> Then
					Rec<i> = OConvS(Rec<i>,TgtFld<i,3>) ;** Conversion
				End
			Next
		End
	End
	
	** 辞書ならバイナリデータを削る
	If FileName[1,4] = "DICT" Then Rec = Rec[@FM,1,15] 

	!! 現在の行数の設定
	Lines = If Rec = "" Then 1 Else DCount(Rec,@fm)

Return
	
*-----------------------------------------------------------------------
*  DoLock
*-----------------------------------------------------------------------
DoLock:
	
	If IsNew Then
		StatusMessage = BG.RED:"Cannot get Lock, because not stored Item."
		Return
	End
	
DoLock.Impl:
	
	Redraw.StatusLine = @true
	
	FileName = BufInfo<BI.FILE>
	ItemName = BufInfo<BI.ITEM>
	
	If FileName Match "'#'1N":@VM:"'#'10" Then
		StatusMessage = "Cannot lock at select list"
		Return
	End
	
	!! レコード格納先ファイルのオープン
	GoSub Common.OpenFile
	
	If BufInfo<BI.LOCKED> Then    
		** ロック中ならロックを外す
		Release FL, ItemName
		BufInfo<BI.LOCKED> = @FALSE
		StatusMessage = "Unlock"
	End Else
		** ロック中でないなら更新ロックを取得する
		If Changed Then GoSub CheckSave
		If Changed Then Return
		If ReadOnly Then
			RecordLockL FL, ItemName Locked
				StatusMessage = "Record previously Locked by ":Status()
				GoSub Common.CloseFile
				Return
			End
			StatusMessage = "Get 'RL' Lock"
		End Else
			RecordLockU FL, ItemName Locked
				StatusMessage = "Record previously Locked by ":Status()
				GoSub Common.CloseFile
				Return
			End
			StatusMessage = "Get 'RU' Lock"
		End
		BufInfo<BI.LOCKED> = @TRUE
	End
	
	GoSub Common.CloseFile
Return

*-----------------------------------------------------------------------
*  DoList
*-----------------------------------------------------------------------
DoList: 
	LTop = 0
	LRefresh = True
	LFin = False
	Option = ""
	Loop
	Until LFin Do
		If LRefresh Then
			Crt @(0,0):@(-3):
			For LI = 1 to LISTDEPTH
				Crt @(0,LI + 1):(LI + LTop "R#5"):". ":List<LI + LTop>:
			Next
			LRefresh = False
		End
		PromptLine = "Up Down Top Bottom number or ESC :"; GoSub PromptLine
		GoSub GetKey
		Begin Case
			Case Upcase(C) = "U" Or actNo = A.UP
				If LTop >= LISTDEPTH Then
					LTop -= LISTDEPTH
					LRefresh = True
				End
			Case Upcase(C) = "D" Or actNo = A.DOWN
				LTop += LISTDEPTH
				LRefresh = True
			Case actNo = A.CANCEL
				LFin = True
			Case C Matches "1n"
				Number = C
				Crt C:
				Input C
				Number := C
				If Number Matches "1n0n" then
					If Number > 0 And Number <= DCount(List,@fm) Then
						Option = List<Number>
						LFin = True
					end
				End
			End case
	Repeat
	Return
*-----------------------------------------------------------------------
*  DoNew
*-----------------------------------------------------------------------
DoNew:  
	FileName = ""
	ItemName = ""
	PathName = ""
	GoSub GetFreeBuf
	If Not(Found) Then Return
	GoSub StackJumpHistory
	CurBuf = Found
	Ins CurBuf Before lruBuffList<1>
	Rec = ""
	GoSub StartBuf 
	IsNew = True
	Return
*-----------------------------------------------------------------------
*  DoPrint
*-----------------------------------------------------------------------
DoPrint: 
	Crt @(0,@CRTHIGH-2):
	Echo Off
	Printer On
	Echo On
	PWidth = @LptrWide - 5
	PDepth = @LptrHigh - 3
	Dc = DCount(Rec,@fm)
	PLine= ""
	PRow = 0
	PNo = 0
	PPage = 1
	Printer On
	GoSub DoPrintHeader
	Loop
		PNo += 1
	Until PNo > Dc Do
		PLine = Rec<PNo>
		SOL = @TRUE
		Loop
			If SOL Then
				OutLine = PNo "R%4":":"
			End Else
				OutLine = " ==> "
			End
			OutLine := PLine[1, PWidth]
			PLine = PLine[PWidth+1, HUGE]
			PRow += 1
			SOL = @False
			If PRow > PDepth Then
				GoSub DoPrintFooter
				GoSub DoPrintHeader
			End
			Print OutLine
		Until PLine = "" Do
		Repeat
	Repeat
	GoSub DoPrintFooter
	Crt @(0,@CRTHIGH-2):
	Printer Off
	Echo Off
	Crt @(0,@CRTHIGH-2):
	Printer Close
	Echo On
	StatusMessage = ""
	Return
*-----------------------------------------------------------------------
*  DoPrintFooter
*-----------------------------------------------------------------------
DoPrintFooter: 
	Print Str("-",@LptrWide)
	Print OConv(date(),"D4"):" Page ":PPage
	Page
	PPage += 1
	Return
*-----------------------------------------------------------------------
*  DoPrintHeader
*-----------------------------------------------------------------------
DoPrintHeader: 
	If BufInfo<BI.FILE> = "" Then
		Print "Untitled"
	End Else
		Print BufInfo<BI.FILE>:" ":BufInfo<BI.ITEM>
	End
	Print Str("-",@LptrWide)
	Print
	PRow = 3
	StatusMessage = "Printing Page ":PPage
	Return
*-----------------------------------------------------------------------
*  DoOpen
*-----------------------------------------------------------------------
DoOpen: 
	GoSub GetFile
	If FileName = "" Then Return
	GoSub GetItem
	If ItemName = "" then Return
	GoSub DoRead
	Return


*-------------------------------------------------------------------------
*  辞書による補助表示
*-------------------------------------------------------------------------
DoShowDictInfo:
	
	IF FileName = "" Then Return ;** Newバッファは無視
	
	If BufInfo<BI.FIELDFIX>="" Then
		!! 物理位置に辞書を登録する
		If BufInfo<BI.PARSETYPE> = PARSE.DATA Then
			If FileName[1,4] = "DICT" Then
				!! 辞書の場合は固定
				TgtFld<1,1> = 1:@VM:@VM:@VM:"TYPE"
				TgtFld<2,1> = 2:@VM:@VM:@VM:"LOC"
				TgtFld<3,1> = 3:@VM:@VM:@VM:"CONV"
				TgtFld<4,1> = 4:@VM:@VM:@VM:"NAME"
				TgtFld<5,1> = 5:@VM:@VM:@VM:"FMT"
				TgtFld<6,1> = 6:@VM:@VM:@VM:"S/M"
				TgtFld<7,1> = 7:@VM:@VM:@VM:"ASSOC"
				TgtFld<12,1> = 12:@VM:@VM:@VM:"CONST"
			End Else If FileName = "VOC" OR FileName[1,4] = "PVOC" Then
				!! VOC
				IF Upcase(Rec[1,1]) = "V" Then
					TgtFld<1,1> = 1:@VM:"F1":@VM:@VM:"V {Desc}"
					TgtFld<2,1> = 2:@VM:"F2":@VM:@VM:"Dispatch code"
					TgtFld<3,1> = 3:@VM:"F3":@VM:@VM:"Processor"
					TgtFld<4,1> = 4:@VM:"F4":@VM:@VM:"{Qualifying}"
					TgtFld<5,1> = 5:@VM:"F5":@VM:@VM:"{Security Subr}"
				End Else If Upcase(Rec[1,1]) = "F" Then
					TgtFld<1,1> = 1:@VM:"F1":@VM:@VM:"F {Desc}"
					TgtFld<2,1> = 2:@VM:"F2":@VM:Trans("DICT VOC","DATA.NAME",3,""):@VM:"Data Path"
					TgtFld<3,1> = 3:@VM:"F3":@VM:Trans("DICT VOC","DICT.NAME",3,""):@VM:"Dict Path"
					TgtFld<4,1> = 4:@VM:"F4":@VM:@VM:"Subfiles"
$IFNDEF U2__UNIVERSE
					TgtFld<5,1> = 5:@VM:"F5":@VM:@VM:"inclusion flags"
					TgtFld<6,1> = 6:@VM:"F6":@VM:@VM:"open mode"
					TgtFld<7,1> = 7:@VM:"F7":@VM:@VM:"encoding"
$ENDIF
				End Else If Upcase(Rec[1,1]) = "Q" Then
					TgtFld<1,1> = 1:@VM:"F1":@VM:@VM:"Q {Desc}"
					TgtFld<2,1> = 2:@VM:"F2":@VM:@VM:"Account"
					TgtFld<3,1> = 3:@VM:"F3":@VM:@VM:"Filename"
					TgtFld<4,1> = 4:@VM:"F4":@VM:@VM:"Server"
				End
			End Else
				Open "DICT",FileName To fpDict Else Return
				!! 物理位置で辞書をセット
				Read a From fpDict,"@MODIFY" Then
					FormList Convert(" ",@FM,a)
				End Else
					Select fpDict
				End
				Loop
					Readnext dict.id Else Exit
					Read dict.rec From fpDict,dict.id Then
						If upcase(dict.rec[1,1]) = 'D' Then
							n = trim(dict.rec<2>)
							If n >= 1 Then
								If TgtFld<n>="" Then
									TgtFld<n,1> = n            ;** 1.location
									TgtFld<n,2> = dict.id      ;** 2.ID
									TgtFld<n,3> = dict.rec<3>  ;** 3.conv
									TgtFld<n,4> = dict.rec<4>  ;** 4.NAME
									TgtFld<n,5> = dict.rec<5>  ;** 5.FMT
									TgtFld<n,6> = dict.rec<6>  ;** 6.S/M
									TgtFld<n,7> = dict.rec<7>  ;** 7.ASSOC
									TgtFld<n,8> = dict.rec<12> ;** 8.CONSTRAINT
								End
							End
						End
					End
				Repeat
			End
		End
	End
	
	If TgtFld Then
		id.max = 0
		name.max = 0
		For i=1 To DCount(TgtFld,@FM)
			id.max = Max(id.max,LenDP(TgtFld<i,2>)) ;** 2.ID
			name.max = Max(name.max,LenDP(TgtFld<i,4>));** 4.Name
		Next
		biInfoWide.dict = (id.max+1):@SVM:(name.max+1)
	End

	Return

DoHideDictInfo:

	If BufInfo<BI.FIELDFIX>="" Then
		!! Conversion
		fldCnt = DCount(TgtFld,@FM)
		For i = 1 To fldCnt
			fno = TgtFld<i,1>
			conv = TgtFld<i,3>
			If conv Then Rec<fno> = IConvS(Rec<fno>,conv)
		Next
		TgtFld = ""
		biInfoWide.dict = 0
	End

	Return

*-----------------------------------------------------------------------
*  InitChoiceList
*    In :
*      choiceList - 選択データ @FM区切り 1Value目が表示される
*      choiceNo - 初期選択位置
*      title - ウィンドウの色とタイトル
*-----------------------------------------------------------------------
InitChoiceList: ;** 選択リストボックス初期化
	
	choiceList.length = DCount(choiceList,@FM)
	
	If choiceOrgY=0 Then
		!! 右側モード
		winHeight = Depth - 2 - choiceOrgY
		tmp = ""
		For i = 1 To choiceList.length
			tmp<-1> = LenDP(choiceList<i,1>)
		Next
		winWidth = Maximum("20":@FM:tmp) + 1
		If winWidth > Width*2/3 Then winWidth = Int(Width*2/3)
		winX = Width - winWidth
		winTop = 0
		
		crtBuff = @(winX,0):title:@(-4)
		crtBuff := @(winX,1):" "
		For i = 1 To winHeight
			crtBuff := @(winX,i+1):" "
		Next
		Crt crtBuff:
		winX += 1
	End Else
		!! 下側モード
		winWidth = Width - 1
		winX = 0
		winTop = 0
		winHeight = Depth - choiceOrgY + 1
		crtBuff = @(0,choiceOrgY):BG.BASE3:@(-4)
		For i = choiceOrgY To choiceOrgY+winHeight
			crtBuff := @(0,i):" "
		Next
		Crt crtBuff:
	End
	
	filterPrev = char(0)
	choiceSelNo = choiceNo
	choiceOutList.length = choiceList.length
	C = ""
	choiceParse = @False
	choiceActive = @TRUE
	
	prevCurBuf = CurBuf
	CurBuf = MAXWINDOWS + 1
	
	GoSub InitBuf
	
	!! フィルター初期値全選択置換
	GoSub Act.SelAll
	InsBuffer = filter
	GoSub InsertLines

	!! 選択範囲の描画
	Line = filter
	Row = 1
	X = If filter[1,1]=" " Then 2 Else Len(filter)+1
	BufInfo<BI.BLOCKSTART> = ""
	HI.OFF = FG.BASE03:BG.BASE3
	GoSub ParseLine.Impl
	PFilter = PLine
	PFilter.X = If Len(Rec) >= X Then LenDP(Rec[X,HUGE]) Else ""
	
	CurBuf = prevCurBuf

Return
*-----------------------------------------------------------------------
*  ProcChoiceList
*    In :
*      C - キーコード
*      choiceActive - 活性モード表示 0/1
*    Out :
*      choiceSelection - 選択された物 choiceList<choiceNo>
*      filter - フィルタ
*-----------------------------------------------------------------------
ProcChoiceList:
	
	!! キーイベント共通
	If C >< "" Then
		Begin Case
		
			!! リストの操作
			Case actNo = A.UP
				choiceNo -= 1
			Case actNo = A.SHIFT_TAB
				choiceNo -= 1
			Case actNo = A.DOWN
				choiceNo += 1
			Case actNo = A.TAB
				choiceNo += 1
			Case actNo = A.PREVSTMT
				choiceNo -= 4
			Case actNo = A.NEXTSTMT
				choiceNo += 4
			Case actNo = A.PREVPAGE
				choiceNo -= winHeight
			Case actNo = A.NEXTPAGE
				choiceNo += winHeight
			Case actNo = A.PREVHALF
				choiceNo -= Int(winHeight / 2)
			Case actNo = A.NEXTHALF
				choiceNo += Int(winHeight / 2)
			Case actNo = A.HOME
				choiceNo = 1
			Case actNo = A.END
				choiceNo = choiceOutList.length
			Case actNo = A.NEWLINE
				!! 何もしない

			!! 共通アクション
			Case 1
				prevCurBuf = CurBuf
				CurBuf = MAXWINDOWS + 1
				
				keepSelection = @False
				GoSub Input.Actions
				
				** --------------------------
				** 選択範囲調整
				** --------------------------
				If keepSelection Then
					** 選択終了位置
					If Not(BufInfo<BI.BLOCKEND>) Then BufInfo<BI.BLOCKEND> = Y:@VM:X
					If BufInfo<BI.BLOCKSTART>=BufInfo<BI.BLOCKEND> Then
						BufInfo<BI.BLOCKSTART> = ""
						BufInfo<BI.BLOCKEND> = ""
					End
				End Else
					** 選択範囲が外れた
					BufInfo<BI.BLOCKSTART> = ""
					BufInfo<BI.BLOCKEND> = ""
				End
				filter = Rec

				!! 選択範囲の描画
				Line = filter
				Row = 1
				HI.OFF = FG.BASE03:BG.BASE3
				GoSub ParseLine.Impl
				PFilter = PLine
				PFilter.X = If Len(Rec) >= X Then LenDP(Rec[X,HUGE]) Else ""
				
				CurBuf = prevCurBuf	
		End Case
		C = ""
	End

	!! フィルター処理
	If filter >< filterPrev Then
		choiceOutList = ""
		filterCnt = 0
		If TRIM(filter)="" Then
			For i = 1 To choiceList.length
				choiceOutList<-1> = i ;** choiceListへの参照を保持
			Next
		End Else
			Dim filterUpcase(10) ;** And検索は最大10まで
			a = UpCase(filter)
			If filter[1,1]=" " Then
				!! スペースで始まる場合は単語単位の前方一致で検索
				filterCnt = 1
				For i = 1 To choiceList.length
					line = choiceList<i>
					p = Index(line,filter[2,9999])
					If p>0 And (p=1 Or Convert(PUNCS:".","",line[p-1,1])="") Then
						choiceOutList<-1> = i ;** choiceListへの参照を保持
					End
				Next i
			End Else
				!! スペース区切り単語のAND検索
				MatParse filterUpcase From Trim(a)," " Setting filterCnt
				For i = 1 To choiceList.length
					line = UpCase(choiceList<i>)
					flg = @True
					For j = 1 To filterCnt
						If Index(line,filterUpcase(j))=0 Then
							flg = @False
							Exit ;** １つでも一致しなければ抜ける
						End
					Next j
					If flg Then choiceOutList<-1> = i ;** choiceListへの参照を保持
				Next i
			End
		End
		choiceOutList.length = DCount(choiceOutList,@FM)
		filterPrev = filter
		tmpY = choiceNo - winTop
		Locate choiceSelNo In choiceOutList By "AR" Setting choiceNo Else
			choiceNo = choiceNo - 1
		End
		winTop = choiceNo - tmpY
		If winTop < 0 Then winTop = 0
	End

	!! 選択範囲チェック
	If choiceNo < 1 Then choiceNo = 1 Else
		If choiceNo >= choiceOutList.length Then choiceNo = choiceOutList.length
	End

	!! リスト表示
	tmpY = winTop + SCROLLMERGINE + 1
	If choiceNo < tmpY Then
		winTop -= tmpY - choiceNo
		If winTop < 0 Then winTop = 0
	End Else
		tmpY = winHeight + winTop - SCROLLMERGINE
		If choiceNo > tmpY Then
			winTop += choiceNo - tmpY
		End
	End
	
	If choiceOrgY=0 Then
		!! タイトルに件数
		crtBuff = @(winX-1,0):title:" (":choiceOutList.length:")":@(-4)
		winY = 1
	End Else
		crtBuff = ""
		winY = choiceOrgY
	End
	
	HI.OFF = SGR.ALL.OFF
	crtBuff := HI.OFF
	listLen = choiceOutList.length - winTop
	If listLen > winHeight Then listLen = winHeight
	i = 1
	Loop While i <= listLen
		no = choiceOutList<winTop+i,1>
		selected = (choiceNo = winTop+i) ;** 選択行か？
		Line = choiceList<no,1>
$IFDEF U2__UNIVERSE
		Line = Line[1,Len(FoldDP(Convert(" ","-",Line),winWidth,"UTF8")<1>)]
$ELSE
		Line = Line[1,Len(FoldDW(Convert(" ","-",Line),winWidth)<1>)]
$ENDIF
		crtBuff := @(winX,i+winY)
		crtBuff := If choiceOrgY=0 Then title[" ",1,1] Else BG.BASE3
		If selected Then
			If choiceActive Then crtBuff := BG.BASE2
		
			If choiceParse Then
				XOffSet = 1
				selection = 1:@FM:BIG
				LineWidth = winWidth
				Selection.Color = BG.BASE2:FG.BASE01
				Selection.Key.Color = HI.KEY.ON
				GoSub ParseLine2
				Row = choiceList<no,2>
				GoSub Get.Gyo
				PLine = FG.BASE01:Gyo:PLine:If choiceActive Then BG.BASE2 Else ""
				Line = Gyo:Line
			End Else
				If choiceActive Then
					PLine = BG.BASE2:FG.BASE02:Line
				End Else
					PLine = Line
				End
			End
		End Else
			crtBuff := FG.BASE01:BG.BASE3
			If choiceParse Then
				XOffSet = 1
				selection = ""
				LineWidth = winWidth
				GoSub ParseLine2
				Row = choiceList<no,2>
				GoSub Get.Gyo
				PLine = FG.BASE0:Gyo:PLine
				Line = Gyo:Line
			End Else PLine = Line
		End
		crtBuff := PLine:@(-4)
		If filterCnt>0 Then
			!! フィルター文字と一致するものに色を付ける
			If filter[1,1]=" " Then
				crtBuff := Char(13)
				If choiceOrgY=0 Then crtBuff := CSI:(winX):"C"
				fi = filter[2,9999]
				fi.len = Len(fi)
				li = Line
				Loop
					p = Index(li,fi)
				While p
					If p=1 Or Convert(PUNCS:".","",li[p-1,1])="" Then
						If p>1 Then crtBuff := CSI:(LenDP(li[1,p])-1):"C"
						If choiceActive Then crtBuff := FG.RED
						crtBuff := li[p,fi.len]
					End
					li = li[p+fi.len,9999]
				Repeat			
			End Else
				For j = 1 To filterCnt
					crtBuff := Char(13)
					If choiceOrgY=0 Then crtBuff := CSI:(winX):"C"
					li = Line
					Loop
						p = Index(UpCase(li),filterUpcase(j))
					While p
						If p>1 Then crtBuff := CSI:(LenDP(li[1,p-1])):"C"
						If choiceActive Then crtBuff := FG.RED
						crtBuff := li[p,Len(filterUpcase(j))]
						li = li[p+Len(filterUpcase(j)),9999]
					Repeat			
				Next j
			End
		End
		i += 1
	Repeat
	crtBuff := BG.BASE3
	Loop While i <= winHeight
		crtBuff := @(winX,i+winY):@(-4)
		i += 1
	Repeat
	
	!! フィルター入力欄表示
	
	If choiceOrgY=0 Then
		crtBuff := @(winX,1):FG.YELLOW:":":BG.BASE3:PFilter:@(-4)
	End Else
		crtBuff := @(winX,winY)
		If choiceActive Then
			If choiceActive Then crtBuff := FG.BLUE
			crtBuff := BG.BASE3
			If title#"" Then crtBuff := title
			crtBuff := " ":Fmt("(":choiceOutList.length:")",Len(choiceList.length)+2:"L")
			crtBuff := " :"
			crtBuff := If choiceActive Then PFilter Else filter
		End
		crtBuff := HI.OFF:@(-4)
	End
	If PFilter.X#"" Then crtBuff := @(-9,PFilter.X) ;** 実際のカーソル位置に戻す
	crtBuff := SGR.ALL.OFF
	GoSub CRT.BUFF.FLUSH
	choiceSelNo = choiceOutList<choiceNo>
	choiceSelection = choiceList<choiceSelNo>

Return

Get.Gyo:
	If Row > 9999 Then
		Gyo = (Rem(Row,10000) "R%4"):" " ;* 行番号
	End Else
		Gyo = (Row "4R"):" " ;* 行番号
	End
	Return

*--------------------------------------------------------------------------
* SelectionStart:
*--------------------------------------------------------------------------
SelectionStart:

	keepSelection = @TRUE
	
	!! 未選択状態なら開始位置をセット
	If Not(BufInfo<BI.BLOCKSTART>) Then
		BufInfo<BI.BLOCKSTART> = Y:@VM:X
	End
	
	Return

*--------------------------------------------------------------------------
* GoToRangeStart:
*--------------------------------------------------------------------------
GoToRangeStart:
	!! 選択継続中でカーソルと範囲選択終了の位置が違う場合は
	!! カーソルを範囲先端に持っていく
	If BufInfo<BI.BLOCKEND> <> Y:@VM:X And keepSelection Then
		!! Go To Range Start
		GoSub GetSelBlock
		Y = blockStart<1>
		X = blockStart<2>
		BufInfo<BI.BLOCKSTART> = BufInfo<BI.BLOCKEND>
	End
	If Not(keepSelection) Then
		Redraw = REDRAW.ALL
	End
	BufInfo<BI.BLOCKEND> = ""
	Return

*--------------------------------------------------------------------------
* GoToRangeEnd:
*--------------------------------------------------------------------------
GoToRangeEnd:
	!! 選択継続中でカーソルと範囲選択終了の位置が違う場合は
	!! カーソルを範囲終端に持っていく
	If BufInfo<BI.BLOCKEND> <> Y:@VM:X And keepSelection Then
		!! Go To Range End
		GoSub GetSelBlock
		Y = blockEnd<1>
		X = blockEnd<2>
	End
	If Not(keepSelection) Then
		Redraw = REDRAW.ALL
	End
	BufInfo<BI.BLOCKEND> = ""
	Return

* *
* GetKey - Output: actNo, C, n

GetKey:
	actNo = 0
	Loop
		
		** キー入力待ち
		C = KeyIn()
		
AfterKeyWait:
				
		n = UniSeq(C) ;** １文字目の文字列数値表記
 		If (n >= 32 And n < 127) OR (n > 255) Then
			actNo = A.INSCHAR
			Return
		End
		
		!! 特殊なエスケープシーケンスを拾う
		If n = 27 Then
			GoSub GetCh.Timeout ; C := ch
			If ch = "" Then
				!! 単独ESC
				Locate C in keys By 'AL' Setting i Then
					actNo = keysToAction<i,1>
					Return
				End
			End Else If ch = "[" Then
				!! CSIシーケンス開始
				GoSub GetCh.Timeout ; C := ch
				If ch = "2" Then
					GoSub GetCh.Timeout ; C := ch
					If ch = "~" Then
						!! Toggle Overlay Mode
						bOverlay = Not(bOverlay)
						If bOverlay Then
							Crt OVERLAY.MODE.SEQ:
						End Else
							Crt INS.MODE.SEQ:
						End
						Return
					End Else If ch = "0" Then
						GoSub GetCh.Timeout ; C := ch
						If ch = "0" Then
							GoSub GetCh.Timeout ; C := ch
							If ch = "~" Then
								!! Bracketed Paste
								C = ""
								Loop
									GoSub GetCh.Timeout
								While ch <> ESC And ch <> ""
									C:= ch
								Repeat
								
								GoSub GetCh.Timeout ;** [
								GoSub GetCh.Timeout ;** 2
								GoSub GetCh.Timeout ;** 0
								GoSub GetCh.Timeout ;** 1
								GoSub GetCh.Timeout ;** ~
								
								InsBuffer = C
								actNo = A.PASTE

								Return
							End
						End
					End
				End Else If ch = "<" Then
					!! Mouse Tracking (SGR)
					C = ""
					Loop
						GoSub GetCh.Timeout
					While ch <> "M" And ch <> "m" And ch <> ""
						C := ch
					Repeat
					A = C[";",1,1]
					If A=64 Then
						actNo = A.WHEEL.UP
					End Else If A=65 Then
						actNo = A.WHEEL.DOWN
					End Else
						actNo = A.MOUSE
					End
					MOUSE = CONVERT(";",@FM,C):@FM:ch
					Return
				End Else If ch = "8" Then
					!! [TBD] 端末サイズの取得
					If C Matches "'":ESC:"[8'...'t'" Then
						** DECSLPP -> CSI Ps1 ; Ps2 ; Ps3 t
						Return
					End
				End Else If ch = "?" Then
					!! [DA] 端末属性
					Loop
						GoSub GetCh.Timeout
						C := ch
					While ch <> ""
					Repeat
					If CSI:"?2004;2$y" Then
						!! Brackets Paste Mode on
						Crt CSI:"?2004h":
						!! mintty系だと見越してついでに太字にも対応しているものとする
						
					End
				End

			End Else If ch = "]" Then
				!! OSC
				GoSub GetCh.Timeout ; C := ch
				If ch = "5" Then
					GoSub GetCh.Timeout ; C := ch
					If ch = "2" Then
						!! OS Clipboard Paste
						C = ""
						Loop
							GoSub GetCh.Timeout ; C := ch
						While ch <> BEL And ch <> ESC And ch <> ""
						Repeat
						If ch = ESC Then GoSub GetCh.Timeout ; ** ESC+\ を読み取る
						cdata = C
						last = Len(cdata)
						data = cdata[1,last-1][';',3,1]
$IFDEF U2__UNIVERSE
						retCode = ENCODE("Base64A", "2", data, "1", InsBuffer, "1")
$ELSE
						InsBuffer = ICONV(ICONV(data, "B64"),"XUTF8")
$ENDIF
						actNo = A.PASTE ;** 挿入処理
						Return
					End
				End
			End Else If ch = "P" Then
				!! DCS
				Loop
					GoSub GetCh.Timeout
					C := ch
				While ch <> ""
				Repeat
			End
		End
		
		Loop
			!! キーシーケンスからアクションを取得
			Locate C in keys By 'AL' Setting i Then
				actNo = keysToAction<i,1>
				Return
			End
		While keys<i>[1,Len(C)] = C
			GoSub GetCh.Timeout
		While ch <> ""
			C := ch
		Repeat
		
Get.Key.Err:
		
		Crt @SYS.BELL:
		
$IFDEF DEBUG
		strKey = ""
		z = Len(C)
		For i = 1 To z
			c = C[i,1]
			n = Seq(c)
			If n < 32 Then strKey := '@' : Char(n + 64)
			Else strKey := c
		Next
		StatusMessage = strKey
		Nap 200
$ENDIF
		
	Repeat
	Return

GetCh.Timeout:
$IFDEF U2__UNIVERSE
	For xxx = 1 To 4
		Input test,-1
		If test Then
			ch = KeyIn()
			Return
		End
		Nap 25 ;** 50ms * 4 = 100ms
	Next xxx
	ch = ""
$ElSE
	ch = KeyIn(0.1)
$ENDIF
	Return

*--------------------------------------------------------------------------
* Enters
*--------------------------------------------------------------------------
Enters:

	** カーソル位置描画
	GoSub PrintCursor
	
	** CRTフラッシュ処理
	If IS.CONSOLE Then
		Crt @(-32):crtBuff:@(-31):
	End Else
		Crt CSI:"?25l":crtBuff:
	End
	
	prevC = C ;** 前回の入力文字を保持
	
	GoSub GetKey
	
	crtBuff = ""
	
	Redraw = ""
	moveX = 0
	moveY = 0
	prevY = Y
	prevX = X
	prevTop = Top
	IndentCh = If IndentType = "Tab" Then Char(9) Else Space(STDTAB)

	keepSelection = @FALSE
	
	!! アクションを実行
	GoSub Switch.Actions
	Begin Case
		Case actNo = A.CANCEL
			GoSub Act.Action ;** メニュー表示
	End Case

Draw.Editor:
	
	Lines = If Rec = "" Then 1 Else DCount(Rec,@fm)
	
	If Y >= Lines Then
		Y = Lines
	End Else If Y < 1 Then
		Y = 1
	End
	
	If prevY >< Y Then moveY = True
	
	** --------------------------
	** X表示位置の計算
	** --------------------------
	Line = Rec<Y> ;** 現在Y行
	If moveY And prevX = X Then
		** X位置を表示位置から逆算する
		GoSub GetX.From.keepDPX
		X = outX
	End
	DP_X = 1
	FOR I=1 TO X-1
		c = Line[I,1]
		DP_X += If c = Char(9) Then STDTAB-REM((DP_X-1),STDTAB) Else LenDP(c)
	NEXT I
	
	moveX = (prevX >< X)
	If keepDP_X=0 Or (Not(moveY) And moveX) Then
		** X位置だけが動いた場合にkeepDP_Xを変える
		keepDP_X = DP_X
	End
	
	** --------------------------
	** Xスクロール位置調整
	** --------------------------
	If moveX Then
		If DP_X < XOffSet  Then
			XOffSet -= Int((@CRTWIDE - 1) / 2)
			Redraw = REDRAW.ALL
		End Else
			If DP_X > Width + XOffSet - 2 then
				XOffSet += Int((@CRTWIDE - 1) / 2) 
				Redraw = REDRAW.ALL
			End
		End
	End
	If XOffSet < 1 Then XOffSet = 1

	** --------------------------
	** Yスクロール位置調整
	** --------------------------
	If prevY >< Y Then
		tmpY = Top + SCROLLMERGINE
		If Y < tmpY Then
			Top -= tmpY - Y
		End Else
			tmpY = Depth + Top - SCROLLMERGINE - 1
			If Y > tmpY Then
				Top += Y - tmpY
			End
		End
	End
	If Top < 1 Then Top = 1
	
	If Not(IS.CONSOLE) And Redraw#REDRAW.ALL And prevTop#Top Then
		If prevTop<Top Then
			a = Top-prevTop
			If a <= SCROLL.DRAW.NUM Then
				!! 下に高速スクロール
				crtBuff := ESC:"[1;":Depth:"r":ESC:"[":a:"S":ESC:"[1;":@CRTHIGH:"r"
				For i=Top+Depth-a To Top+Depth-1 
					Redraw<-1> = i
				Next i
				IF moveY Then
					Find prevY In Redraw Else Redraw<-1> = prevY
					Find Y In Redraw Else Redraw<-1> = Y
				End
			End Else
				Redraw = REDRAW.ALL
			End
		End Else
			a = prevTop-Top
			If a <= SCROLL.DRAW.NUM Then
				!! 上に高速スクロール
				crtBuff := ESC:"[1;":Depth:"r":ESC:"[":a:"T":ESC:"[1;":@CRTHIGH:"r"
				For i=Top To prevTop-1
					Redraw<-1> = i
				Next i
				IF moveY Then
					Find prevY In Redraw Else Redraw<-1> = prevY
					Find Y In Redraw Else Redraw<-1> = Y
				End
			End Else
				Redraw = REDRAW.ALL
			End
		End
	End
	
	** --------------------------
	** 選択範囲調整
	** --------------------------
	If keepSelection Then
		** 選択終了位置
		If Not(BufInfo<BI.BLOCKEND>) Then BufInfo<BI.BLOCKEND> = Y:@VM:X
		Redraw = (If Not(moveY) And Redraw = 0 Then Y Else REDRAW.ALL)
		If BufInfo<BI.BLOCKSTART>=BufInfo<BI.BLOCKEND> Then
			BufInfo<BI.BLOCKSTART> = ""
			BufInfo<BI.BLOCKEND> = ""
		End
	End Else
		If BufInfo<BI.BLOCKSTART> Then
			** 選択範囲が外れた
			BufInfo<BI.BLOCKSTART> = ""
			If moveY OR BufInfo<BI.BLOCKSTART,1> >< BufInfo<BI.BLOCKEND,1> Then
				Redraw = REDRAW.ALL
			End Else
				If Redraw >< REDRAW.ALL Then Redraw = Y
			End
		End
		BufInfo<BI.BLOCKEND> = ""
	End
	
	** 描画処理
	If Redraw = REDRAW.ALL Then
		** 全画面描画
		GoSub PrintPage
	End Else
		** 指定行描画
		If Not(Redraw) Then Redraw = Y:@FM:prevY ;** デフォルトでは前回行と今回行を描画する
		Loop
			Row = Remove(Redraw,sep)
			If Row > 0 & Row <= Lines Then
				Line = Rec<Row>
				GoSub ParseLine
				GoSub PrintLine
			End
		While sep Repeat
		GoSub PrintStatus
	End
	
	Return

*-----------------------------------------------------------------------------
*  X位置を表示位置から逆算する
*  In:  keepDP_X,Line
*  Out: outX
*-----------------------------------------------------------------------------
GetX.From.keepDPX:
	** X位置を表示位置から逆算する
	tmpX = 0
	outX = 1
	Loop
		char = Line[outX,1]
		If char = "" Then Exit
		tmpX += If char = Char(9) Then STDTAB-REM(tmpX,STDTAB) Else LenDP(char)
	Until tmpX >= keepDP_X
		outX += 1
	Repeat
	Return

*--------------------------------------------------------------------------
* EditMenu
*--------------------------------------------------------------------------
EditMenu: 
	MenuLine = "Undo Redo (X)cut Copy Paste [paste from Local] :" ; GoSub MenuLine
	Ok = Upcase(C)
	Begin Case
		Case Ok = "U"
			GoSub Act.Undo
		Case Ok = "R"
			GoSub Act.Redo
		Case Ok = "X"
			GoSub Act.Cut
		Case Ok = "C"
			GoSub Act.Copy
		Case Ok = "P"
			GoSub Act.SendRemotePasteCmd
		Case Ok = "L"
			GoSub Act.PasteLocal
		End Case
	Return
*--------------------------------------------------------------------------
* FileMenu
*--------------------------------------------------------------------------
FileMenu: 
	If IsNew Then
		!! TODO 出来れば使用できないメニューは灰色表示にしたい
		MenuLine = "Showlist New Read Write writeAs View Close :"
	End Else
		MenuLine = "Showlist New Read Write writeAs rEload Close Lock Delete clOse_all :"
	End
	GoSub MenuLine
	Ok = Upcase(C)
	Begin Case
		Case Ok = "S"
			GoSub Act.ShowBuffList
		Case Ok = "N"
			GoSub DoNew
		Case Ok = "R"
			GoSub DoOpen
		Case Ok = "E"
			GoSub Act.Reload
		Case Ok = "W"
			GoSub SaveItem
		Case Ok = "C"
			GoSub Act.CloseBuff
		Case Ok = "A"
			GoSub SaveAs
		Case Ok = "L"
			GoSub DoLock
		Case Ok = "D"
			GoSub Delete
		Case Ok = "O"
			GoSub Act.AllCloseBuf
!!     Case Ok = "P"
!!       GoSub DoPrint
		End Case
	Return
*--------------------------------------------------------------------------
* Format
*   TODO: Undo/Redo対応
*--------------------------------------------------------------------------
Format: 
	FileName = BufInfo<BI.FILE>
	If FileName Match "'#'1N":@VM:"'#'10" Then
		Return
	End
	
	If FileName = "" Then FileName = "BP"
	GoSub Common.OpenFile
	Write Rec On FL, "%%format_temp%%"
	cmd = "FORMAT ":FileName:" %%format_temp%%"
	
$IFDEF U2__UNIVERSE
	Execute cmd, OUT>NULL
$ELSE
	Execute cmd SILENT STACKLIST
$ENDIF

	Read InsBuffer From FL, "%%format_temp%%" Else Null
	Delete FL, "%%format_temp%%"
	GoSub Common.CloseFile
	
	!! 全選択
	BufInfo<BI.BLOCKSTART, 1> = 1
	BufInfo<BI.BLOCKSTART, 2> = 1
	BufInfo<BI.BLOCKEND, 1> = Lines
	BufInfo<BI.BLOCKEND, 2> = Len(Rec<Y>) + 1
	
	GoSub InsertLines
	GoSub PrintPage
	
	Return
*---------------------------------------------------------------------------
* GetArgs
*---------------------------------------------------------------------------
GetArgs: 
	UArg = UpCase(CFileName)
	Begin CAse
		Case UArg = "-CONFIG"
			GoSub DoConfig
		End Case
	Return
*-----------------------------------------------------------------------
*   GetFile
*------------------------------------------------------------------------
GetFile:
	GotFile = False
	Loop
		PromptLine = "File Name, * to list or ESC ->" ; GoSub PromptLine
		inputBox = FileName
		GoSub InputBox
		NewFileName = inputBox
		Begin Case
			Case NewFileName = ""
				FileName = ""
				Redraw = REDRAW.ALL
				Return
			Case NewFileName = "*"
				PromptLine = "Selecting files ..." ; GoSub PromptLine
				Echo Off
				Crt @(0,PY-3):
				ExLine = "SSELECT VOC WITH F1 LIKE F... OR WITH F1 LIKE f..."
				ExLine := " OR WITH F1 LIKE Q... OR WITH F1 LIKE q..."
				Perform ExLine
				ReadList List Else List = ""
				Echo On
				GoSub DoList
				NewFileName = Option
		End Case
		Open NewFileName To TFL Then  
			GotFile = True
			FileName = NewFileName
		End
	Until GotFile Do
	Repeat
Return
*-----------------------------------------------------------------------
*  GetFreeBuf
*-----------------------------------------------------------------------
GetFreeBuf: 
	Found = False
	For I = 1 To MAXWINDOWS Until Found
		If Not(BufInfos(I)<BI.USED>) Then
			Found = I
		end
	Next
	If Not(Found) Then
		StatusMessage = "No Spare Buffers"
		Return
	End
	BufInfos(Found) = ""
	Return
*-----------------------------------------------------------------------
*   GetItem
*------------------------------------------------------------------------
GetItem: 
	PromptLine = "Item Name From '":FileName:"', * To List ->" ; GoSub PromptLine
	inputBox = ""
	GoSub InputBox
	ItemName = inputBox
	If ItemName = "*" Then
		PromptLine = "Selecting Items ..." ; GoSub PromptLine
		Echo Off
		Crt @(0,PY-3):
		ExLine = "SSELECT ":FileName
		Perform ExLine
		ReadList List Else List = 0
		Echo On
		GoSub DoList
		ItemName = Option
	End
	If ItemName = "" Then Redraw = REDRAW.ALL
	Return

*--------------------------------------------------------------------------
*  GetWord.in - 指定カーソル上の単語を取得する
*    [In] inX = X位置
*    [In] inY = Y位置
*  GetWord - 現在のカーソル位置を自動で設定
*--------------------------------------------------------------------------
GetWord:
	inY = Y
	inX = X
GetWord.in:
	Word = "" ;** [Out] 抽出した単語 見つからなかった場合は空
	SOW = ""  ;** [Out] 単語の開始位置
	EOW = ""  ;** [Out] 単語の終了位置
	
	Line = Rec<inY>
	ch = Line[inX,1]
	
	!! タイプチェック
	type = 0
	GoSub Is.Variable.Char ;** 英数字と変数に使える記号
	If flg Then type = 1 Else
		GoSub Is.Unicode.Char ;** UniCode単語
		If flg Then type = 2 Else
			GoSub Is.Mark.Char ;** 区切り記号
			If flg Then type = 3 Else
				GoSub Is.Space.Char ;** 非表示文字
				If flg Then type = 4 Else
					Return ;** 不明
				End
			End
		End
	End
	
	!! 開始位置 SOW を求める
	S = inX
	Loop
		S -= 1
		ch = Line[S,1]
	Until S <= 0
		On type GoSub Is.Variable.Char,Is.Unicode.Char,Is.Mark.Char,Is.Space.Char
	While flg
	Repeat
	SOW = S + 1
	
	!! 終了位置 EOW を求める
	S = inX
	Loop
		S += 1
		ch = Line[S,1]
	Until ch = ""
		On type GoSub Is.Variable.Char,Is.Unicode.Char,Is.Mark.Char,Is.Space.Char
	While flg
	Repeat
	EOW = SOW + S - SOW
	
	If type <> 4 Then
		Word = Line[SOW, EOW-SOW]
	End
	
	Return

Is.Variable.Char:
	flg = (ch Matches "1A":@VM:"1N" OR Count("._$%@",ch))
	Return
	
Is.Unicode.Char:
	flg = (UniSeq(ch) > 255)
	Return
	
Is.Mark.Char:
	flg = Count("=#:<>()[]{}/*+-,!;'\":'"', ch)
	Return
	
Is.Space.Char:
	flg = Count(Char(9):" ", ch)
	Return

*--------------------------------------------------------------------------------
*  Initialise
*--------------------------------------------------------------------------------
Initialise: 
	Return
*--------------------------------------------------------------------------
* InitTerminal(初回起動時に呼ばれる)
*--------------------------------------------------------------------------
InitTerminal: 

$IFNDEF U2__UNIVERSE
	If @TTY = 'console' Then
		x = PTERM(2,@FALSE)
		If System(1044) Then
			!! ECS Mode
			x = PTERM(7,1) ;** UTF8固定
		End
		EXECUTE "TERM msvt"
		Return
	End
$ENDIF

$IFDEF U2__UNIVERSE
	Ttyget ttys Then
		If ttys<1,1> = 3 Then; * EMULATE mode
			ttys<4,4> = 0; * NO Invert
			Ttyset ttys Else Null
		End
	End
	
	IF OS.GATES Then
		** WIN
		IF Len(@(IT$CUD))=0 Then
			Perform "SET.TERM.TYPE uviterm-w MAP UTF8" ;** 制御文字が送れる端末に変更する
		End
	End
	
$ELSE
	x = PTERM(2,@FALSE)
	If System(1044) Then
		!! ECS Mode
		x = PTERM(7,1) ;** UTF8固定
	End
	Execute "TERM xterm-eeepc"
	x = PTERM(8,8) ;** Backspace ^H
$ENDIF

	Return
*--------------------------------------------------------------------------
* InsMenu
*--------------------------------------------------------------------------
InsMenu: 
	MenuLine = "Comment Join OConv IConv Date Time Record :"
	GoSub MenuLine
	C = UpCase(C)
	Begin Case
		Case C = "J"
			GoSub Join
		Case C = "C"
			GoSub Act.InsCommentOut
		Case C = "O"
			GoSub DoOConv
		Case C = "I"
			GoSub DoIConv
		Case C = "D"
			InsBuffer = Date()
			GoSub InsertLines
		Case C = "T"
			InsBuffer = Time()
			GoSub InsertLines
		Case C = "R"
			GoSub DoInsert
		End Case
	Return
*--------------------------------------------------------------------------
* InsertLines
*--------------------------------------------------------------------------
InsertLines: 
	
	InsBuffer = Convert(@IM:@FM:@VM:@SM,CHAR(31):CHAR(10):CHAR(29):CHAR(28),InsBuffer)
	
	editCmd = ""
	
	If BufInfo<BI.BLOCKSTART> Then
		** 選択中
		editCmd<1> = BufInfo<BI.BLOCKEND, 1>
		editCmd<2> = BufInfo<BI.BLOCKEND, 2>
		editCmd<3> = BufInfo<BI.BLOCKSTART, 1>
		editCmd<4> = BufInfo<BI.BLOCKSTART, 2>
		editCmd<5> = InsBuffer
		editCmd<6> = ""
	End Else
		editCmd<1> = Y
		editCmd<2> = X
		If bOverlay Then
			editCmd<3> = Y
			editCmd<4> = X + (If X < Len(Rec<Y>) Then 1 Else 0)
		End Else
			editCmd<3> = ""
			editCmd<4> = ""
		End
		editCmd<5> = InsBuffer
		editCmd<6> = ""
	End
	
	GoSub StackEditCmd
	 
Return
*--------------------------------------------------------------------------
* JoinLines
*--------------------------------------------------------------------------
Join:   
	
	GoSub GET.SELECTION.STRING
	
	If selString = "" Then Return
	
	PromptLine = "Join Word ->" ; GoSub PromptLine
	inputBox = ""
	GoSub InputBox
	joinChars = inputBox
	
	joinChars = Convert(@FM,CHAR(10),joinChars)
	
	InsBuffer = Change(selString,CHAR(10),joinChars)
	
	GoSub InsertLines
	
Return

*--------------------------------------------------------------------------
* ParseLine
*   Line [in]
*   Row [in]
*   PLine [out]
*--------------------------------------------------------------------------
ParseLine:
	HI.OFF = SGR.ALL.OFF ;** デフォルトのBG Coler

ParseLine.Impl:
	
	** 選択領域がある
	selection = ""
	If BufInfo<BI.BLOCKSTART> Then
		GoSub GetSelBlock
		If blockStart<1> = Row Then
			If blockEnd<1> = Row Then
				** １行内での選択範囲
				If blockStart<2> > blockEnd<2> Then
					tmp = blockStart; blockStart = blockEnd; blockEnd = tmp
				End
				selection = blockStart<2>:@FM:blockEnd<2>
			End Else
				** 開始行が一致
				selection = blockStart<2>:@FM:BIG
			End
		End Else If blockEnd<1> = Row Then
			** 終端行が一致
			selection = 1:@FM:blockEnd<2>
		End Else If blockStart<1> < Row And blockEnd<1> > Row Then
			** 選択領域の真ん中なので開始から終了まで
			selection = 1:@FM:BIG
		End
	End
	
	LineWidth = Width ;** 行幅はウィンドウサイズ
	Selection.Color = HI.SELECT.ON
	Selection.Key.Color = SBOLD:FG.BASE3
	Selection.Tab.Color = FG.BASE01

ParseLine2: * (Outline用、呼び出す前に必ず selection に値を入れること)

	L = Len(Line)
	OldLine = Line
	Line = TrimF(Convert(Char(9),Space(STDTAB),Line))
	Mask = Space(L - Len(Line))
	
	ParseType = BufInfo<BI.PARSETYPE>
	Begin Case
		** --------------------
		** Basic
		** --------------------
		Case ParseType = PARSE.BASIC
			Word = Line[";",1,1][" ",1,1]["*",1,1]["!",1,1]
			If Word Matches "1N0N":@VM:"1A0X:" Then
				!! Label
				If INMAT() = 2 Then
					A = Convert("0123456789._","",Word[2,9999]) Matches "0A:"
				End Else A = @TRUE
				If A Then
					len = Len(Word)
					Mask := Str(SI.LABEL,len)
					Line = Line[len+1,BIG]
					L = Len(Line)
					Line = TrimF(Convert(Char(9),Space(STDTAB),Line))
					Word = Line[";",1,1][" ",1,1]["*",1,1]["!",1,1]
				End
			End
			Begin Case   
				!! Comment & Directive
				Case Count("*!",Word[1,1])
					Mask := Str(SI.COMMENT, L)
				Case Count("$#",Word[1,1])
					Mask = Str(SI.DIRECTIVE, L)
				Case 1
					Dc = Count(Line,";")
					If Not(Dc) Then
						Mask := Space(L)
					End Else
						FoundComment = False
						For Z = 1 To Dc Until FoundComment
							Word = TrimF(Line[";",Z+1,1])
							If Count("*!",Word[1,1]) Then
								FoundComment = Z
							End
						Next
						If FoundComment Then
							Mask := Space(Len(Line[";",1, FoundComment])):Str(SI.COMMENT, L)
						End Else
							Mask := Space(L)
						End
					End
			End Case
			
			!! Word
			Lin = Convert(PUNCS,Str(@fm,Len(PUNCS)), UpCase(OldLine))
			Dc3 = Dcount(Lin,@fm)
			For Q = 1 To Dc3
				Word = Lin[@fm,Q,1]
				St = Col1()+ 1
				If St > 1 Then
					If Mask[St-1,1] = " " And OldLine[St-1,1] <> " " Then
						Mask[St-1,1] = SI.OPERATOR ;* operators too
					End
				End
				Begin Case
					Case Word[1,1] = ''
					Case Index(STRQTS,Word[1,1],1)
						Ix = Index(Lin[St+1,HUGE],Word[1,1],1)
						If Ix Then
							If Mask[St,1] = " " Then
								Q = DCount(Lin[1, Ix+St],@fm)
								Mask[St, Ix+1] = Str(SI.STRING, Ix+1)
							End
						End
					Case Word Matches "1N0N"
						If Mask[St,1] = " " Then
							If OldLine[St-1,1]="-" And Lin[@fm,Q-1,1]="" Then
								A = OldLine[St-2,1]
								If A#")" And A#">" Then
									Mask[St-1,1] = SI.NUMBER ;** 負のリテラル
								End
							End
							Mask[St, Len(Word)] = Str(SI.NUMBER, Len(Word))
						End
					Case 1
						Locate Word In KEYWORDS By "AL" Setting Pos Then
							If Mask[St,1] = " " AND OldLine[St+Len(Word),1]#"(" Then
								Mask[St, Len(Word)] = Str(SI.KEY, Len(Word))
							End
						End Else
							Locate Word In FUNCS by "AL" Setting Pos Then
								If Mask[St,1] = " " Then
									Mask[St,Len(Word)] = Str(SI.FUNCTION, Len(Word))
								End
							End
						End
				End Case
			Next
		** --------------------
		** Paragraph
		** --------------------
		Case ParseType = PARSE.PARA
			
			!! 全行系
			OLine = Line
			Line.len = Len(Line)
			C2 = Line[1,2]
			If C2 = "PA" And Row=1 Then
				Mask := Str(SI.COMMENT,Line.len)
			End Else If C2 = "* " Then
				Mask := Str(SI.COMMENT,Line.len)
			End Else
				!! 普通のコマンド文
				
				!! ラベル
				Word = Line[" ",1,1]
				If Word Matches "1N0N" Or Word Matches "1A0X':'" Then
					Mask := Str(SI.LABEL,Len(Word)):" "
					Line = Line[" ",2,BIG]
					Word = Line[" ",1,1]
				End
				
				!! 制御構文
				If Word = "IF" Then
					idx = Index(Line,"THEN",1)
					If idx Then
						Mask := Str(SI.KEY,2)
						Mask := Space(idx-3)
						Mask := Str(SI.KEY,4):" "
						Line = Line[idx+5,BIG]
						Word = Line[" ",1,1]
					End
				End Else If Word = "LOOP" Then
					Mask := Str(SI.KEY,4)
					Line = ""
					Word = ""
				End Else If Word = "REPEAT" Then
					Mask := Str(SI.KEY,6)
					Line = ""
					Word = ""
				End Else If Word = "$ECHO" Then
					Mask := Str(SI.DIRECTIVE,BIG)
					Line = ""
					Word = ""
				End
				
				!! 補助構文
				If Word = "GO" Then
					!! ラベルを強調
					Mask := Str(SI.KEY,3)
					Mask := Str(SI.LABEL,Line.len)
				End Else
					Mask := Space(Line.len)
				End
				
				!! インラインプロンプト強調
				offset = 0
				Line = OLine
				Loop
					idx = Index(Line,"<<",1)
					If idx Then
						idx2 = Index(Line[idx,BIG],">>",1)
						If idx2 Then
							Mask[offset + idx,idx2+1] = Str(SI.DOC,idx2+1)
							offset += idx+idx2-1
							Line = Line[idx+idx2,BIG]
						End Else
							Exit
						End
					End Else
						Exit
					End
				Repeat
				
			End
		
		** --------------------
		** Data
		** --------------------
		Case ParseType = PARSE.DATA Or ParseType = PARSE.RAW
			len = Len(Line)
			For i = 1 To len
				ch = Line[i,1]
				Begin Case
					Case ch = @VM
						Mask := SI.VMK
					Case ch = @SM
						Mask := SI.SMK
					Case 1
						Mask := " "
				End Case
			Next
			
		Case ParseType = PARSE.PDUMP
			Mask = Space(Len(OldLine))
			i1 = Index(OldLine,'"')
			If i1 Then
				i2 = Index(OldLine[i1,BIG],'"')
				If i2 Then
					NewLine = ""
					For i = i1+1 To L
						ch = OldLine[i,1]
						IF ch = "\" THEN
							i+=1
							IF OldLine[i,1] # "\" Then
								A = OldLine[i,4]
								B = XTD(A)
								If A#B Then
									ch = ECHAR(B)
									i += 3
								End Else
									A = OldLine[i,2]
									B = XTD(A)
									If A#B Then
										ch = CHAR(B)
										i += 1
									End
								End
							End
						END
						NewLine := ch
					Next
					!Mask[i1,Len(NewLine)+1] = Str(SI.STRING,Len(NewLine)+1)
					Line = OldLine[1,i1]:NewLine
					OldLine = Line
				End
			End

		Case 1
			Mask = Space(Len(OldLine))
	End Case
			
	** 検索ハイライト
	Word = BufInfo<BI.HIWORD>
	If Word >< "" Then
		Oc = 1
		Loop
			If ignoreCase Then
				Ix = Index(UpCase(OldLine),UpCase(Word),Oc)
				If Ix Then
					Mask[Ix, Len(Word)] = Str(SI.SEARCH, Len(Word))
				End
			End Else
				Ix = Index(OldLine,Word,Oc)
				If Ix Then
					If Ix=1 Or Convert(PUNCS:".":@fm:@vm:@svm,"",OldLine[Ix-1,1])="" Then
						Mask[Ix, Len(Word)] = Str(SI.SEARCH, Len(Word))
					End
				End
			End
		While Ix Do
			Oc += 1
		Repeat
	End
	
	** カーソル行の場合に処理
	If Row = Y Then
		** 対応する括弧の表示
		kakko1 = "" ;** 開き括弧情報(必ず1回は初期化される)
		kakko2 = "" ;** 閉じ括弧情報(必ず1回は初期化される)
		stCh = OldLine[X,1] ;** 現在カーソル文字の再取得
		!! 開き括弧調査
		If stCh >< "" Then
			ki = Index(KAKKO.CHAR.LIST1,stCh,1) 
			If ki Then
				If ki < 5 Or (ki >= 5 And Rem(Count(OldLine[1,X],stCh),2)=1) Then
					iX = X
					moveDir = 1
					enCh = KAKKO.CHAR.LIST2[ki,1]
					GoSub Get.kakko
					kakko1 = kakko
				End
			End
		End
		stCh = OldLine[X-1,1] ;** 現在カーソル文字の再取得
		If stCh >< "" Then
		!! 閉じ括弧調査
			ki = Index(KAKKO.CHAR.LIST2,stCh,1) 
			If ki Then
				If ki < 5 Or (ki >= 5 And Rem(Count(OldLine[1,X],stCh),2)=0) Then
					iX = X-1
					moveDir = -1
					enCh = KAKKO.CHAR.LIST1[ki,1]
					GoSub Get.kakko
					kakko2 = kakko
				End
			End
		End
	End
	
	!! XOffset位置ずらし
	Line = ""
	tmpMask = ""
	iXOffSet = 1 ;** 内部Xオフセット
	rX = 1 ;** 表示X
	iX = 1 ;** 内部X
	Loop
		char = OldLine[iX,1]
		If char = "" Then
			If CurBuf < MAXWINDOWS And Row <> Lines Then
				Line := Char(10)
			End
			Exit
		End
		If XOffSet = rX Then
			iXOffSet = iX ;** Xオフセットの表示位置を保存
		End
		rX += If char = Char(9) Then STDTAB Else LenDP(char)
		If rX >= XOffSet + 1 Then
			Line := char
			tmpMask := Mask[iX,1]
		End
	While rX <= (XOffSet + LineWidth - 2)
		iX += 1
	Repeat
	Mask = tmpMask
	
	If selection And selection<1> < iXOffSet Then
		selection<1> = iXOffSet
	End

	PLine = ""
	Old = ""
	IX = 0
	L = Len(Line)
	For K = 1 to L
		
		!! 選択範囲
		If K = 1 Or K = selection<2> - iXOffSet + 1 Then
			!! 選択終了
			HI.Default = HI.OFF
			HI.Search = HI.SEARCH.ON
			PLine := BG.DEFAULT
			!! 行全体のハイライト
			If Mask[1,1] = SI.DIRECTIVE Then
				HI.Light = FG.BASE3
				HI.Key = SBOLD:FG.BASE3
				PLine := HI.DIR.ON
			End Else
				HI.Light = FG.BASE1
				HI.Key = HI.KEY.ON
			End
			Old = ""
			in.selection = @False
		End
		If K = selection<1> - iXOffSet + 1 And selection<1> <> selection<2> Then
			!! 選択開始
			HI.Default = Selection.Color
			HI.Key = Selection.Key.Color
			HI.Light = FG.BASE00
			HI.Search = HI.SEARCH.SEL
			PLine := HI.Default
			Old = ""
			in.selection = @True
		End
		
		cc = Line[K,1]
		ch = Mask[K,1]
		If cc = Char(9) Then
			!! 文字の描画(タブの場合は表示形式に置換)
			If ch=SI.DIRECTIVE Then
				PLine := FG.BASE3
			End Else
				If (K=1 Or Old#Char(9)) Then
					PLine := If in.selection Then Selection.Tab.Color Else FG.BASE2
				End
			End
			A = STDTAB-1-REM(IX,STDTAB)
			PLine := TAB.DISP:Space(A)
			IX += 1+A
			Old = Char(9)
		End Else If cc = Char(10) Then
			!! 改行の表示
			PLine := If in.selection Then HI.Light Else HI.OFF:FG.BASE2
			PLine := NEWLINE.DISP
		End Else
			!! Maskによる色付け
			If ch <> Old Then
				Begin Case
					Case Old = SI.KAKKO
						PLine := HI.KAKKO.OFF
					Case Old = SI.LABEL
						PLine := HI.LABEL.OFF
					Case Old = SI.COMMENT
						PLine := HI.COMMENT.OFF
					Case Old = SI.KEY
						PLine := HI.KEY.OFF
					Case Old = SI.STRING
						PLine := HI.STRING.OFF
					Case Old = SI.NUMBER
						PLine := HI.NUMBER.OFF
					Case Old = SI.OPERATOR
						PLine := HI.OP.OFF
					Case Old = SI.SEARCH
						PLine := HI.SEARCH.OFF
					Case Old = SI.VMK
						PLine := HI.VMK.OFF
					Case Old = SI.SMK
						PLine := HI.SMK.OFF
				End Case
				PLine := HI.Default
				Begin Case
					Case ch = SI.KAKKO And HI.Default = HI.OFF
						PLine := HI.KAKKO.ON
					Case ch = SI.LABEL
						PLine := HI.LABEL.ON
					Case ch = SI.COMMENT
						PLine := HI.COMMENT.ON
					Case ch = SI.KEY
						PLine := HI.Key
					Case ch = SI.STRING
						PLine := HI.STRING.ON
					Case ch = SI.NUMBER
						PLine := HI.NUMBER.ON
					case ch = SI.OPERATOR
						PLine := HI.OP.ON
					Case ch = SI.FUNCTION
						PLine := HI.FUNC.ON
					Case ch = SI.SEARCH
						PLine := HI.Search
					Case ch = SI.DOC
						PLine := HI.DOC.ON
					Case ch = SI.VMK
						PLine := HI.VMK.ON
					Case ch = SI.SMK
						PLine := HI.SMK.ON
					Case ch = SI.DIRECTIVE
						If Not(in.selection) Then PLine := HI.DIR.ON
				End case
				Old = Mask[K,1]
			End
			PLine := cc
			IX += LenDP(cc)
		End
	Next
	PLine := HI.OFF
Return

* Get.kakko
*   IN:  kakko,OldLine,iX,Mask,stCh,enCh,ki
*   OUT: kakko
Get.kakko:
	
	kakko = ""
	If ki >= 5 Then
		!! 文字リテラルは方向が個数で決まる
		moveDir = If Rem(Count(OldLine[1,iX],stCh),2) Then 1 Else -1
	End
	sign = SI.KAKKO
	
	!! 終了置を探す
	nestCnt = 0
	enPos = iX
	exitPos = If moveDir = 1 Then Len(OldLine) Else 1
	For enPos = iX + moveDir To exitPos Step moveDir
		ch = OldLine[enPos,1]
		If Mask[enPos,1] = SI.STRING And ch="\" Then Continue ;** 文字リテラル中のバックスラッシュは強調しない
		If ch = enCh Then
			If nestCnt > 0 Then
				nestCnt -= 1 ;** ネストを減らす
			End Else
				Mask[iX,1] = sign
				Mask[enPos,1] = sign
				kakko<1,1> = iX
				kakko<2,1> = enPos
				Exit
			End
		End Else If ch = stCh Then
			nestCnt += 1 ;** ネストを増やす
		End
	Next
	Return

*--------------------------------------------------------------------------
* GetSelBlock:選択領域取得
* OUT : blockStart
*       blockEnd
*--------------------------------------------------------------------------
GetSelBlock:
	blockStart = Raise(BufInfo<BI.BLOCKSTART>)
	blockEnd = Raise(BufInfo<BI.BLOCKEND>)
	!! 選択開始 -> 終了 順にSWAP  
	If blockStart<1> * 100000 + blockStart<2> > blockEnd<1> * 100000 + blockEnd<2> Then
		tmp = blockStart; blockStart = blockEnd; blockEnd = tmp
	End
	Return
	
*--------------------------------------------------------------------------
* PrintPage
*--------------------------------------------------------------------------
PrintPage:
	GoSub PrintTextArea
	Redraw.StatusLine = @TRUE
	GoSub PrintStatus
	Return

*--------------------------------------------------------------------------
* PrintTextArea
*--------------------------------------------------------------------------
PrintTextArea:
	For I = 1 To Depth
		Row = Top + I - 1
		If Row > Lines Then crtBuff := @(-3); Exit
		Line = Rec<Row>
		GoSub ParseLine
		GoSub PrintLine
	Next
	Return

*--------------------------------------------------------------------------
* PrintLine
*--------------------------------------------------------------------------
PrintLine:
	crtBuff := @(0,Row - Top) ;* 行の開始
	!! 行情報部の色指定
	If Row = Y Then
		!! 現在行
		crtBuff := FG.YELLOW:BG.BASE2
	End Else
		crtBuff := FG.BASE1:BG.BASE2
	End
	If BufInfo<BI.FIELDFIX> Then
		!! フィールド指定モード
		inY = Row
		GoSub GetDAPos
		bShowUnderline = fldCnt > 1 And fIdx = fldCnt
		If bShowUnderline Then
			!! 複数フィールドの最終行に下線を入れる
			crtBuff := SUL
		End
		If BufInfo<BI.VALUEFIX> Then
			str = "<":fPos:",":BufInfo<BI.VALUEFIX>:",":vPos:"> "
			crtBuff := str "11L"
			biInfoWide.lineNo = 11
		End Else
			str = "<":fPos:",":vPos:"> "
			crtBuff := str "8L"
			biInfoWide.lineNo = 8
		End
		If TgtFld Then
			!! 辞書表示
			crtBuff := FMTDP(TgtFld<fIdx,2>,biInfoWide.dict<1,1,1>:"L")
			crtBuff := FMTDP(TgtFld<fIdx,4>,biInfoWide.dict<1,1,2>:"L")
			If Row=Y And prevY#Y Then
				!! 現在行の場合はステータス表示
				StatusMessage  = FMT(TgtFld<fIdx,3>,"14L"):" | "
				StatusMessage := FMT(TgtFld<fIdx,5>,"10L"):" | "
				StatusMessage := FMT(TgtFld<fIdx,8>,"20L"):" | "
				If TgtFld<fIdx,6>="M" Then
					StatusMessage := "Multi"
					a = TgtFld<fIdx,7>
					If a Then
						StatusMessage := " assoc ":SQuote(a)
					End
				End Else IF TgtFld<fIdx,6>="S" Then
					StatusMessage := "Single"
				End
			End
		End
		If bShowUnderline Then
			!! 下線を消す
			crtBuff := EUL
		End
		
	End Else
		biInfoWide.lineNo = 5
		GoSub Get.Gyo
		crtBuff := Gyo
		If TgtFld Then
			!! 辞書表示
			crtBuff := FMTDP(TgtFld<Row,2>,biInfoWide.dict<1,1,1>:"L")
			crtBuff := FMTDP(TgtFld<Row,4>,biInfoWide.dict<1,1,2>:"L")
			If Row=Y And (prevY#Y Or prevX#X) Then
				!! 現在行の場合はステータス表示
				StatusMessage  = FMT(TgtFld<Row,3>,"14L"):" | "
				StatusMessage := FMT(TgtFld<Row,5>,"10L"):" | "
				StatusMessage := FMT(TgtFld<Row,8>,"20L"):" | "
				If TgtFld<Row,6>="M" Then
					StatusMessage := "Multi <F4> dive"
					a = TgtFld<Row,7>
					If a Then
						StatusMessage := " with assoc ":SQuote(a)
					End
				End Else IF TgtFld<Row,6>="S" Then
					StatusMessage := "Single"
				End
			End
		End
	End
	crtBuff := HI.OFF ;* 行情報部の色指定解除
	!! TABの可視化
	crtBuff := PLine:@(-4) ;** 内容の描画
	Return

*--------------------------------------------------------------------------
* ダイナミックアレイでの位置を返す
*--------------------------------------------------------------------------
GetDAPos:
	fldCnt = Dcount(TgtFld,@FM)
	fIdx = Mod((inY-1),fldCnt)+1
	fPos = TgtFld<fIdx,1>
	vPos = Int((inY-1)/fldCnt)+1
	Return

Get.FileSentence:
	fileSentence = ""
	If info<BI.CHANGED> Then fileSentence := "*"
	If info<BI.PATHNAME> >< "" And UpCase(info<BI.FILE>[1,5])="PATH:" Then
		fileSentence := info<BI.PATHNAME>
	End Else If info<BI.FILE> <> "" Then
		fileSentence := info<BI.FILE>
		fileSentence := " ":info<BI.ITEM>
	End Else If info<BI.CAPTURE> <> "" Then
		fileSentence := "[":info<BI.CAPTURE>:"]"
	End Else
		fileSentence := "(Untitled)" 
	End
	If info<BI.PBUFNO> Then fileSentence := " [pno=":info<BI.PBUFNO>:"]"
	If info<BI.FIELDFIX> Then fileSentence := " {":info<BI.FIELDFIX>:"}"
	If info<BI.VALUEFIX> Then fileSentence := ",V":info<BI.VALUEFIX>
	If info<BI.ACCOUNT> >< @PATH and info<BI.ACCOUNT> >< @WHO Then fileSentence := " <":info<BI.ACCOUNT>:">"
	If info<BI.NEW> Then fileSentence := "(New)"
	Return

*--------------------------------------------------------------------------
* PrintStatus
*--------------------------------------------------------------------------
PrintStatus:
	StLine.Y = PY
PrintStatus.Impl:
	
	crtBuff := HI.STATUS.ON
	
	If Redraw.StatusLine Then
		info = BufInfo
		GoSub Get.FileSentence
		
		!! 左詰
		crtBuff := @(0, StLine.Y)
		crtBuff := " ":CurBuf:"< "
		crtBuff := fileSentence:@(-4)
		
		!! 右詰
		SLine = ""
		If BufInfo<BI.LOCKED> Then SLine := " | Locked"
		If ReadOnly Then SLine := " | R/Only"
		SLine := " | ":BufInfo<BI.PARSETYPE>:" ":IndentType:":":STDTAB:" "
		
		crtBuff := @(@CRTWIDE-17-Len(SLine),StLine.Y)
		crtBuff := SLine:"| "
		
		Redraw.StatusLine = @FALSE
	End

	crtBuff := @(@CRTWIDE-15,StLine.Y)
	
	!! 文字コード情報
	cd = UniSeq(Rec<Y>[X,1])
	If cd = 0 Then cd = 10 ;** 改行コードにする
	hex = OConv(cd,'MX')
	crtBuff := (hex (If cd < 255 Then "R  %%" Else "R%%%%")):" | "
	
	!! カーソル情報
	curInfo = ""
	If BufInfo<BI.FIELDFIX> Then
		!! フィールド固定モード
		inY = Y
		GoSub GetDAPos
		curInfo = "<":fPos
		If BufInfo<BI.VALUEFIX> Then
			curInfo := ",":BufInfo<BI.VALUEFIX>
		End
		curInfo := ",":vPos:">.":DP_X
	End Else
		curInfo := Y:".":DP_X
	End
	crtBuff := curInfo "L#8"
	crtBuff := HI.STATUS.OFF
	
	!! ステータスメッセージ
	If StatusMessage >< "" Then
		crtBuff := @(0, StLine.Y+1):BG.CYAN:FG.BASE3:" ":StatusMessage:" ":SGR.ALL.OFF:@(-4)
		StatusMessage = ""
	End Else
		crtBuff := @(0, StLine.Y+1):BG.BASE2:@(-4)
	End
	Return

*-----------------------------------------------------------------------
*  PrintCursor
*-----------------------------------------------------------------------
PrintCursor:
!! 	crtBuff := @(biInfoWide + DP_X - XOffSet, Y - Top):CSI:"?12l":CSI:"?25h"
	A = Y - Top
	If A >= 0 And A < Depth Then
		crtBuff := @(biInfoWide + DP_X - XOffSet, A):CSI:"?25h"
	End
	Return

*-----------------------------------------------------------------------
*  MenuLine
*-----------------------------------------------------------------------
MenuLine:
	crtBuff = BG.BASE0:FG.BASE2
	f = @TRUE
	For i=1 To HUGE
		ch = MenuLine[i,1]
		If ch = '' Then Exit
		If f Then
			If ch = 'E' And MenuLine[i,3] = "ESC" Then
				crtBuff := BG.BASE00:FG.BASE3:"ESC":BG.BASE0:FG.BASE2
				f = @FALSE
				i += 2
			End Else If ((ch >= 'A' And ch <= 'Z') or ch = '!') Then
				crtBuff := BG.BASE00:FG.BASE3:ch:BG.BASE0:FG.BASE2
				f = @FALSE
			End Else 
				crtBuff := ch
			End
		End Else
			If ch = ' ' Then f = @TRUE
			crtBuff := ch
		End
	Next
	Crt @(0,PY):crtBuff:SGR.ALL.OFF:@(-4):
	GoSub GetKey
	Redraw.StatusLine = @TRUE
	GoSub PrintStatus
	Crt crtBuff:
	Return
*-----------------------------------------------------------------------
*  PromptLine
*-----------------------------------------------------------------------
PromptLine: 
	Crt @(0,PY+1):BG.BASE3:" ":PromptLine:SGR.ALL.OFF:@(-4):
	Redraw.StatusLine = @TRUE
	Return
*-----------------------------------------------------------------------
*  SaveAs
*-----------------------------------------------------------------------
SaveAs: 
	Redraw.StatusLine = @TRUE
	
	If BufInfo<BI.PBUFNO> Then
		StatusMessage = "Save Target is determined by parent buffer"  
		Return
	End
	
	cmdline = "WRITE.BUFFER ":CurBuf:" TO ":BufInfo<BI.FILE>:" ":BufInfo<BI.ITEM>
	bAutoCommand = @TRUE
	bAutoEditor = @true
	GoSub Act.Exit
	
	Return
*--------------------------------------------------------------------------
* SaveItem
*--------------------------------------------------------------------------
SaveItem:

	Redraw.StatusLine = @TRUE
	
	If IsNew Then
		GoSub SaveAs 
	End
	
	If ReadOnly Then
		StatusMessage = "File is marked as Read Only - Cannot save"  
		Return
	End
	
	!! ファイル保存
	If Changed Then
		If BufInfo<BI.FILE> Match "'#'1N":@VM:"'#'10" Then
			!! 選択リストの保存
			cmdline = "WRITE.BUFFER ":CurBuf:" TO ":BufInfo<BI.FILE>
			bAutoCommand = @TRUE
			GoSub Act.Exit ;** 保存でコマンドに戻る
		End Else
			cmdline = "WRITE.BUFFER ":CurBuf:" TO ":BufInfo<BI.FILE>:" ":BufInfo<BI.ITEM>
			GoSub WRITE.BUFFER.impl
		End
	End
	
	Return
*--------------------------------------------------------------------------
* Delete
*--------------------------------------------------------------------------
Delete: 
	
	FileName = BufInfo<BI.FILE>
	If FileName Match "'#'1N":@VM:"'#'10" Then Return
	
	ItemName = BufInfo<BI.ITEM>
	If FileName = "" Then Return
	If ItemName = "" Then Return

	PromptLine = "Are you sure you wish to DELETE this item (Y/N) :"
	GoSub PromptLine
	GoSub GetKey
	
	If UpCase(C) = "Y" Else Return

	GoSub Common.OpenFile
	Crt @(0, PY):
	IF FILEINFO(FL,3)=4 THEN
		IN.OSBS = ItemName
		GOSUB GET.OSBS
	END ELSE
		OUT.OSBS = ItemName
	END
	ReadU prevRec From FL,OUT.OSBS On Error Return Locked
		StatusMessage = "Record previously Locked by ":Status():", Cannot Save"
		GoSub Common.CloseFile
		Return
	End Then
		Convert CHAR(10):CHAR(13) To '' In Rec ;** 改行コードが残っていたら自動除外
	End Else
		prevRec = ""
	End
	
	If prevRec >< StartRec Then
		StatusMessage = "Record previously Changed by Another, Cannot Save This Modify"
		GoSub Common.CloseFile
		Return
	End
	Delete FL,OUT.OSBS
	
	GoSub Common.CloseFile
	
	StatusMessage = "Deleted ":FileName:" ":ItemName
	GoSub Act.CloseBuff
	Return

*--------------------------------------------------------------------------
* SearchMenu
*--------------------------------------------------------------------------
SearchMenu: 
	MenuLine = "Find Again reVerse Replace | goLineno goDeclaration Outline :" ; GoSub MenuLine
	Ok = Upcase(C)
	Begin Case
		Case Ok = "F"
			Replacing = False
			SearchString=""
			GoSub Act.Search
		Case Ok = "A"
			searchReverse = False
			GoSub Act.Search
		Case Ok = "V"
			searchReverse = True
			GoSub Act.Search
		Case Ok = "R"
			Replacing = True
			GoSub Act.Search
		Case Ok = "L"
			GoSub Act.GoLine
		Case Ok = "D"
			GoSub Act.GoDeclaration
		Case Ok = "O"
			GoSub Act.ShowOutline
		End Case
	Return
	
* -----------------------------------------------------------------------
*  Setup Default Key Bindings

SetupDefKeyBindings:
	GoSub LoadKeyBindings
	Return

* -----------------------------------------------------------------------
* LoadKeyBindings

LoadKeyBindings:
	
	keys = ''
	keysToAction = ''
	err = @false
	
	!! 空白 -> @VM
	list = Convert(' ',@VM,TrimS(keySeq))
	
	action = 1
	Loop
		Remove z From list Setting delim
		
		n = Len(z)
		If n Then
			
			!! エスケープ戻す
			For i = 1 To n
				If z = '@@' Then
					z = IF @TTY = 'console' THEN CHAR(27):CHAR(32) ELSE CHAR(0)
				End Else If z[i,1] = '@' Then
					j = index('ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_',z[i+1,1],1)
					If j Then
						z = z[1,i-1] : char(j) : z[i+2,999]
						n -= 1
					End Else If z[i,2] = '@@' Then 
						z = z[1,i] : z[i+2,999]
					End
				End
			Next
			
			!! シーケンス解析
			n = seq(z[1,1])
			If n > 31 And n < 127 Then
			   Display "Key binding for action ":action:" does not start with a control character"
			   err = @TRUE
			End Else
				Locate z In keys By 'AL' Setting i Then
					Display "Duplicate key bindings. Actions ":keysToAction<i>:" and ":action
					err = @true
				End Else
					Ins z Before keys<i>
					Ins action Before keysToAction<i>
				End
			End
		End
	While delim
		If delim = 2 Then action += 1
	While action <= ACTION.ENUM.LAST
	Repeat
	
	Return

*-----------------------------------------------------------------------
*  SetupTokens
*-----------------------------------------------------------------------
SetupTokens: 
	KEYWORDS = ""
	AddKeyWord "ABORT"
	AddKeyWord "ABORTS"
	AddKeyWord "AND"
	AddKeyWord "BEFORE"
	AddKeyWord "BEGIN"
	AddKeyWord "BY"
	AddKeyWord "CALL"
	AddKeyWord "CAPTURING"
	AddKeyWord "CASE"
	AddKeyWord "CATCH"
	AddKeyWord "CLASS"
	AddKeyWord "CLEAR"
	AddKeyWord "CLEARFILE"
	AddKeyWord "CLEARSELECT"
	AddKeyWord "CLOSE"
	AddKeyWord "CLOSESEQ"
	AddKeyWord "COMMIT"
	AddKeyWord "COMMON"
	AddKeyWord "CONTINUE"
	AddKeyWord "CONVERT"
	AddKeyWord "CREATE"
	AddKeyWord "CREATING"
	AddKeyWord "CREATING.SEQKEY"
	AddKeyWord "CRT"
	AddKeyWord "DEFFUN"
	AddKeyWord "DEL"
	AddKeyWord "DELETE"
	AddKeyWord "DELETELIST"
	AddKeyWord "DELETEU"
	AddKeyWord "DELIMITER"
	AddKeyWord "DIM"
	AddKeyWord "DISPLAY"
	AddKeyWord "DO"
	AddKeyWord "EACH"
	AddKeyWord "ELSE"
	AddKeyWord "ENCODING"
	AddKeyWord "END"
	AddKeyWord "ENTER"
	AddKeyWord "EQU"
	AddKeyWord "EQUATE"
	AddKeyWord "ERROR"
	AddKeyWord "EVAL"
	AddKeyWord "EVALUATE"
	AddKeyWord "EXECUTE"
	AddKeyWord "EXIT"
	AddKeyWord "FIND"
	AddKeyWord "FINDSTR"
	AddKeyWord "FOR"
	AddKeyWord "FORMLIST"
	AddKeyWord "FROM"
	AddKeyWord "FUNCTION"
	AddKeyWord "GETLIST"
	AddKeyWord "GETLISTV"
	AddKeyWord "GOSUB"
	AddKeyWord "GOTO"
	AddKeyWord "IF"
	AddKeyWord "IN"
	AddKeyWord "INPUT"
	AddKeyWord "INS"
	AddKeyWord "LIKE"
	AddKeyWord "LOCAL"
	AddKeyWord "LOCATE"
	AddKeyWord "LOCKED"
	AddKeyWord "LOOP"
	AddKeyWord "MAT"
	AddKeyWord "MATBUILD"
	AddKeyWord "MATCH"
	AddKeyWord "MATCHES"
	AddKeyWord "MATPARSE"
	AddKeyWord "NEXT"
	AddKeyWord "NO.TTY"
	AddKeyWord "ON"
	AddKeyWord "OPEN"
	AddKeyWord "OPENDEV"
	AddKeyWord "OPENPATH"
	AddKeyWord "OPENSEQ"
	AddKeyWord "OR"
	AddKeyWord "PASSLIST"
	AddKeyWord "PERFORM"
	AddKeyWord "PRINT"
	AddKeyWord "PRINTER"
	AddKeyWord "PRIVATE"
	AddKeyWord "PROGRAM"
	AddKeyWord "PUBLIC"
	AddKeyWord "READ"
	AddKeyWord "READBLK"
	AddKeyWord "READLIST"
	AddKeyWord "READL"
	AddKeyWord "READNEXT"
	AddKeyWord "READONLY"
	AddKeyWord "READSEQ"
	AddKeyWord "READU"
	AddKeyWord "READV"
	AddKeyWord "READVU"
	AddKeyWord "RECORDLOCKL"
	AddKeyWord "RECORDLOCKU"
	AddKeyWord "RELEASE"
	AddKeyWord "REPEAT"
	AddKeyWord "RESTRICTED"
	AddKeyWord "RETURN"
	AddKeyWord "ROLLBACK"
	AddKeyWord "RTNLIST"
	AddKeyWord "SELECT"
	AddKeyWord "SELECTV"
	AddKeyWord "SETTING"
	AddKeyWord "SHARED"
	AddKeyWord "SILENT"
	AddKeyWord "SSELECT"
	AddKeyWord "STATUS"
	AddKeyWord "STEP"
	AddKeyWord "STOP"
	AddKeyWord "SUBROUTINE"
	AddKeyWord "THEN"
	AddKeyWord "THROW"
	AddKeyWord "TO"
	AddKeyWord "TRANSACTION"
	AddKeyWord "TRAPPING"
	AddKeyWord "TRY"
	AddKeyWord "UNTIL"
	AddKeyWord "USING"
	AddKeyWord "VAR.ARGS"
	AddKeyWord "VOID"
	AddKeyWord "WEOFSEQ"
	AddKeyWord "WHILE"
	AddKeyWord "WRITE"
	AddKeyWord "WRITEBLK"
	AddKeyWord "WRITELIST"
	AddKeyWord "WRITESEQ"
	AddKeyWord "WRITESEQF"
	AddKeyWord "WRITEU"
	AddKeyWord "WRITEV"
	AddKeyWord "WRITEVU"
	FUNCS = ""

	PUNCS = ", []()<>{}~=+-/*:;^#!":Char(9)
	STRQTS = "'\":'"'
	Return
*-----------------------------------------------------------------------
*  ShowText
*-----------------------------------------------------------------------
ShowText: 
	LTop = 0
	LRefresh = True
	LFin = False
	Loop
		If LRefresh Then
			Crt @(0,0):@(-3):
			For TextLine = 1 To LISTDEPTH
				Crt @(0,TextLine):Text<TextLine + LTop>[1, Width]
			Next TextLine
			LRefresh = False
		End
		MenuLine = "Up Down or Esc :" 
		GoSub MenuLine
		Begin Case
			Case Upcase(C) = "U" Or actNo = A.PREVPAGE
				If LTop >= LISTDEPTH Then
					LTop -= LISTDEPTH
					LRefresh = True
				End
			Case Upcase(C) = "D" Or actNo = A.NEXTPAGE
				LTop += LISTDEPTH
				LRefresh = True
			Case actNo = A.UP
				If LTop >= LISTDEPTH Then
					LTop -= 1
					LRefresh = True
				End
			Case actNo = A.DOWN
				LTop += 1
				LRefresh = True
			Case actNo = A.CANCEL
				LFin = True
			End case
	Until LFin Do
	Repeat
	Crt @(0,2):@(-3):
	GoSub ShowWindow
	Return
*-----------------------------------------------------------------------
*  Showwindow
*-----------------------------------------------------------------------
ShowWindow: 
	GoSub PrintPage
	Crt crtBuff:
	Return
*-----------------------------------------------------------------------
*  Set.BI.ACCOUNT
*-----------------------------------------------------------------------
Set.BI.ACCOUNT:
	BufInfo<BI.ACCOUNT> = @PATH
	Open ACCOUNT.FILE To fpAcc Then
		Read rec From fpAcc,@ACCOUNT Then
			BufInfo<BI.ACCOUNT> = @ACCOUNT
		End
	End
	Close fpAcc
	Return
*-----------------------------------------------------------------------
*  StartBuf
*-----------------------------------------------------------------------
StartBuf: 

	BufInfo<BI.FILE> = FileName
	BufInfo<BI.ITEM> = ItemName
	BufInfo<BI.PBUFNO> = ParentBufNo
	BufInfo<BI.FIELDFIX> = FldInfo
	BufInfo<BI.VALUEFIX> = DiveValuePos
	BufInfo<BI.USED> = True
	BufInfo<BI.BLOCKSTART> = False
	BufInfo<BI.READONLY> = False
	BufInfo<BI.CAPTURE> = ""
	BufInfo<BI.PATHNAME> = PathName

	!! アカウントの設定
	!! ショートネームがあればそちらを採用なければフルパス
	GoSub Set.BI.ACCOUNT
	
	Changed = False
	BufInfo<BI.LOCKED> = @FALSE

	DiveValuePos = ""
	TgtFld = "" ;** フィールドのリスト
	
	!! ParseTypeの自動判定
	ParseType = If FileName >< "" Then PARSE.DATA Else PARSE.RAW
	** Basic
	If FileName >< "" Then
$IFDEF U2__UNIVERSE
		Equ OBJ.FILENAME Lit 'FileName:".O"'
$ElSE
		Equ OBJ.FILENAME Lit 'FileName:".OUT"'
$ENDIF
		Open OBJ.FILENAME To fpBP.O Then
			Close fpBP.O
			ParseType = PARSE.BASIC
		End Else
			If FileName Matches "BP":@VM:"BP....":@VM:"....BP" Or ItemName Matches "...'.H'" Then 
				ParseType = PARSE.BASIC
			End
		End
		If UpCase(Rec<1>) Matches "PROGRAM...":@VM:"SUBROUTINE...":@VM:"FUNCTION...":@VM:"CLASS..." Then
			ParseType = PARSE.BASIC			
		End
	End
	** Paragraph
	If Rec[1,2] = "PA" Then ParseType = PARSE.PARA
	**
	If Rec[1,15] = "QM PROCESS DUMP" Then
		ParseType = PARSE.PDUMP
		BufInfo<BI.READONLY> = True
	End
	BufInfo<BI.PARSETYPE> = ParseType
	BufInfo<BI.INDENTTYPE> = If ParseType = PARSE.DATA Then "Tab" Else DEFAULT.INDENT.TYPE
	BufInfo<BI.INDENTSIZE> = DEFAULT.INDENT

	If FileName = "" Then
		BufInfo<BI.CAPTURE> = "Create At ":OConv(Date(),"D-YMD[,2]"):" ":OConv(Time(),"MTS")
	End

	GoSub InitBuf
	StartRec = Rec
	
	Return
	
*-----------------------------------------------------------------------
*  InitBuf
*-----------------------------------------------------------------------
InitBuf:
	Y = 1
	X = 1
	DP_X = 1
	keepDP_X = 1
	Top = 1
	XOffSet = 1
	Lines = If Rec = "" Then 1 Else DCount(Rec,@fm)
	EditCmdStack = "SAVED_POINT"
	EditCmdPos = 1
	Return
	
*-----------------------------------------------------------------------
*  ChangeBuf
*-----------------------------------------------------------------------
ChangeBuf: 
	** LRU List 入れ替え
	Find Found In lruBuffList Setting f Then
		Del lruBuffList<f>
		Ins Found Before lruBuffList<1>
	End
	CurBuf = Found
	
	keepDP_X = X
	keepSelection = @TRUE
	
$IFNDEF U2__UNIVERSE
	!! 現在バッファの環境変数を設定
	CALL !SETVAR("@SISH.CBP",BufInfo<BI.PATHNAME>)
	CALL !SETVAR("@SISH.CBF",BufInfo<BI.FILE>)
	CALL !SETVAR("@SISH.CBI",BufInfo<BI.ITEM>)
$ENDIF
	
	Return
*--------------------------------------------------------------------------
* SubstCommand
*--------------------------------------------------------------------------
SubstCommand: 
	Cmd = Change(Cmd,"%f", FileName)
	Cmd = Change(Cmd,"%i", ItemName)
	GoSub SubstPrompts
	Cmd = Change(Cmd,"|",@FM)
	Return
*---------------------------------------------------------------------------
* SubstPrompts
*---------------------------------------------------------------------------
SubstPrompts: 
	PromptList = ""
	NP = 0
	Loop
		NP += 1
		CIx = Index(Cmd,"{",NP)
	While CIx Do
		Temp = (Cmd["{",NP+1,1]["}",1,1])
		Locate Temp In PromptList Setting Pos ELse
			PromptList<-1> = Temp
		End
	Repeat
	For PromptNo = 1 To DCount(PromptList,@FM)
		PromptLine = PromptList<PromptNo> ; GoSub PromptLine
		Input Temp
		Cmd = Change(Cmd,"{":PromptList<PromptNo>:"}",Temp)
	Next
	RETURN
*--------------------------------------------------------------------------
* ToolsMenu
*--------------------------------------------------------------------------
ToolsMenu: 
	MenuLine = "BGColorSwitch Loadtheme Keys :"
	GoSub MenuLine
	C = UpCase(C)
	Begin Case
		Case C = "B"
			GoSub Act.SwitchTheme
		Case C = "L"
			GoSub Load.Theme
		Case C = "K"
			GoSub Keys
			GoSub ShowWindow
		End Case
	Return
*---------------------------------------------------------------------------
* Keys
*---------------------------------------------------------------------------
Keys:   
	Crt @(-1):
!! 	Crt "Cursor Keys:"
!! 	KeyName = "Left"
!! 	KeyName = "Left" ; Key = K.LEFT ; GoSub ShowKey
!! 	KeyName = "Right" ; Key = K.RIGHT ; GoSub ShowKey
!! 	KeyName = "Up" ; Key = K.UP ; GoSub ShowKey
!! 	KeyName = "Down" ; Key = K.DOWN ; GoSub ShowKey
!! 	KeyName = "End" ; Key = K.END ; GoSub ShowKey
!! 	KeyName = "Home" ; Key= K.HOME ; GoSub ShowKey
!! 	KeyName = "Page Up" ; Key = K.PREVPAGE ; GoSub ShowKey
!! 	KeyName = "Next Word" ; Key = K.NEXTWORD ; GoSub ShowKey
!! 	KeyName = "Prev Word" ; Key = K.PREVWORD ; GoSub ShowKey

	CRT FG.BASE3:"BASE3  ":BG.BASE3:"  ":SGR.ALL.OFF
	CRT FG.BASE2:"BASE2  ":BG.BASE2:"  ":SGR.ALL.OFF
	CRT FG.BASE1:"BASE1  ":BG.BASE1:"  ":SGR.ALL.OFF
	CRT FG.BASE0:"BASE0  ":BG.BASE0:"  ":SGR.ALL.OFF
	CRT FG.BASE00:"BASE00 ":BG.BASE00:"  ":SGR.ALL.OFF
	CRT FG.BASE01:"BASE01 ":BG.BASE01:"  ":SGR.ALL.OFF
	CRT FG.BASE02:"BASE02 ":BG.BASE02:"  ":SGR.ALL.OFF
	CRT FG.BASE03:"BASE03 ":BG.BASE03:"  ":SGR.ALL.OFF
	CRT FG.YELLOW:"YELLOW ":BG.YELLOW:"  ":SGR.ALL.OFF
	CRT FG.ORANGE:"ORANGE ":BG.ORANGE:"  ":SGR.ALL.OFF
	CRT FG.RED:"RED    ":BG.RED:"  ":SGR.ALL.OFF
	CRT FG.MAGENTA:"MAGENT ":BG.MAGENTA:"  ":SGR.ALL.OFF
	CRT FG.VIOLET:"VIOLET ":BG.VIOLET:"  ":SGR.ALL.OFF
	CRT FG.BLUE:"BLUE   ":BG.BLUE:"  ":SGR.ALL.OFF
	CRT FG.CYAN:"CYAN   ":BG.CYAN:"  ":SGR.ALL.OFF
	CRT FG.GREEN:"GREEN  ":BG.GREEN:"  ":SGR.ALL.OFF	
	actNo = 0	
	strKey = ""
	
	Loop
		a = @(0, PY-2):@(-13):"SHOW Key Sequence When Press Key (Exit->ESC):":@(-14):" "
		a := strKey
		If actNo Then a:= " actNo->":actNo
		a := @(-4)
		Crt a
		
		C = KeyIn()
		Loop
			GoSub GetCh.Timeout
		While ch <> ""
			C := ch
		Repeat

		If C = ESC Then Exit
		
		!! 文字列形式にエスケープ
		strKey = ""
		z = Len(C)
		For i = 1 To z
			c = C[i,1]
			n = Seq(c)
			Print n:" ":
			If n < 32 Then strKey := '@' : Char(n + 64)
			Else strKey := c
		Next
		Print @(-4)
		
		!! キーシーケンスからアクションを取得
		Locate C in keys By 'AL' Setting i Then
			actNo = keysToAction<i,1>
		End Else 
			actNo = 0
		End
		
	Repeat
	Return
	
!! ShowKey: 
!! 	Convert "'" To "" In Key
!! 	Crt KeyName "L#20" :
!! 	For U = 1 to Len(Key)
!! 		Crt Seq(Key[U,1]):";":
!! 	Next
!! 	Crt
!! 	Return

*--------------------------------------------------------------------------
* InputBox
*   In :
*     inputBox -> 初期入力値
*   OUT : 
*     inputBox -> 確定された入力データ
*--------------------------------------------------------------------------
InputBox:

	If IS.CONSOLE Then
		Prompt ""
		Input out = inputBox
		inputBox = out
		Return
	End

	prevCurBuf = CurBuf
	CurBuf = MAXWINDOWS + 1
	
	GoSub InitBuf
	
	!! 全選択置換
	GoSub Act.SelAll
	InsBuffer = inputBox
	GoSub InsertLines

	X = If inputBox[1,1]=" " Then 2 Else Len(inputBox)+1
	BufInfo<BI.BLOCKSTART> = ""
	
	crtBuff = ""

	!! カーソル位置を保存
	Crt ESC:"7":
	
	Loop
		
		!! １行に固定する
		Y = 1
		Rec = Rec<1>
		
		GoSub Draw.InputBox
		
		GoSub GetKey
		
		keepSelection = False
		
		Begin Case
			!! Cancel
			Case actNo = A.CANCEL
				actNo = 0
				inputBox = ""
				GoTo InputBox.Ending
				
			!! Confirm
			Case actNo = A.NEWLINE
				inputBox = Rec
				GoTo InputBox.Ending
				
			!! WordHokan
			Case actNo = A.WORD_HOKAN
				
				!! 現在カーソル位置から単語の先頭までの単語を取得
				GoSub Get.CurrentWord
				
				!! 置換範囲を描画
				BufInfo<BI.BLOCKSTART> = Y:@VM:stX
				BufInfo<BI.BLOCKEND> = Y:@VM:X
				GoSub Draw.InputBox
				
				CurBuf = prevCurBuf
				
				!! 現在ファイルの単語一覧を取得
				lineList = Rec
				GoSub Get.WordList
				
				CurBuf = MAXWINDOWS + 1
				
				InsBuffer = ""
				
				GoSub Core.ShowWordHokan
				
				If InsBuffer <> "" Then
					GoSub InsertLines
					BufInfo<BI.BLOCKSTART> = ""
				End
				
				If CMD_BUF <> prevCurBuf Then
					!! エディタモードなら再描画
					CurBuf = prevCurBuf
					GoSub PrintTextArea
					GoSub CRT.BUFF.FLUSH
					CurBuf = MAXWINDOWS + 1
				End
				
			!! 共通アクション
			Case 1
				GoSub Input.Actions
				
		End Case
		
		** --------------------------
		** 選択範囲調整
		** --------------------------
		If keepSelection Then
			** 選択終了位置
			If Not(BufInfo<BI.BLOCKEND>) Then BufInfo<BI.BLOCKEND> = Y:@VM:X
			If BufInfo<BI.BLOCKSTART>=BufInfo<BI.BLOCKEND> Then
				BufInfo<BI.BLOCKSTART> = ""
				BufInfo<BI.BLOCKEND> = ""
			End
		End Else
			** 選択範囲が外れた
			BufInfo<BI.BLOCKSTART> = ""
			BufInfo<BI.BLOCKEND> = ""
		End
		
	Repeat

InputBox.Ending:
	
	CurBuf = prevCurBuf
	
Return

Draw.InputBox:

	!! 選択範囲の描画
	Line = Rec
	Row = 1
	GoSub ParseLine
	
	!! 表示
	crtBuff = ESC:"8" ;** カーソル位置を復元
	crtBuff := SGR.ALL.OFF:PLine:@(-4) ;** 文字列の描画
	If Len(Rec) >= X Then crtBuff := @(-9,LenDP(Rec[X,HUGE])) ;** 実際のカーソル位置に戻す
	 
	** CRTフラッシュ処理
	GoSub CRT.BUFF.FLUSH
	
	Return

*--------------------------------------------------------------------------
* Input.Actions
* Switch.Actions

Input.Actions:
	
	If actNo > ENUM.INPUT.ACTION.LAST Then Return
	
Switch.Actions:
	
	If actNo = 0 Then Return
	
	On actNo Goto Act.Left,               ;** Cursor Left
								Act.Right,
								Act.Up,
								Act.Down,
								Act.Home,
								Act.End,
								Act.NextPage,
								Act.PrevPage,
								Act.NextHalf,
								Act.PrevHalf,
								Act.NextWord,
								Act.PrevWord,
								Act.NextStmt,
								Act.PrevStmt,
								Act.NextChar,
								Act.PrevChar,
								Act.Top,
								Act.Bottom,
								Act.SelLeft,
								Act.SelRight,
								Act.SelUp,
								Act.SelDown,
								Act.SelHome,
								Act.SelEnd,
								Act.SelNextWord,
								Act.SelPrevWord,
								Act.SelNextStmt,
								Act.SelPrevStmt,
								Act.SelNextPage,
								Act.SelPrevPage,
								Act.SelNextHalf,
								Act.SelPrevHalf,
								Act.SelNextChar,
								Act.SelPrevChar,
								Act.SelTop,
								Act.SelBottom,
								Act.ScrollMid,
								Act.NewLine,
								Act.InsertChar,
								Act.DelLine,
								Act.DelBackCh,
								Act.DelCh,
								Act.Cut,
								Act.Copy,
								Act.SendRemotePasteCmd,
								Act.Paste,
								Act.PasteLocal,
								Act.Undo,
								Act.Redo,
								Act.SelAll,
								Act.SelExpand,	
							  Act.DelBackWord,
								Act.DelNextWord,
								Act.Cancel,
								Act.Tab,
								Act.ShiftTab,
								Act.SwitchTheme,
								Act.InsVMC,
								Act.InsSMC,
								Act.InsTMC,
								Act.InsTemplate,
								Act.InsCommentOut,
								Act.Search,
								Act.Repeat,
								Act.Reverse,
								Act.Replace,
								Act.ShowBuffList,
								Act.ShowOutline,
								Act.GoLine,
								Act.GoDeclaration,
								Act.GoNextJumpHist,
								Act.GoPrevJumpHist,
								Act.Save,
								Act.ShowHelp,
								Act.Compile,
								Act.Reload,
								Act.Action,
								Act.Exit,
								Act.CloseBuff,
								Act.GoDive,
								Act.ToggleCaseInvert,
								Act.Fit.Term,
								Act.ShowWordHokan,
								DoNew,
								Act.Run,
								Act.Mouse,
								Act.ScrollUp,
								Act.ScrollDown
NULL.Action:
	Return

* **************************************************************************
* Act.Left

Act.Fit.Term:
	GoSub AutoTermSize
	IF bAutoCommand Then
		bAutoEditor = @TRUE
		GoSub Act.Exit
	End
	Return

* **************************************************************************
* Act.Left

Act.SelLeft:
	GoSub SelectionStart
Act.Left:
	If BufInfo<BI.BLOCKEND> Then
		prevPos = Y:@FM:X
		GoSub GoToRangeStart
		If prevPos <> Y:@FM:X Then Return ;** Go To Range Start Then Stop
	End
	
	If X > 1 Then X -= 1 Else
		If Y > 1 Then
			prevY = Y
			Y -= 1 ; X = Len(Rec<Y>) + 1
			keepDP_X = 0
		End
	End
	Return

* **************************************************************************
* Act.Right

Act.SelRight:
	GoSub SelectionStart
Act.Right:
	If BufInfo<BI.BLOCKEND> Then
		prevPos = Y:@FM:X
		GoSub GoToRangeEnd
		If prevPos <> Y:@FM:X Then Return ;** Go To Range End Then Stop
	End
	
	A = Rec<Y>
	If A[X,1] = "" Then
		If Y < Lines Then Y += 1 ; X = 1
	End Else
		X += 1
	End
	Return

* **************************************************************************
* Act.Up

Act.SelUp:
	GoSub SelectionStart
Act.Up:
	If BufInfo<BI.BLOCKEND> Then
		prevPos = Y:@FM:X
		GoSub GoToRangeStart
		X = prevPos<2> ;** X位置は元に戻す
	End
	
	If AutoWrap>0 Then
		nextDX = ""
		nextDY = ""
		
		Line = Rec<Y>
		Line.len = Len(Line)+1
		tmpDX = 1
		tmpDY = 1
		For i=1 To Line.len
			c = Line[i,1]
			dispLen = LenDP(c)
			
			If i = X Then
				nextDX = Max(tmpDX,keepDP_X)
				nextDY = tmpDY-1
				Exit
			End
			
			If c = @VM Or tmpDX+dispLen > AutoWrap Then
				* 改行
				tmpDX = 1
				tmpDY += 1
				If c = @VM Then dispLen = 0
			End
			
			tmpDX += dispLen
				
		Next i
		
		If nextDY>=1 Then
			tmpDX = 1
			tmpDY = 1
			For i=1 To Line.len
				c = Line[i,1]
				dispLen = LenDP(c)
				
				If nextDX<=tmpDX And nextDY=tmpDY Then
					X = i
					Return
				End
				
				If c = @VM Or tmpDX+dispLen > AutoWrap Then
					* 改行
					tmpDX = 1
					tmpDY += 1
					If nextDY<tmpDY Then
						X = i
						Return
					End
					If c = @VM Then dispLen = 0
				End
				
				tmpDX += dispLen
			Next i
		End
		
		!! １つ上の行の最後の行に移動
		Y -= 1
		If Y > 0 Then
			Line = Rec<Y>
			Line.len = Len(Line)+1
			
			tmpDX = 1
			For i=1 To Line.len
				c = Line[i,1]
				dispLen = LenDP(c)
				
				If nextDX>=tmpDX Then
					X = i
				End
				
				If c = @VM Or tmpDX+dispLen > AutoWrap Then
					* 改行
					tmpDX = 1
					If c = @VM Then dispLen = 0
				End
				
				tmpDX += dispLen
			Next i
		End
		
		Return
	End
	
	Y -= 1
	
	Return

* **************************************************************************
* Act.Down

Act.SelDown:
	GoSub SelectionStart
Act.Down:
	If BufInfo<BI.BLOCKEND> Then
		prevPos = Y:@FM:X
		GoSub GoToRangeEnd
		X = prevPos<2> ;** X位置は元に戻す
	End
	
	If AutoWrap>0 Then
		nextDX = ""
		nextDY = BIG
		
		Line = Rec<Y>
		Line.len = Len(Line)
		tmpDX = 1
		tmpDY = 1
		For i=1 To Line.len
			c = Line[i,1]
			dispLen = LenDP(c)
			
			If i = X Then
				!! 現在位置
				nextDX = Max(tmpDX,keepDP_X)
				nextDY = tmpDY+1
			End Else
				If nextDX<=tmpDX And nextDY=tmpDY Then
					X = i
					Return
				End
			End
			
			If c = @VM Or tmpDX+dispLen > AutoWrap Then
				* 改行
				tmpDX = 1
				tmpDY += 1
				If nextDY<tmpDY Then
					X = i
					Return
				End
				If c = @VM Then dispLen = 0
			End
			
			tmpDX += dispLen
			
		Next i
		
		If nextDY=tmpDY Then
			X = Line.len+1 ;** 次の行の最終にする
		End Else
			Y += 1
		End
		
		Return
	End
	
	Y += 1
	
	Return

* **************************************************************************
* Act.NextWord

Act.SelNextWord:
	GoSub SelectionStart
Act.NextWord:
	If Not(keepSelection) And BufInfo<BI.BLOCKSTART> Then
		If BufInfo<BI.BLOCKSTART,1>#BufInfo<BI.BLOCKEND,1> Then
			GoSub Act.IncreaseIndent
			Return
		End
	End
	
	If BufInfo<BI.BLOCKEND> Then
		prevPos = Y:@FM:X
		GoSub GoToRangeEnd
		If prevPos <> Y:@FM:X Then Return ;** Go To Range End Then Stop
	End
	
	Line = Rec<Y>
	If X >= Len(Line)+1 Then
		!! 次の行へ
		If Y < Lines Then Y += 1; X = 1
	End Else
		If Line[1,X] = Space(X) And STDINDENT#0 Then
			!! インデント部
			
			X = Int((X-1) / STDINDENT) * STDINDENT + STDINDENT + 1
			
		End Else
			!! 非インデント部
			If kakko1 >< "" Then
				!! 対応する括弧に移動
				X = kakko1<2,1>+1
				If BufInfo<BI.BLOCKSTART> Then BufInfo<BI.BLOCKEND> = Y:@VM:X
			End Else
				!! 単語移動
				GoSub Move.NextWord
			End
		End
	End
	Return

* **************************************************************************
* Act.PrevWord

Act.SelPrevWord:
	GoSub SelectionStart
Act.PrevWord:
	If Not(keepSelection) And BufInfo<BI.BLOCKSTART> Then
		If BufInfo<BI.BLOCKSTART,1>#BufInfo<BI.BLOCKEND,1> Then
			GoSub Act.DecreaseIndent
			Return
		End
	End
	
	If BufInfo<BI.BLOCKEND> Then
		prevPos = Y:@FM:X
		GoSub GoToRangeStart
		If prevPos <> Y:@FM:X Then Return ;** Go To Range Start Then Stop
	End
	
	Line = Rec<Y>
	If X <= 1 Then
		!! 前の行へ
		If Y > 1 Then Y -= 1; X = Len(Rec<Y>)+1
	End Else
	
		If Line[1,X-1] = Space(X-1) And STDINDENT#0 Then
			!! インデント部
			
			X = Int((X-1) / STDINDENT) * STDINDENT - STDINDENT + 1
			
		End Else
			!! 非インデント部
			
			If kakko2 >< "" Then
				!! 対応する括弧に移動
				X = kakko2<2,1>
				If BufInfo<BI.BLOCKSTART> Then
					BufInfo<BI.BLOCKEND> = Y:@VM:X
				End
			End Else
				!! 単語移動
				GoSub Move.PrevWord
			End
		End      
	End
	
	Return

* **************************************************************************
* Act.NextStmt

Act.SelNextStmt:
	GoSub SelectionStart
Act.NextStmt:
!	If Not(keepSelection) And BufInfo<BI.BLOCKSTART> Then
!		GoSub Act.SwapDown
!		Return
!	End
	
	If BufInfo<BI.BLOCKEND> Then
		prevPos = Y:@FM:X
		GoSub GoToRangeEnd
		X = prevPos<2> ;** X位置は元に戻す
	End
	A = TrimF(Rec<Y>)[1,1]
	If A<>"" And Count("*!$",A) Then
		!! コメント行内
		Line = Change(Rec<Y+1>,Char(9),Space(STDTAB))
		GoSub GetX.From.keepDPX
		ch = Line[outX,1]
		If Not(Count("*!$",ch)) And (ch = "" Or TrimF(Convert("*!$","  ",Line)[1,outX]) = "") Then
			!! 次行がインデント内なら次に文字が出現するまで進む
			For iY = Y+1 To Lines
				Line = Change(Rec<iY>,Char(9),Space(STDTAB))
				GoSub GetX.From.keepDPX
				If Not(Line[outX,1] = "" Or TrimF(Convert("*!$","  ",Line)[1,outX]) = "") Then Exit
			Next 
			Y = iY
		End Else
			!! 文の切れ目まで進む（インデントの出現かコメント行の出現で止める）
			For iY = Y+1 To Lines+1
				Line = Change(Rec<iY>,Char(9),Space(STDTAB))
				If Not(Count("*!$",TrimF(Line)[1,1])) Then Exit
				GoSub GetX.From.keepDPX
				ch = Line[outX,1]
				If Not(Count("*!$",ch)) And (ch = "" Or TrimF(Convert("*!$","  ",Line)[1,outX]) = "") Then Exit
			Next
			Y = If iY - 1 = Y Then Y + 1 Else iY - 1
		End
	End Else
		!! コメント行外
		Line = Change(Rec<Y+1>,Char(9),Space(STDTAB))
		GoSub GetX.From.keepDPX
		If Count("*!$",TrimF(Line)[1,1]) Or Line[outX,1] = "" Or TrimF(Line[1,outX]) = "" Then
			!! 次行がインデント内なら次に文字が出現するまで進む
			For iY = Y+1 To Lines
				Line = Change(Rec<iY>,Char(9),Space(STDTAB))
				If Count("*!$",TrimF(Line)[1,1]) Then Continue
				GoSub GetX.From.keepDPX
				If Not(Line[outX,1] = "" Or TrimF(Line[1,outX]) = "") Then Exit
			Next 
			Y = iY
		End Else
			!! 文の切れ目まで進む（インデントの出現かコメント行の出現で止める）
			For iY = Y+1 To Lines+1
				Line = Change(Rec<iY>,Char(9),Space(STDTAB))
				If Count("*!$",TrimF(Line)[1,1]) Then Exit
				GoSub GetX.From.keepDPX
				If Line[outX,1] = "" Or TrimF(Line[1,outX]) = "" Then Exit
			Next
			Y = iY-1
		End
	End
	If Y > Lines Then Y = Lines
	Return

* **************************************************************************
* SwapUp

Act.SwapUp:
	
	If Not(BufInfo<BI.BLOCKSTART>) Then
		blockStart = Y:@VM:1
		blockEnd = Y:@VM:1
	End Else
		GoSub GetSelBlock
	End
	
	keepSelection = True
	
	If blockStart<1> <= 1 Then Return
	
	blockStart<2> = 1
	If blockEnd<2> > 1 Then
		blockEnd<1> += 1
		blockEnd<2> = 1
	End
	InsBuffer = Rec[@FM,blockStart<1>,blockEnd<1>-blockStart<1>]
	deltaY = Y-blockStart<1>
	
	!! 切り取って
	ecmd = ""
	If blockEnd<1> > Lines Then
		!! 最終行にかかる場合
		ecmd<1> = blockStart<1>-1
		ecmd<2> = Len(Rec<blockStart<1>>)+1
	End Else
		ecmd<1> = blockStart<1>
		ecmd<2> = blockStart<2>
	End
	ecmd<3> = blockEnd<1>
	ecmd<4> = blockEnd<2>
	ecmd<5> = ""
	ecmd<6> = "1"
	editCmd = ecmd
	
	!! 貼り付け
	ecmd = ""
	ecmd<1> = blockStart<1>-1
	ecmd<2> = 1
	ecmd<3> = ""
	ecmd<4> = ""
	ecmd<5> = Convert(@FM,Char(10),InsBuffer):Char(10)
	ecmd<6> = Y:",":X:":1"
	editCmd<-1> = ecmd
	
	GoSub StackEditCmd
	
	!! Y位置調整
	Y = blockStart<1>-1+deltaY
	
	Return

* **************************************************************************
* SwapDown

Act.SwapDown:
	
	If Not(BufInfo<BI.BLOCKSTART>) Then
		blockStart = Y:@VM:1
		blockEnd = Y:@VM:1
	End Else
		GoSub GetSelBlock
	End
	
	keepSelection = True
	
	If blockEnd<1> > Lines Then Return
	
	blockStart<2> = 1
	If blockEnd<2> > 1 Then
		blockEnd<1> += 1
		blockEnd<2> = 1
	End
	
	InsBuffer = Rec[@FM,blockStart<1>,blockEnd<1>-blockStart<1>]
	deltaY = Y-blockStart<1>
	
	!! 切り取って
	ecmd = ""
	ecmd<1> = blockStart<1>
	ecmd<2> = blockStart<2>
	ecmd<3> = blockEnd<1>
	ecmd<4> = blockEnd<2>
	ecmd<5> = ""
	ecmd<6> = "1"
	editCmd = ecmd
	
	!! 張り付け
	ecmd = ""
	ecmd<1> = blockStart<1>+1
	ecmd<2> = 1
	ecmd<3> = ""
	ecmd<4> = ""
	ecmd<5> = Convert(@FM,Char(10),InsBuffer):If blockEnd<1> < Lines Then Char(10) Else ""
	ecmd<6> = "1:1"
	editCmd<-1> = ecmd
	
	GoSub StackEditCmd
	
	!! Y位置調整
	Y = blockStart<1>+1+deltaY
	
	Return

* **************************************************************************
* Act.PrevStmt

Act.SelPrevStmt:
	GoSub SelectionStart
Act.PrevStmt:
!	If Not(keepSelection) And BufInfo<BI.BLOCKSTART> Then
!		GoSub Act.SwapUp
!		Return
!	End
	
	If BufInfo<BI.BLOCKEND> Then
		prevPos = Y:@FM:X
		GoSub GoToRangeStart
		X = prevPos<2> ;** X位置は元に戻す
	End
	A = TrimF(Rec<Y>)[1,1]
	If A<>"" And Count("*!$",A) Then
		!! コメント行内
		Line = Change(Rec<Y-1>,Char(9),Space(STDTAB))
		GoSub GetX.From.keepDPX
		ch = Line[outX,1]
		If Not(Count("*!$",ch)) And (ch = "" Or TrimF(Convert("*!$","  ",Line)[1,outX]) = "") Then
			!! 次行がインデント内なら次に文字が出現するまで進む
			For iY = Y-1 To 1 Step -1
				Line = Change(Rec<iY>,Char(9),Space(STDTAB))
				GoSub GetX.From.keepDPX
				If Not(Line[outX,1] = "" Or TrimF(Convert("*!$","  ",Line)[1,outX]) = "") Then Exit
			Next 
			Y = iY
!		ch = Line[X,1]
!		If Not(Count("*!$",ch)) And (ch = "" Or TrimF(Convert("*!$","  ",Line)[1,X]) = "") Then
!			!! 次行がインデント内なら次に文字が出現するまで戻る
!			For iY = Y-1 To 1 Step -1
!				Line = Rec<iY>
!				If Not(Line[X,1] = "" Or TrimF(Convert("*!$","  ",Line)[1,X]) = "") Then Exit
!			Next 
!			Y = iY
		End Else
			!! 文の切れ目まで戻る（インデントの出現で止める）
			For iY = Y-1 To 0 Step -1
				Line = Change(Rec<iY>,Char(9),Space(STDTAB))
				If Not(Count("*!$",TrimF(Line)[1,1])) Then Exit
				GoSub GetX.From.keepDPX
				ch = Line[outX,1]
				If Not(Count("*!$",ch)) And (ch = "" Or TrimF(Convert("*!$","  ",Line)[1,outX]) = "") Then Exit
			Next
			Y = If iY + 1 = Y Then Y - 1 Else iY + 1
		End
	End Else
		!! コメント行外
		Line = Change(Rec<Y-1>,Char(9),Space(STDTAB))
		GoSub GetX.From.keepDPX
		If Count("*!$",TrimF(Line)[1,1]) Or Line[outX,1] = "" Or TrimF(Line[1,outX]) = "" Then
			!! 次行がインデント内なら次に文字が出現するまで進む
			For iY = Y-1 To 1 Step -1
				Line = Change(Rec<iY>,Char(9),Space(STDTAB))
				If Count("*!$",TrimF(Line)[1,1]) Then Continue
				GoSub GetX.From.keepDPX
				If Not(Line[outX,1] = "" Or TrimF(Line[1,outX]) = "") Then Exit
			Next 
			Y = iY
		End Else
			!! 文の切れ目まで戻る（インデントの出現で止める）
			For iY = Y-1 To 0 Step -1
				Line = Change(Rec<iY>,Char(9),Space(STDTAB))
				If Count("*!$",TrimF(Line)[1,1]) Then Exit
				GoSub GetX.From.keepDPX
				If Line[outX,1] = "" Or TrimF(Line[1,outX]) = "" Then Exit
			Next
			Y = iY+1
		End
	End
	If Y < 1 Then Y = 1
	Return

* **************************************************************************
* Act.NextChar

Act.SelNextChar:
	GoSub SelectionStart
	BufInfo<BI.BLOCKEND> = ""
Act.NextChar:
	moveChar = @TRUE ;** 進むフラグ
	keepSelection = @TRUE
	StatusMessage = "Enter first char in word ->"
	Return

* **************************************************************************
* Act.PrevChar

Act.SelPrevChar:
	GoSub SelectionStart
	BufInfo<BI.BLOCKEND> = ""
Act.PrevChar:
	moveChar = @FALSE ;** 戻るフラグ
	keepSelection = @TRUE
	StatusMessage = "Enter first char in word (move prev) ->"
	Return

* **************************************************************************
* Act.End

Act.SelEnd:
	GoSub SelectionStart
Act.End:
	GoSub GoToRangeEnd
	
	If AutoWrap>0 Then
		nextDY = 0
		
		Line = Rec<Y>
		Line.len = Len(Line)
		tmpDX = 1
		tmpDY = 1
		For i=1 To Line.len
			c = Line[i,1]
			dispLen = LenDP(c)
			If c = @VM Or tmpDX+dispLen > AutoWrap Then
				* 改行
				If nextDY=tmpDY Then
					X = If c = @VM Then i Else i-1
					Return
				End
				tmpDX = 1
				tmpDY += 1
				If c = @VM Then dispLen = 0
			End

			If i=X Then
				nextDY = tmpDY
			End
			
			tmpDX += dispLen
				
		Next i
		
	End

	X = Len(Rec<Y>) + 1
	Return

* **************************************************************************
* Act.Home

Act.SelHome:
	GoSub SelectionStart
Act.Home:
	!! 選択継続中でカーソルと範囲選択終了の位置が違う場合は
	!! カーソルを範囲先端に持っていく
	If BufInfo<BI.BLOCKSTART> <> Y:@VM:X And keepSelection Then
		!! Go To Range Start
		GoSub GetSelBlock
		Y = blockStart<1>
		X = blockStart<2>
		BufInfo<BI.BLOCKEND> = BufInfo<BI.BLOCKSTART>
	End
	If Not(keepSelection) Then
		Redraw = REDRAW.ALL
	End
	BufInfo<BI.BLOCKEND> = ""
	
	If AutoWrap>0 Then
		homeIndex = 1
		
		Line = Rec<Y>
		Line.len = Len(Line)+1
		tmpDX = 1
		tmpDY = 1
		For i=1 To Line.len
			c = Line[i,1]
			dispLen = LenDP(c)
			
			If i = X Then
				Exit
			End
			
			If c = @VM Or tmpDX+dispLen > AutoWrap Then
				* 改行
				tmpDX = 1
				tmpDY += 1
				homeIndex = i
				If c = @VM Then
					dispLen = 0
					homeIndex = i+1
				End Else
					homeIndex = i
				End
			End
			
			tmpDX += dispLen
				
		Next i
		
		X = homeIndex
		
		Return
	End
	
	** 論理行頭を探す
	logicalX = 1
	For i= 1 To HUGE
		a = Rec<Y>[i,1]
		If a > CHAR(32) Then logicalX = i; Exit
	While a >< ""
	Next
	** 現在位置が論理行頭なら先頭行にする
	If logicalX = X Then X = 1 Else X = logicalX
	If XOffSet > 1 Then Redraw = REDRAW.ALL
	XOffSet = 1
	Return

* **************************************************************************
* Act.NextPage

Act.SelNextPage:
	GoSub SelectionStart
Act.NextPage:
	If BufInfo<BI.BLOCKEND> Then
		prevPos = Y:@FM:X
		GoSub GoToRangeEnd
		X = prevPos<2> ;** X位置は元に戻す
	End
	
	dispY = Y - Top
	Y += Depth
	If Y > Lines Then Y = Lines
	Top = Y - dispY
	Redraw = REDRAW.ALL
	Return

* **************************************************************************
* Act.PrevPage

Act.SelPrevPage:
	GoSub SelectionStart
Act.PrevPage:
	If BufInfo<BI.BLOCKEND> Then
		prevPos = Y:@FM:X
		GoSub GoToRangeStart
		X = prevPos<2> ;** X位置は元に戻す
	End
	
	dispY = Y - Top
	Y -= Depth
	If Y < 1 Then Y = 1
	Top = Y - dispY
	Redraw = REDRAW.ALL
	Return

* **************************************************************************
* Act.NextHalf

Act.SelNextHalf:
	GoSub SelectionStart
Act.NextHalf:
	If BufInfo<BI.BLOCKEND> Then
		prevPos = Y:@FM:X
		GoSub GoToRangeEnd
		X = prevPos<2> ;** X位置は元に戻す
	End
	
	Y += Int(Depth/3)
	If Y > Lines Then Y = Lines
	
	Return

* **************************************************************************
* Act.PrevHalf

Act.SelPrevHalf:
	GoSub SelectionStart
Act.PrevHalf:
	If BufInfo<BI.BLOCKEND> Then
		prevPos = Y:@FM:X
		GoSub GoToRangeStart
		X = prevPos<2> ;** X位置は元に戻す
	End
	
	Y -= Int(Depth/3)
	If Y < 1 Then Y = 1
	
	Return

* **************************************************************************
* Act.Top

Act.SelTop:
	GoSub SelectionStart
Act.Top:
	!! 選択継続中でカーソルと範囲選択終了の位置が違う場合は
	!! カーソルを範囲先端に持っていく
	If BufInfo<BI.BLOCKSTART> <> Y:@VM:X And keepSelection Then
		!! Go To Range Start
		GoSub GetSelBlock
		Y = blockStart<1>
		X = blockStart<2>
		BufInfo<BI.BLOCKEND> = BufInfo<BI.BLOCKSTART>
	End
	If Not(keepSelection) Then
		Redraw = REDRAW.ALL
	End
	BufInfo<BI.BLOCKEND> = ""
	
	Y = 1
	X = 1
	Return

* **************************************************************************
* Act.Bottom

Act.SelBottom:
	GoSub SelectionStart
Act.Bottom:
	GoSub GoToRangeEnd
	
	Y = Lines
	X = Len(Rec<Y>)+1
	Return

* **************************************************************************
* Act.SelAll
* 全選択

Act.SelAll:
	If BufInfo<BI.BLOCKSTART> = 1:@VM:1 And BufInfo<BI.BLOCKEND> = Lines:@VM:(Len(Rec<Lines>) + 1) Then
		!! 全選択解除
		keepSelection = @FALSE
	End Else
		!! 全選択
		BufInfo<BI.BLOCKSTART,1> = 1
		BufInfo<BI.BLOCKSTART,2> = 1
		BufInfo<BI.BLOCKEND,1> = Lines
		BufInfo<BI.BLOCKEND,2> = Len(Rec<Lines>) + 1
		keepSelection = @TRUE
	End
	Return

* **************************************************************************
* Act.SelExpand
* 選択範囲拡張
* -> 単語 -> 両端スペース -> 1行 -> 同一インデント行 -> なし

Act.SelExpand:
	
	If BufInfo<BI.BLOCKSTART> Then
		GoSub GetSelBlock
		If blockStart<2> = 1 And blockEnd<2> = 1 Then
			!! 行選択 -> 同一インデント行選択
			
			bChanged = @FALSE ;** 選択範囲に変化があったかどうか
			
			!! 選択先端
			iY = blockStart<1>
			line = Rec<iY>
			GoSub GetIndentCnt
			If indentCnt > 0 Then
				baseIndentCnt = indentCnt
				Loop
					iY -= 1
					line = Rec<iY>
					GoSub GetIndentCnt
				Until baseIndentCnt > indentCnt Or iY = 1
					bChanged = @TRUE
					BufInfo<BI.BLOCKSTART,1> = iY
				Repeat
			End
			
			!! 選択末端
			iY = blockEnd<1> - 1
			line = Rec<iY>
			GoSub GetIndentCnt
			If indentCnt > 0 Then
				baseIndentCnt = indentCnt
				Loop
					iY += 1
					line = Rec<iY>
					GoSub GetIndentCnt
				Until baseIndentCnt > indentCnt Or iY = Lines
					bChanged = @TRUE
					BufInfo<BI.BLOCKEND,1> = iY + 1
				Repeat
			End
			
			If Not(bChanged) Then
				!! 同一インデント行選択 -> 解除
				keepSelection = @FALSE
				Redraw = REDRAW.ALL
				Return
			End
			
		End Else
			!! 単語選択 < 行選択
			
			sY = blockStart<1>
			sX = blockStart<2>
			eY = blockEnd<1>
			eX = blockEnd<2>
			
			Line = Rec<Y>
			ch = Line[X,1]
			If Not(Count(' ':CHAR(9),ch)) Then
				!! カーソル位置が空白でなければ選択範囲を空白まで進める
				
				!! 選択開始を空白文字まで進める
				Loop
					sX -= 1
					ch = Line[sX,1]
				Until sX <= 0 Or Count(' ':CHAR(9),ch) Do
				Repeat
				sX += 1
				If BufInfo<BI.BLOCKSTART,1> = sY Then
					BufInfo<BI.BLOCKSTART,2> = sX
				End Else
					BufInfo<BI.BLOCKEND,2> = sX
				End
				
				!! 選択終了を空白文字まで進める
				Line = Rec<eY>
				Loop
					ch = Line[eX,1]
				Until ch = "" Or Count(' ':CHAR(9),ch) Do
					eX += 1
				Repeat
				If BufInfo<BI.BLOCKEND,1> = eY Then
					BufInfo<BI.BLOCKEND,2> = eX
				End Else
					BufInfo<BI.BLOCKSTART,2> = eX
				End
				
			End
			
			If blockStart<2> = sX And blockEnd<2> = eX Then
				!! 選択 -> 1行選択(改行込)
				BufInfo<BI.BLOCKSTART,1> = blockStart<1>
				BufInfo<BI.BLOCKSTART,2> = 1
				BufInfo<BI.BLOCKEND,1> = blockEnd<1> + 1
				BufInfo<BI.BLOCKEND,2> = 1
			End
			
		End
	End Else
		!! 単語選択
		GoSub GetWord
		BufInfo<BI.BLOCKSTART,2> = SOW
		BufInfo<BI.BLOCKEND,2> = EOW
		BufInfo<BI.BLOCKSTART,1> = Y
		BufInfo<BI.BLOCKEND,1> = Y
	End
	keepSelection = @TRUE

Return

* **************************************************************************
* Act.Cancel

Act.Cancel:
	If BufInfo<BI.BLOCKSTART> Then
		!! 選択があれば選択解除
		keepSelection = @FALSE
		actNo = 0 ;** Cancelは無効にする
	End
	Return

* **************************************************************************
* Act.ScrollMid

Act.ScrollMid:
	GoSub StackJumpHistory ;** ジャンプ位置も記録しておく
	Top = Y - Int(Depth / 2)
	Redraw = REDRAW.ALL
	Return

* **************************************************************************
* Act.DelCh

Act.DelCh:
	
	editCmd = ""
	
	If CurBuf = CMD_BUF Then
		If BufInfo<BI.BLOCKSTART>="" And Len(Rec<Y>)+1 = X Then
			Return ;** コマンドバッファは改行を削除できない
		End
	End
	
	If BufInfo<BI.BLOCKSTART> Then
		** 選択中
		editCmd<1> = BufInfo<BI.BLOCKEND, 1>
		editCmd<2> = BufInfo<BI.BLOCKEND, 2>
		editCmd<3> = BufInfo<BI.BLOCKSTART, 1>
		editCmd<4> = BufInfo<BI.BLOCKSTART, 2>
	End Else
		editCmd<1> = Y
		editCmd<2> = X
		editCmd<3> = Y
		editCmd<4> = X+1
	End
	editCmd<5> = ""
	editCmd<6> = "1" ;** 選択範囲がX=1の時はカーソルX位置をキープする
	
	GoSub StackEditCmd
	
	Return

* **************************************************************************
* Act.DelBackCh

Act.DelBackCh:
	If Y=1 And X=1 Else
	
		editCmd = ""
		If BufInfo<BI.BLOCKSTART> Then
			** 選択中
			editCmd<1> = BufInfo<BI.BLOCKEND, 1>
			editCmd<2> = BufInfo<BI.BLOCKEND, 2>
			editCmd<3> = BufInfo<BI.BLOCKSTART, 1>
			editCmd<4> = BufInfo<BI.BLOCKSTART, 2>
		End Else
			editCmd<1> = Y
			editCmd<2> = X
			If X = 1 Then
				editCmd<3> = Y-1
				editCmd<4> = Len(Rec<Y-1>)+1
			End Else
				editCmd<3> = Y
				editCmd<4> = X-1
			End
		End
		editCmd<5> = ""
		editCmd<6> = ""
		
		GoSub StackEditCmd
		
	End
	
	Return

* **************************************************************************
* Act.DelLine

Act.DelLine:
	
	tmpX = X ;** X位置を維持する
	
	editCmd = ""
	editCmd<1> = Y
	editCmd<2> = 1
	IF Y+1 > Lines Then
		editCmd<3> = Y
		editCmd<4> = Len(Rec<Y>)+1
	End Else
		editCmd<3> = Y+1
		editCmd<4> = 1
	End
	editCmd<5> = ""
	editCmd<6> = ""
	
	GoSub StackEditCmd
	
	X = tmpX
	
	Return


* **************************************************************************
* Act.InsertChar

Act.InsertChar:
	
	If moveChar # "" Then
		!! １文字移動割り込み処理モード
		If moveChar<2> = "" Then
			moveChar<2> = C ;** 検索文字をセット
		End
		If moveChar<2> = C Then
			ch = moveChar<2>
			iY = Y
			If moveChar<1> Then
				If BufInfo<BI.BLOCKEND> And BufInfo<BI.BLOCKEND> <> Y:@VM:X Then
					!! カーソルと範囲終了の位置が違う場合は
					!! カーソルを範囲先端に持っていく
					GoSub GetSelBlock
					Y = blockStart<1>
					X = blockStart<2>
					prevY = Y
					prevX = X
					BufInfo<BI.BLOCKSTART> = Lower(blockEnd)
				End
				!! 進む
				iX = Index(Rec<iY>[X+1,HUGE],ch,1)
				If Not(iX) Then
					endY = Y+(Depth-(Y-Top))-1
					For iY = Y+1 To endY
						iX = Index(Rec<iY>,ch,1)
						If iX Then Exit
					Next 
				End Else iX = X + iX
			End Else
				If BufInfo<BI.BLOCKEND> And BufInfo<BI.BLOCKEND> <> Y:@VM:X Then
					!! カーソルと範囲終了の位置が違う場合は
					!! カーソルを範囲先端に持っていく
					GoSub GetSelBlock
					Y = blockStart<1>
					X = blockStart<2>
					prevY = Y
					prevX = X
					BufInfo<BI.BLOCKSTART> = Lower(blockEnd)
				End
				!! 戻る
				Line = Rec<iY>[1,X-1]
				iX = Index(Line,ch,Count(Line,ch))
				If Not(iX) Then
					For iY = Y-1 To Top Step -1
						Line = Rec<iY>
						iX = Index(Line,ch,Count(Line,ch))
						If iX Then Exit
					Next 
				End
			End
			If iX Then
				Y = iY
				X = iX
				StatusMessage = "Enter same char go to next -> ":ch
			End Else
				StatusMessage = "Not found char -> ":ch
			End
			BufInfo<BI.BLOCKEND> = ""
			keepSelection = @TRUE
			Return ;** !! 入力は無かった事にする
		End
		moveChar = "" ;** モード解除
	End
	
	InsBuffer = C
	curFlg = ""
	ki = Index(KAKKO.CHAR.LIST2,C,1)
	If ki Then
		!! 入力文字が閉じ括弧である
		If BufInfo<BI.BLOCKSTART> Then
			!! 選択範囲があればその前後に括弧を入れる
			GoSub GET.SELECTION.STRING
			InsBuffer = KAKKO.CHAR.LIST1[ki,1]:selString:KAKKO.CHAR.LIST2[ki,1]
		End
	End Else
		ki = Index(KAKKO.CHAR.LIST1,C,1)
		If ki Then
			!! 入力文字が開き括弧である
			If BufInfo<BI.BLOCKSTART> Then
				!! 選択範囲があればその前後に括弧を入れる
				GoSub GET.SELECTION.STRING
				!! 開く括弧
				InsBuffer = KAKKO.CHAR.LIST1[ki,1]:selString:KAKKO.CHAR.LIST2[ki,1]
				Y = blockStart<1>
				X = blockStart<2>
				curFlg = "1"
			End
		End
	End

	editCmd = ""
	If BufInfo<BI.BLOCKSTART> Then
		** 選択中
		editCmd<1> = BufInfo<BI.BLOCKEND, 1>
		editCmd<2> = BufInfo<BI.BLOCKEND, 2>
		editCmd<3> = BufInfo<BI.BLOCKSTART, 1>
		editCmd<4> = BufInfo<BI.BLOCKSTART, 2>
		editCmd<5> = InsBuffer
		editCmd<6> = curFlg
	End Else
		editCmd<1> = Y
		editCmd<2> = X
		If bOverlay Then
			editCmd<3> = Y
			editCmd<4> = X + (If X < Len(Rec<Y>) Then 1 Else 0)
		End Else
			editCmd<3> = ""
			editCmd<4> = ""
		End
		editCmd<5> = InsBuffer
		editCmd<6> = curFlg
	End
	
	GoSub StackEditCmd
	
	Return

* **************************************************************************
* Act.Search

Act.Search:
	Replacing = False
	searchReverse = False
	inputBox = SearchString
	SearchString = ""
	GoSub Search.Core
	Return

* **************************************************************************
* Act.Repeat

Act.Repeat:
	searchReverse = False
	GoSub Search.Core
	Return

* **************************************************************************
* Act.Reverse

Act.Reverse:
	searchReverse = True
	GoSub Search.Core
	Return

* **************************************************************************
* Act.Replace

Act.Replace:
	Replacing = True
	SearchString = ""
	GoSub Search.Core
	Return

* --------------------------------------------------------------------------
* Search.Core

Search.Core:
	If SearchString = "" Then 
		If BufInfo<BI.BLOCKSTART> And BufInfo<BI.BLOCKSTART,1> = BufInfo<BI.BLOCKEND,1> Then
			** インラインで選択されている文字列を初期値にする
			startX = BufInfo<BI.BLOCKSTART,2>
			endX = BufInfo<BI.BLOCKEND, 2>
			If startX > endX Then tmp = startX; startX = endX; endX = tmp
			inputBox = Rec<Y>[startX, endX-startX]
			If Convert(PUNCS:".":@fm:@vm:@svm,"",Rec<Y>[startX-1,1])="" Then inputBox = " ":inputBox
		End
		PromptLine = FG.YELLOW:BG.BASE3:"Enter Search Text :" ; GoSub PromptLine
		GoSub InputBox
		SearchString = inputBox
		!! スペースで始まる場合は厳格モード
		If Trim(SearchString)="" Or SearchString[1,1] # " " Then
			ignoreCase = True
		End Else
			ignoreCase = False
			SearchString = SearchString[2,9999]
		End
		!! ハイライト文字列の設定
		BufInfo<BI.HIWORD> = SearchString
		
		Redraw = REDRAW.ALL
		If SearchString = "" Then Return
		
		If BufInfo<BI.BLOCKSTART> And BufInfo<BI.BLOCKSTART,1> = BufInfo<BI.BLOCKEND,1> Then
			If Replacing Then X = startX - 2 ;** 現在カーソル位置の物を対象に入れるため
		End
		
	End

	!!
	!! 検索ループ
	!!
	firstFound = @TRUE
	replaceCnt = 0
	skipVerify = @FALSE
	Loop

		prevY = Y
	
		!! 検索ロジック
		isFound = @FALSE
		If ignoreCase Then
			Word = UpCase(SearchString)
			!! 大小無視
			If searchReverse Then
				Ix = X - 1
				For Iy = Y To 1 Step -1
					Line = UpCase(Rec<Iy>[1,Ix])
					Ix = Index(Line, Word, Count(Line,Word))
					If Ix Then
						If Not(Y = Iy And X <= Ix) Then
							Y = Iy
							X = Ix
							isFound = @TRUE
							Exit
						End
					End
					Ix = HUGE
				Next
			End Else
				Ix = X + 1
				For Iy = Y To Lines
					idx = Index(UpCase(Rec<Iy>[Ix,HUGE]), Word, 1)
					If idx Then
						Ix += idx - 1
						If Not(Y = Iy And X >= Ix) Then
							Y = Iy
							X = Ix
							isFound = @TRUE
							Exit
						End
					End
					Ix = 1
				Next
			End
		End Else
			!! スペースで始まる場合は単語単位の前方一致で検索
			If searchReverse Then
				Ix = X - 1
				For Iy = Y To 1 Step -1
					Line = Rec<Iy>
					Loop
						Line = Line[1,Ix]
						Ix = Index(Line, SearchString, Count(Line,SearchString))
						If Ix=0 Then
							Ix = HUGE
							Exit
						End Else
							If (Ix=1 Or Convert(PUNCS:".":@fm:@vm:@svm,"",Line[Ix-1,1])="") Then
								If Not(Y = Iy And X <= Ix) Then
									Y = Iy
									X = Ix
									isFound = @TRUE
									GoTo Search.Found
								End
							End
							Ix -= 1
						End
					Repeat
				Next
			End Else
				Ix = X + 1
				For Iy = Y To Lines
					Line = Rec<Iy>
					Loop
						idx = Index(Line[Ix,HUGE], SearchString, 1)
						If idx=0 Then
							Ix = 1
							Exit
						End Else
							Ix += idx - 1
							If (Ix=1 Or Convert(PUNCS:".":@fm:@vm:@svm,"",Line[Ix-1,1])="") Then
								Y = Iy
								X = Ix
								isFound = @TRUE
								GoTo Search.Found
							End
							Ix += 1
						End
					Repeat
				Next
			End
		End
		
Search.Found:
		!! 見つかった
		If isFound Then
			!! 検索単語を選択する
			BufInfo<BI.BLOCKSTART> = Y:@VM:X
			BufInfo<BI.BLOCKEND> = Y:@VM:X+Len(SearchString)
			keepSelection = True
			If Replacing Then
				
				!! エディタ画面の再描画
				crtBuff = ""
				GoSub Draw.Editor
				GoSub CRT.BUFF.FLUSH
				
				If firstFound Then
					firstFound = @FALSE
					HI.OFF = BG.BASE2
					PromptLine = FG.YELLOW:BG.BASE3:"Enter Replacement :" ; GoSub PromptLine
					inputBox = ""
					GoSub InputBox
					Replacement = inputBox
					HI.OFF = BG.BASE2
					PromptLine = FG.YELLOW:BG.BASE3:"(All or Verify) :"; GoSub PromptLine
					GoSub GetKey
					Ok = TrimF(UpCase(C[1,1]))
					If Ok = "A" Then
						!! 全単語置換
						skipVerify = @TRUE
						Y = 1 ; X = 1
						Continue
					End Else
						If Ok <> "V" Then Exit
					End
				End
				
				If skipVerify Then
					Ok = "Y"
				End Else 
					HI.OFF = BG.BASE2
					PromptLine = FG.YELLOW:BG.BASE3:"Replace This Selection (Y/N/All) :"; GoSub PromptLine
					GoSub GetKey
					Ok = UpCase(TrimF(C)[1,1])
				End
				
				Begin Case
					Case Ok = "Y"
						InsBuffer = Replacement
						GoSub InsertLines
					Case Ok = "N"
						X += 1
					Case Ok = "A"
						skipVerify = @TRUE
						Y = 1 ; X = 1
						Continue
					Case 1
						Exit
				End Case
				X -= 1
				BufInfo<BI.BLOCKSTART> = Y:@VM:X
				BufInfo<BI.BLOCKEND> = Y:@VM:X+Len(SearchString)
				keepSelection = True
				replaceCnt += 1
			End Else
				Exit
			End
		End Else
			!! 見つからなかった
			
			If Y = 1 And X = 1 Then
				StatusMessage = "Search Text Not Found"
				Top = 1
				Redraw = REDRAW.ALL
				Exit
			End
			If Replacing And skipVerify Then
				StatusMessage = replaceCnt:" Strings Replaced"
				keepSelection = False
				Exit
			End
			GoSub ShowWindow
			PromptLine = "Search Text Not Found - Start from ":(If searchReverse Then "Buttom" Else "Top"):"(Y) :" ; GoSub PromptLine
			GoSub GetKey
			If UpCase(C) = "Y" Then
				If searchReverse Then
					Y = Lines; X = Len(Rec<Lines>)
				End Else
					Y = 1 ; X = 1
				End
				BufInfo<BI.BLOCKSTART> = ""
				Continue
			End Else
				Exit
			End
		End
	Repeat
	
	Return

* **************************************************************************
* Act.ShowOutline - Show a list of Outlines
*-----------------------------------------------------------------------
Act.ShowOutline:
	
	blockStart = ""
	blockEnd = ""
	If BufInfo<BI.BLOCKSTART> Then
		GoSub GetSelBlock
	End
	
	If blockStart And blockStart<1> = blockEnd<1> Then
		!! 単語選択なら選択単語を含む行を抽出する
		a = blockStart<1>
		SWord = Rec<a>[blockStart<2>,blockEnd<2>-blockStart<2>]
	End Else
		SWord = BufInfo<BI.HIWORD> ;** 検索ハイライトの単語
	End
	choiceList = "" ;** アウトライン出力対象
	For I = 1 to Lines
		Line = Convert(char(9)," ",Rec<I>) ;** インデントはSP1とする
		
		If blockStart Then
			!! 選択範囲内の行を含める
			If blockStart<1> <= I And I <= blockEnd<1> Then
				choiceList<-1> = Line:@VM:I
				Continue
			End
		End
		
		If SWord#"" Then
			!! 検索ハイライトの行を含める
			If ignoreCase Then
				If Index(UpCase(Line),UpCase(SWord)) Then
					choiceList<-1> = Line:@VM:I
					Continue
				End
			End Else
				Ix = Index(Line,SWord)
				If Ix And Convert(PUNCS:".":@fm:@vm:@svm,"",Line[Ix-1,1])="" Then
					choiceList<-1> = Line:@VM:I
					Continue
				End
			End
		End
		
		!! Label
		word = Line[";",1,1][" ",1,1]["*",1,1]["!",1,1]
		If word Matches "1n0n":@VM:"1A0X':'" Then
			choiceList<-1> = Line:@VM:I
		End

		!! PROGRAM, SUBROUTINE, $INCLUDE
		lists = ""
		lists<-1> = "PROGRAM"
		lists<-1> = "SUBROUTINE"
		lists<-1> = "FUNCTION"
		lists<-1> = "CLASS"
		lists<-1> = "$INCLUDE"
		Convert @FM To @VM In lists
		a = CatS(lists,Reuse("..."))

		!! 修飾子を削る
		b = UpCase(Line)
		b = Change(b,"LOCAL","")
		b = Change(b,"PUBLIC","")
		b = Change(b,"PRIVATE","")
		b = Change(b,"SHARE","")
		b = Trimf(b)
		If b Matches a Then
			choiceList<-1> = Line:@VM:I
		End
	Next

	choiceOrgY = Int(Depth / 2) + 1
	tmpList = Fields(Convert(@VM,char(1),choiceList),char(1),2)
	Locate Y In tmpList By "AR" Setting choiceNo Else choiceNo -= 1
	
	!! カーソルがちょうど検索ハイライト文字の上なら初期値に入れる
	If SWord#"" Then
		If blockStart Then
			If blockStart<1> = blockEnd<1> Then
				filter = " ":SWord
			End Else
				filter = ""
				BufInfo<BI.BLOCKSTART> = ""
			End
		End Else
			!! 検索ハイライトの行を含める
			Line = Rec<Y>
			If ignoreCase Then
				If Upcase(Line[X,Len(SWord)])=UpCase(SWord) Then
					filter = SWord
				End
			End Else
				If Line[X,Len(SWord)]=SWord Then
					If Convert(PUNCS:".":@fm:@vm:@svm,"",Line[X-1,1])="" Then
						filter = " ":SWord
					End
				End
			End
		End
	End Else
		BufInfo<BI.BLOCKSTART> = ""
	End
	
	StLine.Y = choiceOrgY-1
	Redraw.StatusLine = @True
	crtBuff = ""
	GoSub PrintStatus.Impl
	GoSub CRT.BUFF.FLUSH
	
	!! 選択リストボックス初期化
	GoSub InitChoiceList
	choiceParse = @True
	Stack.XOffSet = XOffSet
	
	title = FG.YELLOW:" Outline"
	choiceSelection = ""
	Loop
		
		prevChoiceSelection = choiceSelection
		
		!! 選択リストボックス処理共通
		GoSub ProcChoiceList
		
		If choiceSelection#"" And prevChoiceSelection#choiceSelection Then
			!! 選択が切り替わったらプレビュー表示
			Top = choiceSelection<1,2> - Int(choiceOrgY/2) + 1
			If Top <= 0 Then Top = 1
			Redraw = @True
		End
		
		!! ソース画面再描画
		If Redraw Then
			crtBuff = ESC:"7" ;** カーソル位置の保存
			For I = 0 To choiceOrgY-2
				Row = Top+I
				Line = Rec<Row>
				If Row = choiceSelection<1,2> Then
					selection = 1:@FM:BIG
					LineWidth = winWidth
					Selection.Color = BG.BASE2:FG.BASE01
					Selection.Key.Color = HI.KEY.ON
					Selection.Tab.Color = FG.BASE3
					GoSub ParseLine2
					GoSub Get.Gyo
					crtBuff := @(0,Row - Top) ;* 行の開始
					crtBuff := BG.BASE2:FG.BASE01:Gyo:PLine:Selection.Color:@(-4)
				End Else
					GoSub ParseLine
					GoSub PrintLine
				End
			Next
			crtBuff := ESC:"8" ;** カーソル位置の復元
			GoSub CRT.BUFF.FLUSH
		End
		
		Redraw = @False
		
		!! キー入力待ち
		GoSub GetKey
		Begin Case
			Case actNo = A.OUTLINE
				GoSub ShowWindow
				GoTo Act.ShowOutline2
				
			Case actNo = A.WHEEL.UP
				If Top>1 Then
					Top -= 1
					Redraw = @True
				End
				
			Case actNo = A.WHEEL.DOWN
				If Top < Lines - Depth + SCROLLMERGINE + 1 Then
					Top += 1
					Redraw = @True
				End
				
			Case actNo = A.MOUSE
				GoSub Act.Mouse
				Exit
			
			!! Cancel
			Case actNo = A.CANCEL
				CurBuf = prevCurBuf
				actNo = 0
				XOffSet = Stack.XOffSet
				keepDP_X = DP_X
				Exit
			
			!!決定
			Case actNo = A.NEWLINE
				CurBuf = prevCurBuf
				If choiceSelection Then
					BufInfo<BI.BLOCKSTART> = ""
					BufInfo<BI.BLOCKEND> = ""
					GoSub StackJumpHistory
					Y = choiceSelection<1,2>
					Line = Rec<Y>
					!! ハイライト単語があればそのX位置にする
					If ignoreCase Then
						Ix = Index(UpCase(Line),UpCase(Word))
						If Ix Then X = Ix
					End Else
						Ix = Index(Line,Word)
						If Ix And Convert(PUNCS:".":@fm:@vm:@svm,"",Line[Ix-1,1])="" Then X = Ix
					End
					If Len(Line) < X Then
						X = Len(Line)+1
						keepDP_X = X
					End Else
						keepDP_X = DP_X
					End
					XOffSet = 1
				End
				Exit
		End Case
		
	Repeat
	
	choiceParse = @False
	If Not(Top < Y And Y < Top + Int(Depth / 2)) Then
		Top = Y - Int(Depth / 2)
	End
	Redraw = REDRAW.ALL
	
	Return

Act.ShowOutline2:
	
	blockStart = ""
	blockEnd = ""
	If BufInfo<BI.BLOCKSTART> Then
		GoSub GetSelBlock
	End
	
	If blockStart And blockStart<1> = blockEnd<1> Then
		!! 単語選択なら選択単語を含む行を抽出する
		a = blockStart<1>
		SWord = Rec<a>[blockStart<2>,blockEnd<2>-blockStart<2>]
	End Else
		SWord = BufInfo<BI.HIWORD> ;** 検索ハイライトの単語
	End
	choiceList = "" ;** アウトライン出力対象
	For I = 1 to Lines
		Line = Convert(char(9)," ",Rec<I>) ;** インデントはSP1とする
		
		If blockStart Then
			!! 選択範囲内の行を含める
			If blockStart<1> <= I And I <= blockEnd<1> Then
				choiceList<-1> = Line:@VM:I
				Continue
			End
		End
		
		If SWord#"" Then
			!! 検索ハイライトの行を含める
			If ignoreCase Then
				If Index(UpCase(Line),UpCase(SWord)) Then
					choiceList<-1> = Line:@VM:I
					Continue
				End
			End Else
				Ix = Index(Line,SWord)
				If Ix And Convert(PUNCS:".":@fm:@vm:@svm,"",Line[Ix-1,1])="" Then
					choiceList<-1> = Line:@VM:I
					Continue
				End
			End
		End
		
		!! Label
		word = Line[";",1,1][" ",1,1]["*",1,1]["!",1,1]
		If word Matches "1n0n":@VM:"1A0X':'" Then
			choiceList<-1> = Line:@VM:I
		End

		!! PROGRAM, SUBROUTINE, $INCLUDE
		lists = ""
		lists<-1> = "PROGRAM"
		lists<-1> = "SUBROUTINE"
		lists<-1> = "FUNCTION"
		lists<-1> = "CLASS"
		lists<-1> = "$INCLUDE"
		Convert @FM To @VM In lists
		a = CatS(lists,Reuse("..."))

		!! 修飾子を削る
		b = UpCase(Line)
		b = Change(b,"LOCAL","")
		b = Change(b,"PUBLIC","")
		b = Change(b,"PRIVATE","")
		b = Change(b,"SHARE","")
		b = Trimf(b)
		If b Matches a Then
			choiceList<-1> = Line:@VM:I
		End
	Next

	choiceOrgY = 0
	title = SBOLD:FG.BASE02:BG.YELLOW:" Outline"
	tmpList = Fields(Convert(@VM,char(1),choiceList),char(1),2)
	Locate Y In tmpList By "AR" Setting choiceNo Else choiceNo -= 1
	
	!! カーソルがちょうど検索ハイライト文字の上なら初期値に入れる
	If SWord#"" Then
		If blockStart And blockStart<1> = blockEnd<1> Then
			filter = " ":SWord
		End Else
			!! 検索ハイライトの行を含める
			Line = Rec<Y>
			If ignoreCase Then
				If Upcase(Line[X,Len(SWord)])=UpCase(SWord) Then
					filter = SWord
				End
			End Else
				If Line[X,Len(SWord)]=SWord Then
					If Convert(PUNCS:".":@fm:@vm:@svm,"",Line[X-1,1])="" Then
						filter = " ":SWord
					End
				End
			End
		End
	End
	
	!! 選択リストボックス初期化
	GoSub InitChoiceList
	choiceParse = @True
	Stack.XOffSet = XOffSet
	
	Loop
		
		!! 選択リストボックス処理共通
		GoSub ProcChoiceList
		
		!! キー入力待ち
		GoSub GetKey
		Begin Case
			Case actNo = A.OUTLINE
				GoSub ShowWindow
				GoTo Act.ShowOutline
			
			!! Cancel
			Case actNo = A.CANCEL
				CurBuf = prevCurBuf
				actNo = 0
				XOffSet = Stack.XOffSet
				Exit
			!!決定
			Case actNo = A.NEWLINE
				CurBuf = prevCurBuf
				If choiceSelection Then
					GoSub StackJumpHistory
					Y = choiceSelection<1,2>
					Top = Y - SCROLLMERGINE
					If Top <= 0 Then Top = 1
					X = 1
					!! ハイライト単語があればそのX位置にする
					If ignoreCase Then
						Ix = Index(UpCase(Rec<Y>),UpCase(Word))
						If Ix Then X = Ix
					End Else
						Ix = Index(Rec<Y>,Word)
						If Ix And Convert(PUNCS:".":@fm:@vm:@svm,"",Rec<Y>[Ix-1,1])="" Then X = Ix
					End
					keepDP_X = X
					XOffSet = 1
					Redraw = REDRAW.ALL
				End
				Exit
		End Case
		
	Repeat

	Redraw = REDRAW.ALL
	
	Return

* **************************************************************************
* Act.ShowWordHokan - Word Auto Complete
*-----------------------------------------------------------------------
Act.ShowWordHokan:
	
	!! 現在カーソル位置から単語の先頭までの単語を取得
	GoSub Get.CurrentWord
	
	!! 置換元を選択表示する
	If currentWord <> "" Then
		
		!! 単語置き換え範囲を
		BufInfo<BI.BLOCKSTART> = Y:@VM:stX
		BufInfo<BI.BLOCKEND> = Y:@VM:X
		
		!! 置換範囲を描画
		Row = Y
		GoSub ParseLine
		GoSub PrintLine
		GoSub PrintCursor
		GoSub CRT.BUFF.FLUSH
		
	End
	
	!! 単語を集める
	lineList = Rec
	GoSub Get.WordList
	
	InsBuffer = ""
	
	GoSub Core.ShowWordHokan
	
	If InsBuffer <> "" Then
		GoSub InsertLines
		BufInfo<BI.BLOCKSTART> = ""
	End
	
	Redraw = REDRAW.ALL
	
	Return

* --------------------------
* Get.CurrentWord
* currentWord [out]
* stX [out]
Get.CurrentWord:
	
	Line = Rec<Y>
	inX = If X > 1 Then X-1 Else 1
		
	!! 単語の先頭まで進む
	Loop
		ch = Line[inX,1]
	While ch <> "" And ch Matches "1A":@VM:"1N" Or Count("._$",ch)
		inX -= 1
		If inX <= 0 Then Exit
	Repeat
	
	!! 現在の単語を設定
	stX = inX + 1
	currentWord = Line[stX,X-stX]
	
	Return

Core.ShowWordHokan:
	
	choiceList = wordList
	
	If currentWord <> "" Then
		
		!! Auto Complete
		hitWord = ""
		choiceList.length = DCount(choiceList,@FM)
		currentWordU = UpCase(currentWord)
		For i = 1 To choiceList.length
			line = choiceList<i>
			If Index(UpCase(line),currentWordU,1) Then
				If hitWord Then
					!! 1つ以上見つかったので終了
					hitWord = ""
					Exit
				End
				!! 初めて見つかった
				hitWord = line
			End
		Next i
		If hitWord Then
			!! 1つだけ見つかった場合はその単語に自動補完
			GoSub GetWord
			If Word <> hitWord And currentWord <> hitWord Then
				InsBuffer = hitWord
				Return
			End
		End
		
	End

	!! 選択リストボックス初期化
	choiceOrgY = 0
	choiceNo = 1
	title = SBOLD:FG.BASE02:BG.YELLOW:" Words"
	filter = currentWord
	GoSub InitChoiceList
	
	Loop
		
		!! 選択リストボックス処理共通
		GoSub ProcChoiceList
		
		!! キー入力待ち
		GoSub GetKey
		Begin Case
			!! Cancel
			Case actNo = A.CANCEL Or actNo = A.WORD_HOKAN
				InsBuffer = ""
				actNo = 0
				Exit
			!! 決定
			Case actNo = A.NEWLINE
				If choiceSelection Then
					InsBuffer = choiceSelection
				End
				Exit
		End Case
		
	Repeat

	Return

* **************************************************************************
* Get.WordList     - 単語一覧取得
*   lineList [in]  - 検索対象
*   wordList [out] - 結果

Get.WordList:
	
	wordList = ""
	
	i.puncs = PUNCS
	o.puncs = Str(@FM,Len(i.puncs))
	
	!! 全行ループ
	lineList.len = DCount(lineList,@FM)
	For y = 1 To lineList.len
		line = lineList<y> ;** 1行
		line = Trim(Convert(Char(9)," ",line)) ;** Remove Tab Space
		
		If line And Not(Count("*!",line[1,1])) Then
			!! 空行とComment行でない
			
			If Count(Upcase(line),"INCLUDE") Then
				temp = Convert(" ",@FM,Trim(line))
				FindStr "INCLUDE" In Upcase(temp) Setting Ps Then
					ROL = temp[@FM,Ps+1,9]
					If ROL<2> = "" Then
						FileName = BufInfo<BI.FILE>
						ItemName = ROL<1>
					End Else
						FileName = ROL<1>
						ItemName = ROL<2>
					End
					incRec = Raise(Trans(FileName,ItemName,-1,"X"))
					If incRec Then
						!! インクルードレコードを後ろに追加
						lineList<-1> = incRec
						lineList.len += DCount(incRec,@FM)
					End
				End
			End
			
			!! 文字列リテラルの除去
			mline = ""
			line.len = Len(line)
			For i = 1 To line.len
				a = line[i,1]
				If Count(STRQTS,a) Then
					!! クォート文字が見つかったら次の対応文字まで進む
					b = Index(line[i+1,HUGE],a,1)
					i += If b Then b Else HUGE
				End Else
					mline := a
				End
			Next i
			
			!! マルチラインループ
			Convert ";" To @FM In mline
			Loop
				line = Trim(Remove(mline,s2))
				
				If line And Not(Count("*!",line[1,1])) Then
					
					!! 単語のループ
					words = Convert(i.puncs,o.puncs,line)
					Loop
						word = Remove(words,s3)
						If word Then
							ch = word[1,1]
							s = Seq(ch)
							If (36 = s) or (64 <= s And s <= 122) And currentWord <> word Then
								!! Alphabetで始まりフィルタと完全一致しないもの
								Locate word In wordList By "AL" Setting f Else
									Ins word Before wordList<f>
								End
							End
						End
					While s3
					Repeat
					
				End
				
			While s2
			Repeat
			
		End
		
	Next y
	
	!! バッファ内のファイル名も補完対象に加える
	For I = 1 To MAXWINDOWS
		If BufInfos(I)<BI.USED> Then
			word = BufInfos(I)<BI.FILE>
			Locate word In wordList By "AL" Setting f Else
				Ins word Before wordList<f>
			End
			word = BufInfos(I)<BI.ITEM>
			Locate word In wordList By "AL" Setting f Else
				Ins word Before wordList<f>
			End
		end
	Next
	
	Return

* **************************************************************************
* Act.GoLine

Act.GoLine: 
	Redraw = REDRAW.ALL
	HI.OFF = BG.BASE2
	prevY = Y ;** GoTo前のY位置
	If TgtFld Then
		!! フィールド指定モード
		fldCnt = Dcount(TgtFld,@FM)
		If BufInfo<BI.VALUEFIX> Then
			!! バリュー固定モード
			If fldCnt = 1 Then
				!! フィールド数が１つ
				PromptLine = FG.GREEN:BG.BASE3:"SubValue No :"
				GoSub PromptLine
				inputBox = ""
				GoSub InputBox
				Ok = TrimS(Convert(",",@FM,inputBox))
				vno = Ok<1>
			End Else
				!! フィールド数が複数
				PromptLine = FG.GREEN:BG.BASE3:"Value No (fno,svno) :"
				inputBox = ""
				GoSub InputBox
				Ok = TrimS(Convert(",",@FM,inputBox))
				Ok = IfS(NumS(Ok),Ok,Reuse(""))
				fno = Ok<1>
				vno = Ok<2>
			End
			
		End Else
			If fldCnt = 1 Then
				!! フィールド数が１つ
				fno = TgtFld<1,1>
				PromptLine = FG.GREEN:BG.BASE3:"Value No (vno[,svno]) :"
				GoSub PromptLine
				inputBox = ""
				GoSub InputBox
				Ok = TrimS(Convert(",",@FM,inputBox))
				Ok = IfS(NumS(Ok),Ok,Reuse(""))
				vno = Ok<1>
				svno = Ok<2>
			End Else
				PromptLine = FG.GREEN:BG.BASE3:"Value No (fno,vno[,svno]) :"
				inputBox = ""
				GoSub InputBox
				Ok = TrimS(Convert(",",@FM,inputBox))
				Ok = IfS(NumS(Ok),Ok,Reuse(""))
				fno = Ok<1>
				vno = Ok<2>
				svno = Ok<3>
			End
		End

		If fno And vno Then
			list = FieldS(Convert(@VM,",",TgtFld),",",1)
			Find fno In list Setting i Else
				!! 物理位置が見つからない
				Redraw.StatusLine = @TRUE
				StatusMessage = "Cannot find f-no"
				Return
			End
			GoSub StackJumpHistory
			lineno = i * vno
			If lineno > DCount(Rec,@fm) Then Return
			Y = lineno
			X = 1
			XOffSet = 1
			BufInfo<BI.BLOCKSTART> = Y:@VM:1
			BufInfo<BI.BLOCKEND> = Y:@VM:Len(Rec<Y>) + 1
			keepSelection = @TRUE
		End
		
	End Else
		PromptLine = FG.GREEN:BG.BASE3:"Line No (fno[,vno[,svno]]) :"
		GoSub PromptLine
		inputBox = ""
		GoSub InputBox
		Ok = inputBox
		If Ok = "" Then Return
		Ok = TrimS(Convert(",",@FM,inputBox))
		Ok = IfS(NumS(Ok),Ok,Reuse(""))
		fno = Ok<1>
		vno = Ok<2>
		svno = Ok<3>
		If fno And fno > 0 Then
			If fno > DCount(Rec,@fm) Then Return
			GoSub StackJumpHistory
			Y = fno
			X = 1
			XOffSet = 1
		End
		If vno And vno > 0 Then
			If Field(Rec<Y>,@VM,vno) Then
				X = Col1() + 1
				BufInfo<BI.BLOCKSTART> = Y:@VM:X
				BufInfo<BI.BLOCKEND> = Y:@VM:Col2()
				keepSelection = @TRUE
			End
		End
	End

	!! Goto Subvalue And Selection
	If svno And svno > 0 Then
		If Field(Rec<Y>[X,9999],@SVM,svno) Then
			x2 = X + Col2() - 1
			X = X + Col1()
			BufInfo<BI.BLOCKSTART> = Y:@VM:X
			BufInfo<BI.BLOCKEND> = Y:@VM:x2
			keepSelection = @TRUE
		End
	End

	!! 画面の中心にスクロールさせる
	If prevY <> Y Then
		Top = Y - Int(@CRTHIGH/2) + 1
		If Top < 1 Then Top = 1
	End
	
	Return

* **************************************************************************
* Act.GoDeclaration - 宣言元に行く

Act.GoDeclaration:
	
	Line = Rec<Y>
	
	!!
	!! INCLUE 行全体
	!!
	If Count(Upcase(Line),"INCLUDE") Then
		temp = Convert(" ",@FM,Trim(Line))
		FindStr "INCLUDE" In Upcase(temp) Setting Ps Then
			ROL = temp[@FM,Ps+1,9]
			If ROL<2> = "" Then
				FileName = BufInfo<BI.FILE>
				ItemName = ROL<1>
			End Else
				FileName = ROL<1>
				ItemName = ROL<2>
			End
			flg = Trans(FileName,ItemName,0,"X")
			If flg Then
				GoSub DoRead
				If Found Then
					GoSub ShowWindow
					Return
				End
			End
		End
	End
	
	GoSub GetWord
	If Word Then
		!!
		!! CALL
		!!
		If Count(Upcase(Line),"CALL") Then
			temp = Convert(" ",@FM,Trim(Line))
			FindStr "CALL" In Upcase(temp) Setting Ps Then
				len = Len(Word)
				ItemName = temp<Ps+1>[1,len]
				If ItemName = Word Then
					If Word[1,1] = "@" Then
						!! InDirect Call なので変数へジャンプ
						Word = Word[2,999]
					End Else
						GoSub Search.Program
						If flg Then
							GoSub DoRead
							If Found Then
								GoSub ShowWindow
								Return
							End
						End
					End
				End
			End
		End
		!!
		!! DEFFUN
		!!   TODO CALLING,LOCAL
		!!
		If Count(Upcase(Line),"DEFFUN") Then
			temp = Convert(" ",@FM,Trim(Line))
			FindStr "DEFFUN" In Upcase(temp) Setting Ps Then
				len = Len(Word)
				ItemName = temp<Ps+1>[1,len]
				If ItemName = Word Then
					GoSub Search.Program
					If flg Then
						GoSub DoRead
						If Found Then
							GoSub ShowWindow
							Return
						End
					End
				End
			End
		End
		
		!!
		!! ラベルJump
		!!
		If Word Matches "1A..." Then
			tmpY = 0
			tmpRec = Rec
			Loop
				FindStr Word:":" In tmpRec Setting Pos Then
					li = tmpRec<Pos>
					If Word:":" = Convert(CHAR(9):" ","",li)[1,Len(Word)+1] Then
						GoSub StackJumpHistory
						Y = tmpY + Pos
						Top = Y - 3
						X = 1
						Redraw = REDRAW.ALL
						Return
					End
					tmpY += Pos
					tmpRec = tmpRec[@FM,Pos+1,HUGE]
				End Else Exit
			Repeat
			FindStr "SUBROUTINE ":UpCase(Word) In UpCase(Rec) Setting Pos Then
				!! ローカルサブルーチンの可能性
				GoSub StackJumpHistory
				Y = Pos
				Top = Pos - 3
				X = 1
				Redraw = REDRAW.ALL
				Return
			End
		End
		
		!!
		!! 変数定数宣言元へJump
		!!
		Dim iRec(10),iRec.Cnt(10),iRec.Y(10)
		result = "" ;** 結果データ 1:File 2:X 3:Y
		sp = 1 ;** スタック位置
		iRec(sp) = Rec ;** 現在ファイルから開始
		GoSub Find.Definition
		If result Then
			GoSub StackJumpHistory
			If result<1> Then
				!! INCLUDE先のファイル
				FileName = result<1,1>
				ItemName = result<1,2>
				GoSub DoRead
				If Found Then
					GoSub ShowWindow
				End
			End
			Y = result<2>
			X = result<3>
			Redraw = REDRAW.ALL
		End

	End
	Return

Search.Program:

	FileName = BufInfo<BI.FILE> ;** 同一ファイルから検索
	flg = Trans(FileName,ItemName,0,"X")
	If flg Then Return
	
$IFNDEF U2__UNIVERSE
	Call !FINDPROG(rslt,ItemName)
	If rslt Then
		src.path = rslt<2>
		If src.path Then
			a = DCount(src.path,@DS)
			FileName = src.path[@DS,a-1,1]
			ItemName = src.path[@DS,a,1]
			flg = Trans(FileName,ItemName,0,"X")
			If flg Then Return
		
			flg = OSPATH(src.path,16)
			If flg Then
				FileName = "PATH:":src.path[@DS,1,a-1]
				Return
			End
		End
	End
	
$ENDIF

	Return

* **************************************************************************
* レコード内で対象変数の宣言位置を返す
* Input:  iRec - 検索対象レコード
*         iY   - Y位置
*         Word - 対象単語
* Output: result - Jump先結果 1:ファイル 2:Y位置 3:X位置
*-----------------------------------------------------------------------------
Find.Definition:
	
	iRec.Cnt(sp) = DCount(iRec(sp),@FM) ;** 最大行数
	iX = 1
	For iRec.Y(sp) = 1 To iRec.Cnt(sp)
		Line = iRec(sp)<iRec.Y(sp)>[iX,HUGE]
		
		!! $INCLUDE の場合は再帰的に探す
		If Count(Upcase(Line),"INCLUDE") Then
			temp = Convert(" ",@FM,Trim(Line))
			FindStr "INCLUDE" In Upcase(temp) Setting Ps Then
				ROL = temp[@FM,Ps+1,9]
				If ROL<2> = "" Then
					FileName = BufInfo<BI.FILE>
					ItemName = ROL<1>
				End Else
					FileName = ROL<1>
					ItemName = ROL<2>
				End
				If sp < 10 Then
					sp += 1 ;** next Stack
					iRec(sp) = Raise(Trans(FileName,ItemName,-1,"X"))
					GoSub Find.Definition
					sp -= 1;** back Stack
					If result Then
						!! 見つかった場合
						If Not(result<1>) Then
							!! このファイルで初めて見つかったので対象ファイルを格納する
							result<1> = FileName:@VM:ItemName
						End
						Return
					End
				End
			End
		End
		
		!! 完全一致する単語を見つける
		iX = Index(Line,Word,1)
		If iX Then
			lineList = Line
			currentWord = ""
			GoSub Get.WordList
			Find Word In wordList Setting pos Then
				result<2> = iRec.Y(sp)
				result<3> = iX
				Return
			End
			
			iX += 1
			Continue
		End
		iX = 1
	Next iRec.Y(sp)

	Return


* **************************************************************************
* Act.GoPrevJumpHist - 前のJump履歴を復元

Act.GoPrevJumpHist:

	If jumpHistoryPos <= 0 Then
		!! ジャンプ戻り前の位置を保存しておく
		GoSub GetJumpData
		currentJumpData = jumpData
	End
	If jumpHistory<jumpHistoryPos+1> >< "" Then
		jumpHistoryPos += 1 ;** 1つ前へ
		jumpData = Raise(jumpHistory<jumpHistoryPos>)
		GoSub RestoreFromJumpData
		If jumpData >< "" Then
			!! それ以前のJump履歴は打ち切りにする
			jumpHistory = jumpHistory[@FM,1,jumpHistoryPos]
		End
	End
	If jumpHistoryPos < 0 Then
		jumpHistoryPos = 0
	End
	
	Redraw = REDRAW.ALL

	Return

* **************************************************************************
* Act.GoNextJumpHist - 次のJump履歴を復元

Act.GoNextJumpHist:

	If jumpHistoryPos > 1 Then
		jumpHistoryPos -= 1 ;** 1つ次へ
		jumpData = Raise(jumpHistory<jumpHistoryPos>)
	End Else
		jumpHistoryPos = 0
		jumpData = Raise(currentJumpData)
	End

	GoSub RestoreFromJumpData
	
	Redraw = REDRAW.ALL

	Return

* **************************************************************************
* Act.Copy

Act.Copy:
	
	GoSub GET.SELECTION.STRING
	
	If selString = "" Then
		!! 選択がなければ行選択にする
		selString = Rec<Y>:CHAR(10)
		BufInfo<BI.BLOCKSTART> = Y:@VM:1
		BufInfo<BI.BLOCKEND> = Y+1:@VM:1
	End
	
	!! カーソルが行頭なら選択範囲を残す
	keepSelection = @TRUE
	StatusMessage = "copied"
	
Act.Copy.Impl:
	clipboard = selString ;** ローカルクリップボードに格納
		
	!! リモート端末に送信する
	If @TTY = 'console' Then
		GoSub ToWinClip
	End Else
$IFDEF U2__UNIVERSE
		result = ""
		retCode = ENCODE("Base64A", "1", selString, "1", result, "1")
$ELSE
		result = OCONV(OCONV(selString,"XUTF8"), "B64")
$ENDIF
		Crt ESC:"]52;;":result:CHAR(7):
	End
	
	Return

* **************************************************************************
* Act.Cut

Act.Cut:
	
	GoSub Act.Copy
	keepSelection = @FALSE
	If BufInfo<BI.BLOCKSTART> Then
		!! 選択中の物は削除する
		GoSub Act.DelCh
	End Else
		GoSub Act.DelLine
	End
	
	Return
	
* **************************************************************************
* Act.SendRemotePasteCmd

Act.SendRemotePasteCmd:
	If @TTY = 'console' Then
		GoSub FromWinClip
		GoTo Act.PasteLocal
	End Else
		!! リモート端末のクリップボードから取得を要求
		Crt ESC:"]52;0;?":CHAR(7):
	End
	keepSelection = True
	Return
	
* **************************************************************************
* Act.PasteLocal
* Act.Paste

Act.PasteLocal:
	InsBuffer = clipboard
Act.Paste:
	startPos = Y:@VM:X
	If BufInfo<BI.BLOCKSTART> Then
		GoSub GET.SELECTION.STRING
		If Convert(CHAR(13):CHAR(10):@FM,"",selString) = Convert(CHAR(13):CHAR(10):@FM,"",InsBuffer) Then
			!! 同じ行を複製したい場合があるので同一内容の場合は選択を解除
			BufInfo<BI.BLOCKSTART> = ""
		End Else
			GoSub GetSelBlock
			startPos = Lower(blockStart)
		End
	End
	If CurBuf = CMD_BUF Then
		tmp = Convert(CHAR(13):CHAR(10),@FM,InsBuffer)
		!! コマンド画面用特殊処理
		If Index(tmp,@FM) Then
			!! 複数行
			InsBuffer = ""
			cnt = DCount(tmp,@FM)
			For i=1 To cnt
				cl = tmp<i>
				!! コマンド
				If i=1 And X <= prmptLen+1 Then
					!! 先頭が行頭の場合にのみそのまま入れる
					InsBuffer := cl
				End Else
					!! それ以外は必ず改行
					InsBuffer := @FM:FMT(":",prmptLen:"R"):cl
				End
			Next i
		End
	End
	
	InsBuffer = Convert(@IM:@FM:@VM:@SM,CHAR(31):CHAR(10):CHAR(29):CHAR(28),InsBuffer)
	editCmd = ""
	If BufInfo<BI.BLOCKSTART> Then
		** 選択中
		editCmd<1> = BufInfo<BI.BLOCKEND, 1>
		editCmd<2> = BufInfo<BI.BLOCKEND, 2>
		editCmd<3> = BufInfo<BI.BLOCKSTART, 1>
		editCmd<4> = BufInfo<BI.BLOCKSTART, 2>
	End Else
		editCmd<1> = Y
		editCmd<2> = X
		If bOverlay Then
			editCmd<3> = Y
			editCmd<4> = X + (If X < Len(Rec<Y>) Then 1 Else 0)
		End Else
			editCmd<3> = ""
			editCmd<4> = ""
		End
	End
	editCmd<5> = InsBuffer
	editCmd<6> = If Index(InsBuffer,Char(10)) Then "0:1" Else ""
	GoSub StackEditCmd
	
	If CurBuf = CMD_BUF Then
		BufInfo<BI.BLOCKSTART> = ""
		BufInfo<BI.BLOCKEND> = ""
		keepSelection = False
	End Else If X = 1 Then
		!! カーソル位置が先頭の時は選択範囲を残す
		BufInfo<BI.BLOCKSTART> = startPos
		BufInfo<BI.BLOCKEND> = Y:@VM:X
		keepSelection = True
	End
	Return
	
* **************************************************************************
* Act.Undo

Act.Undo:
	
	If EditCmdStack<EditCmdPos> = "SAVED_POINT" Then EditCmdPos += 1 ;** １つ前に戻る
	editCmd = EditCmdStack<EditCmdPos,2> 
	If editCmd >< "" Then
		GoSub DoEditCmd
		EditCmdPos += 1 ;** １つ前に戻る
		Changed = If EditCmdStack<EditCmdPos> = "SAVED_POINT" Then False Else True
		Redraw = REDRAW.ALL
		prevY = ""
	End
	
	Redraw.StatusLine = @TRUE
	
	Return
	
* **************************************************************************
* Act.Redo

Act.Redo:

	If EditCmdPos > 1 Then 
		If EditCmdStack<EditCmdPos-1> = "SAVED_POINT" Then
			EditCmdPos -= 1 ;** １つ先に進む
		End
		EditCmdPos -= 1 ;** １つ先に進む
		editCmd = EditCmdStack<EditCmdPos,1>
		GoSub DoEditCmd
		If EditCmdStack<EditCmdPos-1> = "SAVED_POINT" Then
			Changed = False
			EditCmdPos -= 1 ;** １つ先に進む
		End Else
			Changed = True
		End
		Redraw = REDRAW.ALL
		prevY = ""
	End
	
	Redraw.StatusLine = @TRUE
	
	Return

* **************************************************************************
* Act.ShowBuffList - Print a list of the buffer

Act.ShowBuffList:

	!!
	!! 選択肢の構築
	!!
	listCnt = DCount(lruBuffList,@FM)
	choiceList = ""
	dispMaxLen = 0
	For I = 1 To listCnt
		no = lruBuffList<I>
		info = BufInfos(no)
		GoSub Get.FileSentence
		dispStr = Fmt(no,"2R"):"< "
		dispStr := fileSentence
		dispMaxLen = Max(dispMaxLen,Len(dispStr))
		choiceList<-1> = dispStr:@VM:no
	Next
	dispMaxLen = Max(dispMaxLen+4,Int(@CRTWIDE/2))
	For I = 1 To listCnt
		no = choiceList<I,2>
		A = Bufs(no)<1>
		If A#"" Then
			choiceList<I,1> = FMTDP(choiceList<I,1>,dispMaxLen:"L"):"| ":A
		End
	Next I
	
	choiceList<-1> = Trim(IfS(NotS(SubstringS(LRUOpenList,1,1)),SubstringS(LRUOpenList,2,999),""),@FM)
	
	choiceOrgY = Int(Depth / 2) + 1
	title = FG.BLUE:" Buffers"
!	choiceOrgY = 0
!	title = SBOLD:FG.BASE02:BG.BLUE:" Buffers"
	choiceNo = If DCount(choiceList,@FM) < 2 Then 1 Else 2 ;**   !! 初期値は１つ前のものにする
	
	StLine.Y = choiceOrgY-1
	Redraw.StatusLine = @True
	crtBuff = ""
	GoSub PrintStatus.Impl
	GoSub CRT.BUFF.FLUSH

	!! 選択リストボックス初期化
	filter = ""
	GoSub InitChoiceList
	
	Loop
		
		!! 選択リストボックス処理共通
		GoSub ProcChoiceList
		
		!! キー入力待ち
		GoSub GetKey
		Begin Case
			Case actNo = A.CANCEL ;** 抜ける
				actNo = 0
				GoSub Act.Reload
				Exit
			Case actNo = A.NEWLINE ;** 決定
				If choiceSelection Then
					Found = choiceSelection<1,2>
					IF Found Then
						!! バッファ切り替え
						GoSub StackJumpHistory
						GoSub ChangeBuf
						GoSub ShowWindow
						GoSub Act.Reload
					End Else
						!! 新規オープン
						cmdline = "READ.BUFFER ":choiceSelection
						bAutoCommand = @TRUE
						bAutoEditor = @TRUE
						GoSub Act.Exit
					End
				End
				Exit
			Case actNo = A.BUFFER ;** バッファ進める
				actNo = A.DOWN
			Case actNo = A.CLOSEBUF ;** この場でバッファを閉じる
				If choiceSelection Then
					Found = choiceSelection<1,2>
					GoSub StackJumpHistory
					GoSub ChangeBuf
					GoSub ShowWindow
					GoSub Act.CloseBuff
					If AllDone Then Exit 
					GoSub ShowWindow
					GoTo Act.ShowBuffList
				End
		End Case
		
	Repeat

	Redraw = REDRAW.ALL
	
	Return

* **************************************************************************
* Act.AutoIndent

Act.AutoIndent:
	
	!! 直前の行
	line = Rec<Y-1>
	GoSub GetIndentCnt
	prev.indent = line[1,indentLen-1]
	prev.indentCnt = indentCnt
	adjustIndentCnt = indentCnt ;** 揃えるインデント数
	

	autoClosing = "" ;** 自動閉じ処理

	!!
	!! 直前の行の内容によりインデントを増やす
	!!
	line = line[";",1,1] ;** 複数行の時にインデントが上がるケースはまずないので無視する
	line = TrimB(Convert(Char(9)," ",line)) ;** 正規化
	lineUC = UpCase(line)
	
	If lineUC Matches "... THEN":@VM:"... ELSE" Then
		!! IF分岐
		adjustIndentCnt += 1
		autoClosing = "End"
		If line Matches "... THEN":@VM:"... ELSE" Then
			autoClosing = "END"
		End Else If line Matches "... then":@VM:"... else" Then
			autoClosing = "end"
		END
	End Else If lineUC Matches "BEGIN... ...CASE":@VM:"... BEGIN... ...CASE" Then
		!! Switch分岐
		adjustIndentCnt += 1
		autoClosing = "End Case"
		If line Matches "...BEGIN...CASE" Then
			autoClosing = "END CASE"
		End Else If line Matches "...begin...case" Then
			autoClosing = "end case"
		End
	End Else If lineUC Matches "... CASE ..." Then
		!! Case分岐
		adjustIndentCnt += 1
	End Else If lineUC Matches "LOOP":@VM:"... LOOP" Then
		!! ループ
		adjustIndentCnt += 1
		autoClosing = "Repeat"
		If line Matches "...LOOP" Then
			autoClosing = "REPEAT"
		End Else If line Matches "...loop" Then
			autoClosing = "repeat"
		End
	End Else If lineUC Matches "FOR ...":@VM:"... FOR ..." Then
		!! Forループ
		a = line[Index(lineUC,"FOR",1),3]
		pattern = "...'":a:"'...1A0X' '..."
		varName = MatchField(line,pattern,4):MatchField(line,pattern,5)
		varName = varName["=",1,1]
		If UpCase(varName) = "EACH" Then
			!! EACHが来たらもう一度
			pattern = "...'":a:"'...'":varName:"'...1A0X' '..."
			varName = MatchField(line,pattern,6):MatchField(line,pattern,7)
		End
		If varName Then
			adjustIndentCnt += 1
			If line Matches "...FOR..." Then
				autoClosing = "NEXT ":varName
			End Else If line Matches "...for..." Then
				autoClosing = "next ":varName
			End Else
				autoClosing = "Next ":varName
			End
		End
	End
	
	!! 現在の行
	line = Rec<Y>
	GoSub GetIndentCnt
	!! インデント数が同じならスキップ
	If adjustIndentCnt = indentCnt Then
		Return
	End
	
	!! インデント挿入
	editCmd = ""
	editCmd<1> = Y
	editCmd<2> = 1
	editCmd<3> = Y
	editCmd<4> = indentLen 
	editCmd<5> = prev.indent:Str(IndentCh,(adjustIndentCnt-prev.indentCnt))
	editCmd<6> = ""
	GoSub StackEditCmd
	
	!! 自動閉じ文挿入
	If autoClosing Then
		
		!! 自動閉じ処理が不要な場合を探す
		For iY = Y+1 To Lines
			
			line = Rec<iY>
			GoSub GetIndentCnt
			
			!! 開始時のインデントから上がったら抜ける
			If indentCnt < adjustIndentCnt - 1 Then Exit
			
			!! 同一インデントの場合に自動閉じ処理が見つかったら不要である
			If indentCnt = adjustIndentCnt - 1 Then
				If UpCase(line[indentLen,9999]) Matches UpCase(autoClosing):"..." Then
					GoTo Skip.AutoClosing
				End
				Exit
			End
		Next iY
		
		
		nokoriStr = Rec<Y>[X,BIG]
		
		cmd = ""
		cmd<1> = Y
		cmd<2> = X
		cmd<3> = Y
		cmd<4> = X+Len(nokoriStr)
		cmd<5> = nokoriStr:Char(10):Str(IndentCh,adjustIndentCnt-1):autoClosing
		cmd<6> = "1"
		editCmd = cmd
		GoSub StackEditCmd
		
	Skip.AutoClosing:
	End
	
	Return

* **************************************************************************
* Act.Tab

Act.Tab:
	
	If BufInfo<BI.BLOCKSTART> Then
		** 一括インデント増やし
		GoSub Act.IncreaseIndent
	End Else
		!! カーソル位置がインデント位置なら自動インデント
		line = Rec<Y>
		GoSub GetIndentCnt
		If X < indentLen Then
			GoSub Act.AutoIndent
		End Else
			editCmd = ""
			editCmd<1> = Y
			editCmd<2> = X
			editCmd<3> = ""
			editCmd<4> = ""
			editCmd<5> = IndentCh
			editCmd<6> = ""
		
			GoSub StackEditCmd
		End
		
	End
	Return

* **************************************************************************
* Act.IncreaseIndent

Act.IncreaseIndent:
	
	editCmd = ""
	If Not(BufInfo<BI.BLOCKSTART>) Then
		blockStart = Y:@VM:1
		blockEnd = Y:@VM:1
	End Else
		GoSub GET.SELECTION.STRING
		
		!! 選択開始位置のインデント数を取得
		iY = BufInfo<BI.BLOCKSTART,1>
		line = Rec<iY>
		GoSub GetIndentCnt
		startIndentCnt = indentCnt
	End
	
	blockStart<2> = 1
	If blockEnd<2> > 1 Then
		blockEnd<1> += 1
		blockEnd<2> = 1
	End
	
	InsBuffer = ""
	
	cnt = blockEnd<1>
	If blockEnd<2> = 1 Then cnt -= 1
	For iY = blockStart<1> To cnt
		If startIndentCnt # 0 Then
			!! 開始インデントが0ではないのならインデントが0の物は残す
			line = Rec<iY>
			GoSub GetIndentCnt
			If indentCnt = 0 Then
				InsBuffer<-1> = line
				Continue
			End
		End
		InsBuffer<-1> = IndentCh:Rec<iY>
	Next iY
	
	editCmd = ""
	editCmd<1> = blockStart<1>
	editCmd<2> = blockStart<2>
	editCmd<3> = blockEnd<1>
	editCmd<4> = blockEnd<2>
	editCmd<5> = Convert(@FM,Char(10),InsBuffer):Char(10)
	editCmd<6> = Y:",":(If X=1 Then 1 Else (X+Len(IndentCh))):":1"
	
	GoSub StackEditCmd
	
	keepSelection = True
	
	Return

* **************************************************************************
* Act.DecreaseIndent

Act.DecreaseIndent:

	editCmd = ""
	
	If Not(BufInfo<BI.BLOCKSTART>) Then
		BufInfo<BI.BLOCKSTART> = Y:@VM:X
		BufInfo<BI.BLOCKEND> = Y:@VM:X+1
	End
	GoSub GetSelBlock

	blockStart<2> = 1
	If blockEnd<2> > 1 Then
		blockEnd<1> += 1
		blockEnd<2> = 1
	End
	
	InsBuffer = ""
	
	cnt = blockEnd<1>
	If blockEnd<2> = 1 Then cnt -= 1
	For iY = blockStart<1> To cnt
		If Rec<iY>[1,1]=Char(9) Then
			InsBuffer<-1> = Rec<iY>[2,99999]
		End Else
			InsBuffer<-1> = Rec<iY>
		End
	Next iY

	editCmd = ""
	editCmd<1> = blockStart<1>
	editCmd<2> = blockStart<2>
	editCmd<3> = blockEnd<1>
	editCmd<4> = blockEnd<2>
	editCmd<5> = Convert(@FM,Char(10),InsBuffer):Char(10)
	editCmd<6> = Y:",":(X-1):":1"
	
	GoSub StackEditCmd

	keepSelection = True
	Return	

* **************************************************************************
* Act.ShiftTab

Act.ShiftTab:
	
	GoSub Act.DecreaseIndent
	
	Return

* **************************************************************************
* Act.InsFMC

Act.InsFMC:
	
	Return
	
* **************************************************************************
* Act.InsVMC

Act.InsVMC:
	
	Return

* **************************************************************************
* Act.InsSMC

Act.InsSMC:
	
	Return

* **************************************************************************
* Act.InsTMC

Act.InsTMC:
	
	Return

* **************************************************************************
* Act.NewLine

Act.NewLine:
	
	editCmd = ""
	If BufInfo<BI.BLOCKSTART> Then
		** 選択中
		editCmd<1> = BufInfo<BI.BLOCKEND, 1>
		editCmd<2> = BufInfo<BI.BLOCKEND, 2>
		editCmd<3> = BufInfo<BI.BLOCKSTART, 1>
		editCmd<4> = BufInfo<BI.BLOCKSTART, 2>
	End Else
		editCmd<1> = Y
		editCmd<2> = X
		editCmd<3> = Y
		editCmd<4> = Len(Rec<Y>)+1
	End

	editCmd<5> = CHAR(10)
	editCmd<6> = ""
	
	If Rec<Y>[X,1] >< "" Then
		!! 行の途中での改行処理
		editCmd2 = ""
		editCmd2<1> = Y+1
		editCmd2<2> = 1
		editCmd2<3> = ""
		editCmd2<4> = ""
		editCmd2<5> = Rec<Y>[X,HUGE]
		editCmd2<6> = "1"
		editCmd := @FM:editCmd2
	End
	
	GoSub StackEditCmd

	If BufInfo<BI.PARSETYPE> = PARSE.BASIC Then
		!! 自動インデント処理
		GoSub Act.AutoIndent
	End

	Return

* **************************************************************************
* Act.InsTemplate

Act.InsTemplate:
	Return

* **************************************************************************
* Act.InsCommentOut

Act.InsCommentOut:
	tmpX = X ;** X位置を維持する
	tmpLen = Len(Rec<Y>)

	StBlock = BufInfo<BI.BLOCKSTART,1>
	EdBlock = BufInfo<BI.BLOCKEND,1>
	If StBlock<1> > EdBlock<1> Then tmp = StBlock; StBlock = EdBlock; EdBlock = tmp
	
	If BufInfo<BI.BLOCKEND,2>=1 Then EdBlock -= 1
	If Not(StBlock) Then
		StBlock = Y
		EdBlock = Y
	End
	editCmd = ""
	For Z = StBlock To EdBlock
		cmd = ""
		cmd<6> = "0"
		IF ParseType = PARSE.PARA THEN
			If Rec<Z>[1,1] = "*" Then
				** コメント外す
				cmd<1> = Z
				cmd<2> = 1
				cmd<3> = Z
				cmd<4> = 1 + IF Rec<Z>[1,2] = "* " THEN 2 ELSE 1
				cmd<5> = ""
			End Else
				** コメント付ける
				cmd<1> = Z
				cmd<2> = 1
				cmd<3> = ""
				cmd<4> = ""
				cmd<5> = "* "
			End
			editCmd<-1> = cmd
		END IF ParseType = PARSE.BASIC THEN
			If Rec<Z>[1,1] = "!" Then
				** コメント外す
				cmd<1> = Z
				cmd<2> = 1
				cmd<3> = Z
				cmd<4> = 2
				cmd<5> = ""
			End Else
				** コメント付ける
				cmd<1> = Z
				cmd<2> = 1
				cmd<3> = ""
				cmd<4> = ""
				cmd<5> = "!"
			End
			editCmd<-1> = cmd
		END
	Next
	keepSelection = @TRUE
	GoSub StackEditCmd
	X = tmpX + (Len(Rec<Y>) - tmpLen)
	Return

* **************************************************************************
* Act.GoDive

Act.GoDive:
	
	If BufInfo<BI.VALUEFIX> Then Return ;** SubValueまでで終わり
	
	!! 現在のバッファを親にする
	ParentBufNo = CurBuf
	!! アイテム情報は現状を引き継ぐ
	FileName = BufInfo<BI.FILE>
	ItemName = BufInfo<BI.ITEM>
	If BufInfo<BI.FIELDFIX> Then
		!! SubValueにDive
		inY = Y
		GoSub GetDAPos
		DiveValuePos = vPos
		FldInfo = BufInfo<BI.FIELDFIX>
	End Else
		!! ValueにDive
		FldInfo = "F":Y ;** 現在のカーソル行をターゲットにする
		If TgtFld Then
			If FldInfo Then
				inY = Y
				GoSub GetDAPos
				If TgtFld<fIdx,7> Then
					FldInfo = TgtFld<fIdx,7> ;** WITH ASSOC
				End Else
					FldInfo = TgtFld<fIdx,2> ;** ID指定
				End
			End	Else
				If TgtFld<Y,7> Then
					FldInfo = TgtFld<Y,7> ;** WITH ASSOC
				End Else
					FldInfo = TgtFld<Y,2> ;** ID指定
				End
			End
		End
	End
	GoSub DoRead
	GoSub DoShowDictInfo
	Redraw = REDRAW.ALL
	Return

* **************************************************************************
* Act.ShowHelp

Act.ShowHelp: 
	GoSub GetWord
	If Word = "" Then
		Return
	End
	HelpText = ""
$IFDEF U2__UNIVERSE
	HelpFiles = "BASIC.HELP.JP|BASIC.HELP|SYS.HELP"
$ELSE
	HelpFiles = "SW_HANYO"
$ENDIF
	For HelpNo = 1 To Dcount(HelpFiles,"|")
		Open Field(HelpFiles,"|",HelpNo,1) To HELPFL Then
			Read helpRec From HELPFL, UpCase(Word) Else
				Read helpRec From HELPFL, UpCase(Word):"()" Else
					Read helpRec From HELPFL, Word Else
						Read helpRec From HELPFL, Word:".TXT" Else
							helpRec = ""
						End
					End
				End
			End
			If helpRec >< "" Then HelpText<-1> = helpRec
			Close HELPFL
		End
	Next HelpNo
	If HelpText = "" Then
		StatusMessage = "Cannot find help for ": Word ; Redraw.PrintLine = True 
		Return
	End
	Text = HelpText
	GoSub ShowText
	Return

* **************************************************************************
* Act.Reload

Act.Reload:
	
	FileName = BufInfo<BI.FILE>
	ItemName = BufInfo<BI.ITEM>
	PathName = BufInfo<BI.PATHNAME>
	
	If IsNew Then Return
	
	If FileName Match "'#'1N":@VM:"'#'10" Then
		!! 選択リストから開く
		GoTo ReadItem
	End
	
	!! レコード格納先ファイルのオープン
	GoSub Common.OpenFile
	IF FILEINFO(FL,3)=4 THEN
		IN.OSBS = ItemName
		GOSUB GET.OSBS
	END ELSE
		OUT.OSBS = ItemName
	END
	Read TempRec From FL,OUT.OSBS Else TempRec = ""
	GoSub Common.CloseFile
	
	Convert CHAR(10):CHAR(13) To '' In TempRec ;** 改行コードが残っていたら自動除外
	
	If TempRec >< StartRec Then
		!! 初めのレコードと違いがある
		!! 変更ありなら自分の変更を破棄するか判断させる
		If AllDone Then
			If Changed Then
				Print "Record previously changed by another, Are you sure you want to destroy your modification? (Y) :":
			End Else
				Print "Record previously changed by another, Do you want to reload this item? (Y) :":
			End
			Input C
		End Else
			If Changed Then
				PromptLine = BG.RED:FG.BASE3:"Record previously changed by another, Are you sure you want to destroy your modification? (Y) :"
			End Else
				PromptLine = BG.CYAN:FG.BASE3:"Record previously changed by another, Do you want to reload this item? (Y) :"
			End
			GoSub PromptLine
			GoSub GetKey
		End
		If UpCase(C) = "Y" Else Return
		
		cmdline = "READ.BUFFER ":If PathName<>"" And FileName[1,5]="PATH:" Then PathName Else FileName:" ":ItemName
		bAutoCommand = @TRUE
		bAutoEditor = @TRUE
		GoSub Act.Exit
		Changed = @False
		GoSub Act.CloseBuff
	End Else
		Redraw = REDRAW.ALL
	End
	
	!! ロック処理の再実行をしておく
	If BufInfo<BI.LOCKED> Then
		If Not(IsNew) And Not(ReadOnly) Then
			BufInfo<BI.LOCKED> = @FALSE
			GoSub DoLock.Impl
		End
	End
	
	Return

* **************************************************************************
* Act.Save

Act.Save:
	GoSub SaveItem
	Return

* **************************************************************************
* Act.Compile

Act.Compile:
	
	If BufInfo<BI.PARSETYPE> = PARSE.BASIC Then
		If Changed Then GoSub CheckSave
		FileName = BufInfo<BI.FILE>
		ItemName = BufInfo<BI.ITEM>
$IFDEF U2__UNIVERSE
		cmdline = "BASIC ":FileName:" ":ItemName
$ELSE
		cmdline = "BASIC ":FileName:" ":ItemName:" DEBUGGING CHANGED"
$ENDIF
		cmdline<-1> = "PAUSE"
		bAutoCommand = @TRUE
		bAutoEditor = @true
		GoSub Act.Exit
	End
	Return

* **************************************************************************
* Act.Run

Act.Run:

	If BufInfo<BI.PARSETYPE> = PARSE.BASIC Then
		FileName = BufInfo<BI.FILE>
		ItemName = BufInfo<BI.ITEM>
$IFDEF U2__UNIVERSE
		cmdline = "BASIC ":FileName:" ":ItemName
$ELSE
		cmdline = "BASIC ":FileName:" ":ItemName:" CHANGED DEBUGGING"
$ENDIF
		cmdline<-1> = "RUN ":FileName:" ":ItemName
	End Else If BufInfo<BI.PARSETYPE> = PARSE.PARA Then
		rec = Rec
		GoSub Conv.rec2cmdlines
		cmdline = cmdlines
	End
	cmdline<-1> = "PAUSE"
	bAutoCommand = @TRUE
	bAutoEditor = @true
	GoSub Act.Exit
	Return

Conv.rec2cmdlines:
	cnt = DCount(rec,@FM)
	If cnt=1 Then Return
	cmdlines = ""
	For i=2 To cnt
		cl = rec<i>
		If cl[1]="_" Then
			Loop
			While cl[1]="_"
				cl = cl[1,Len(cl)-1]
				i += 1
				cl := @VM:rec<i>
			Repeat
		End
		cmdlines<i> = cl
	Next
	Return

* **************************************************************************
* Act.Mouse
Act.Mouse:
	If MOUSE<4>="M" Then
		!! クリックした位置にカーソルを移動
		Y = Top + MOUSE<3> - 1
		Line = Rec<Y>
		keepDP_X = MOUSE<2> - biInfoWide.lineNo
		GoSub GetX.From.keepDPX
		X = outX
		If MOUSE<1>="2" Then
			keepSelection = @TRUE
		End
		Redraw = REDRAW.ALL
	End
	Return

* **************************************************************************
* Act.ScrollUp

Act.ScrollUp:
	If Top>1 Then
		Top -= 1
!		If IS.CONSOLE Then
!			crtBuff := @(0,PY):@(-3):@(0,0):@(-17)
!			Redraw.StatusLine = @TRUE
!		End Else
!			crtBuff := ESC:"[1;":Depth:"r":ESC:"[T":ESC:"[1;":@CRTHIGH:"r"
!		End
!		Redraw<-1> = Top
	End
	Return

* **************************************************************************
* Act.ScrollDown

Act.ScrollDown:
	If Top < Lines - Depth + SCROLLMERGINE + 1 Then
		Top += 1
!		If IS.CONSOLE Then
!			crtBuff := @(0,PY):@(-3):@(0,0):@(-18)
!			Redraw.StatusLine = @TRUE
!		End Else
!			crtBuff := ESC:"[1;":Depth:"r":ESC:"[S":ESC:"[1;":@CRTHIGH:"r"
!		End
!		Redraw<-1> = Depth + Top - 1
	End
	Return

* **************************************************************************
* Act.Action

Act.Action:
	GoSub Action
	Return

* **************************************************************************
* Act.Exit

Act.Exit:
	AllDone = True ;** Exit Main Loop
	Return

* **************************************************************************
* Act.CloseBuff

Act.CloseBuff:
	
	If Changed And Not(ReadOnly) Then
		PromptLine = BG.RED:FG.BASE3:"Record has changed - Enter ! to Force Close :"; GoSub PromptLine
		GoSub GetKey
		If C >< "!" Then Return
	End

	FileName = BufInfo<BI.FILE>
	ItemName = BufInfo<BI.ITEM>
	
	!! ロックを外す
	If BufInfo<BI.LOCKED> And FileName >< "" And ItemName >< "" Then
		Open FileName To FL Then
			IF FILEINFO(FL,3)=4 THEN
				IN.OSBS = ItemName
				GOSUB GET.OSBS
			END ELSE
				OUT.OSBS = ItemName
			END
			Release FL,OUT.OSBS
			Close FL
		End
	End

	!! 現在のバッファ終了  
	BufInfo<BI.USED> = False
	
	!! lruBuffListからCurBufをすべて削除
	flgs = EqS(lruBuffList,Reuse(CurBuf))
	lruBuffList = IfS(flgs,Reuse(""),lruBuffList)
	lruBuffList = Convert(' ',@FM,Trim(Convert(@FM,' ',lruBuffList)))

	!! オープンフラグを消す
	Find CurBuf In SubstringS(LRUOpenList,1,1) Setting f Then
		LRUOpenList<f>[1,1] = "0"
	End

	!! 次のバッファ
	Found = lruBuffList<1>
	If Found="" Then
		GoSub Act.Exit
	End Else
		CurBuf = Found
		GoSub ChangeBuf
	End
	Return

* **************************************************************************
* Act.CloseBuff

Act.AllCloseBuf:
	
	If lruBuffList >< "" Then
		PromptLine = "Ara you sure Close all Buffer ? : Enter ! to Force ->"; GoSub PromptLine
		GoSub GetKey
		If C >< "!" Then Return
	End
	
	!! 変更のないバッファを破棄
	Found = False
	For I = 1 To MAXWINDOWS Until Found
		If BufInfos(I)<BI.USED> then
			If BufInfos(I)<BI.CHANGED> And Not(BufInfos(I)<BI.READONLY>) Then
				Found = True
			End Else
				BufInfos(I)<BI.USED> = @FALSE
			End
		End
	Next
	If Found then
		PromptLine = "There are changed items, Are you sure Close all Buffer ? : Enter ! to Force ->"; GoSub PromptLine
		If C >< "!" Then Return
		!! 強制的にすべて破棄
		For I = 1 To MAXWINDOWS
			BufInfos(I)<BI.USED> = @FALSE
		Next
	End
	
	GoSub Act.Exit
	Return

* **************************************************************************
* Act.ToggleCaseInvert - 大文字<->小文字切り替えフラグの切り替え

Act.ToggleCaseInvert:
	
	bInvert = Not(bInvert)
	Perform "PTERM CASE ":If bInvert Then "INVERT" Else "NOINVERT"
	
	Return

* **************************************************************************
* テーマカラー設定を読み込む

Load.Theme:
	!! TODO @HOME\sish_theme.ini があればそれを読み込む
	Crt THEME.COLOR.SETTINGS: ;** SISH.SETTING.H を事前に読み込んでおく
	Return

* **************************************************************************
* Act.SwitchTheme (背景色の入れ替え)

Act.SwitchTheme:

	A = FG.BASE3; FG.BASE3 = FG.BASE03; FG.BASE03 = A
	A = FG.BASE2; FG.BASE2 = FG.BASE02; FG.BASE02 = A
	A = FG.BASE1; FG.BASE1 = FG.BASE01; FG.BASE01 = A
	A = FG.BASE0; FG.BASE0 = FG.BASE00; FG.BASE00 = A
	A = BG.BASE3; BG.BASE3 = BG.BASE03; BG.BASE03 = A
	A = BG.BASE2; BG.BASE2 = BG.BASE02; BG.BASE02 = A
	A = BG.BASE1; BG.BASE1 = BG.BASE01; BG.BASE01 = A
	A = BG.BASE0; BG.BASE0 = BG.BASE00; BG.BASE00 = A
	
	theme = Not(theme)
	
	Redraw = REDRAW.ALL
	
	RETURN

*-----------------------------------------------------------------------------
*カーソル位置から単語の先頭までを削除する
*-----------------------------------------------------------------------------
Act.DelBackWord:

	GoSub Act.SelPrevWord
	
	editCmd = ""
	editCmd<1> = BufInfo<BI.BLOCKSTART, 1>
	editCmd<2> = BufInfo<BI.BLOCKSTART, 2>
	editCmd<3> = Y
	editCmd<4> = X
	editCmd<5> = ""
	editCmd<6> = "1" ;** 選択範囲がX=1の時はカーソルX位置をキープする
	GoSub StackEditCmd
	
	keepSelection = @FALSE
	
	Return

Act.DelNextWord:
	
	!! 単語選択
	GoSub GetWord
	If BufInfo<BI.BLOCKSTART> Then
		GoSub GetSelBlock
		BufInfo<BI.BLOCKSTART,1> = blockStart<1>
		BufInfo<BI.BLOCKSTART,2> = blockStart<2>
		BufInfo<BI.BLOCKEND,1> = Y
		BufInfo<BI.BLOCKEND,2> = EOW
	End Else
		BufInfo<BI.BLOCKSTART,1> = Y
		BufInfo<BI.BLOCKSTART,2> = X
		BufInfo<BI.BLOCKEND,1> = Y
		BufInfo<BI.BLOCKEND,2> = EOW
	End

	GoSub Act.DelCh
	
  Return

*-----------------------------------------------------------------------------
*  カーソル位置が単語の途中なら単語の末端へ移動
*  それ以外なら次の単語の先頭位置へ移動
*-----------------------------------------------------------------------------
Move.NextWord:
	!! 単語の終端まで移動
	GoSub GetWord
	If Word Then
		If X # SOW Then
			!! 単語の途中なので単語の末端へ移動
			!! 変数として利用できる "._$%@" も区切りとする
			prev.ch = ""
			Loop
				X += 1
				ch = Convert(Char(9):@FM:@VM:@SVM,Space(4),Line[X,1])
			Until ch = ""
			Until Count("._$%@ #=:;<>()[]{}/*+-,'\":'"',ch)
			Until ch = UpCase(ch) And prev.ch # UpCase(prev.ch)
				prev.ch = ch
			Repeat
			Return
		End
		Loop
			X += 1
			ch = Convert(Char(9):@FM:@VM:@SVM,Space(4),Line[X,1])
		Until ch = ""
		Until Count(" #=:;<>()[]{}/*+-,'\":'"',ch)
		Repeat
	End Else
		ch = Convert(Char(9):@FM:@VM:@SVM,Space(4),Line[X,1])
	End
	
	!! 次の単語の先頭を探す
	If Line[X,1] = "" Then Return
	X += 1
	If Line[X,1] = "" Then Return
	prevKwd = Count("#=:;<>()[]{}/*+-,'\":'"',ch)
	Loop
		ch = Convert(Char(9):@FM:@VM:@SVM,Space(4),Line[X,1])
		If ch = "" Then X-=1; Exit
		kwd = Count("#=:;<>()[]{}/*+-,", ch)
		If prevKwd And kwd Else
			If ch <> " " Then Exit
		End
		prevKwd = kwd
		X += 1
	Repeat  
		
	Return


*-----------------------------------------------------------------------------
*  カーソル位置が単語の途中なら単語の先頭へ移動
*  それ以外なら前の単語の先頭位置へ移動
*-----------------------------------------------------------------------------
Move.PrevWord:
	GoSub GetWord
	Line = Rec<Y>
	Line.len = Len(Line)
	If Word = "" Or type <> 1 Or X = SOW Or X = Line.len+1 Then
		!! カーソルが単語の開始位置または行の最終にある場合は
		!! 前の単語の先頭位置に移動する（高速移動）
		Line = Line[1,X]
		finX = X
		If X = Line.len+1 Then finX -= 1
		X = 0
		tmpX = 1
		Loop
			GoSub Move.NextWord
			If X >= finX Then Exit ;** 開始位置を超えたら抜ける
			tmpX = X
		Repeat
		X = tmpX ;** 直前の位置が答え
	End Else
		!! カーソルが単語の途中にある場合は
		!! 単語の区切り "._$%@" とキャメルケースを考慮に入れる（低速移動）
		prevX = X
		prev.ch = ""
		Loop
			X -= 1
		Until X = 0
			ch = Convert(Char(9):@FM:@VM:@SVM,Space(4),Line[X,1])
		Until ch = ""
		Until Count("._$%@ #=:;<>()[]{}/*+-,'\":'"',ch)
			If ch = UpCase(ch) And prev.ch # UpCase(prev.ch) Then
				X -= 1
				Exit
			End
			prev.ch = ch
		Repeat
		X += 1
		If prevX = X Then
			!! カーソルが動かなかった場合は１つ動かして再度ロジックを走らす
			X -= 1
			GoSub Move.PrevWord
		End
	End

	Return

*-----------------------------------------------------------------------------
* 指定の行文字列のインデント数を返す
* Input: line
* Output: indentCnt - インデント数
*         indentLen - インデントの文字列長
*-----------------------------------------------------------------------------
GetIndentCnt:
	
	!! スペースに統一して計算する
	lineLen = Len(line)
	indentCnt = 0
	indentLen = 1
	!! 行頭からのコメントは無視
	Loop
		ch = line[indentLen,1]
		If ch = "" Or Not(Count("*!",ch)) Then Exit
		indentLen += 1
		indentCnt += 1
	Repeat
	Loop
		ch = line[indentLen,1]
		If ch > CHAR(32) Or ch = "" Then Exit
		indentLen += 1
		indentCnt += (If ch = Char(9) Then STDTAB Else 1) 
	Repeat
	If indentCnt > 0 Then indentCnt = indentCnt / STDTAB
	
	Return

*-----------------------------------------------------------------------------
* 指定の行文字列のインデント数を返す
* Input:  dirPath - パス
* Output:    list - @FM区切り
*-----------------------------------------------------------------------------
GetDirList:
$IFNDEF U2__UNIVERSE
  TEMP.PATH = SYSTEM(38):(If OS.GATES Then "\" Else "/"):"SISH.DIR.":@USERNO
	TEMP.PATH.CMD = TEMP.PATH:".cmd"
	TEMP.PATH.OUT = TEMP.PATH:".out"

	OpenSeq TEMP.PATH.CMD Encoding "UTF8" To fp Else Create fp Else Abort "Cannot create temp file -> ":TEMP.PATH
	
	batch = ""
	If OS.GATES Then
		d = DQuote(Convert('/"','\',dirPath))
		batch<-1> = "chcp 65001"
		batch<-1> = "dir /b /a:d ":d:" > ":TEMP.PATH.OUT
		batch<-1> = "echo : >> ":TEMP.PATH.OUT
		batch<-1> = "dir /b /a:-d ":d:" >> ":TEMP.PATH.OUT
		batch = Change(batch,@FM,CHAR(13):CHAR(10))
	End Else
		d = dirPath
		batch<-1> = "ls -F ":d:" 2> /dev/null | grep / > ":TEMP.PATH.OUT
		batch<-1> = "echo : >> ":TEMP.PATH.OUT
		batch<-1> = "ls -F ":d:" 2> /dev/null | grep -v / >> ":TEMP.PATH.OUT
		batch = Change(batch,@FM,CHAR(10))
		!! 実行権限を付与
		TEMP.PATH.CMD = "chmod 744 ":TEMP.PATH.CMD:" && ":TEMP.PATH.CMD
	End

	WriteSeq batch To fp Else Abort "Cannot Write"
	
	WEOFSeq fp
	CloseSeq fp
	
	OS.Execute TEMP.PATH.CMD Silent
	
	list = ""
	OpenSeq TEMP.PATH.OUT Encoding "UTF8" To fp Then
		d = "D"
		Loop
			ReadSeq line From fp Else Exit
			If line[1,1] = ":" Then d = "" Else
				list<-1> = Convert("*/","",line):@VM:d
			End
		Repeat
	End
	CloseSeq fp
$ENDIF
Return

** Windowsのクリップボード
ToWinClip:
$IFNDEF U2__UNIVERSE
	TEMP.PATH = SYSTEM(38):"\SISH.CLIP.":@USERNO

	OpenSeq TEMP.PATH Encoding "UTF8" To fp Else Create fp Else Abort "Cannot create temp file -> ":TEMP.PATH
	
	batch = Change(clipboard,@FM,CHAR(13):CHAR(10))
	WriteBlk batch To fp Else Abort "Cannot Write"
	WEOFSeq fp
	CloseSeq fp
	
	OS.Execute "chcp 65001 & clip < ":TEMP.PATH Silent
	
	OSDelete TEMP.PATH
	
$ENDIF
Return

FromWinClip:
$IFNDEF U2__UNIVERSE
	TEMP.PATH = SYSTEM(38):"\SISH.CLIP.":@USERNO
	
	If HAS.PASTE.EXE Then
		OS.Execute 'chcp 65001 > NUL & ':HAS.PASTE.EXE:' > ':TEMP.PATH
		OSRead clipboard from TEMP.PATH Then
			clipboard = ICONV(clipboard,"XUTF8")
			OSDelete TEMP.PATH
		End
	End Else
		OS.Execute 'mshta.exe "vbscript:Execute("str=window.clipboardData.getData(""text""):CreateObject(""Scripting.FileSystemObject"").GetStandardStream(1,true).Write(str^&""""):close")" > ':TEMP.PATH
		OSRead clipboard from TEMP.PATH Then
			clipboard = ICONV(clipboard,"XUTF16.L")
			OSDelete TEMP.PATH
		End
	End
	
$ENDIF
Return

** 画面更新 (in: crtBuff)
CRT.BUFF.FLUSH:
	If IS.CONSOLE Then
		Crt @(-32):crtBuff:@(-31):
	End Else
		Crt CSI:'?25l':crtBuff:CSI:'?25h':
	End
Return
End
*
* Local variables:
* mode: unibasic
* End:
