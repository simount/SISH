Program SISH
**========================================================================================
**
**  FUNCTION
**
**    SImount Shell (Beta)
**    
**    Operate like UnixShell when edit commandline and Screen Editor
**
**    Please read the "README.adoc" for more information
**
**  Support Platform
**
**    * OpenQM 3.2.x or later
**    * UniVerse 11.2 or later
**
**  DATE
**
**    2017/05/23
**  
**  AUTHOR
**    
**    Kazuya Kosaku <kosaku@simount.com>
**  
**  LICENSE
**  
**    Copyright (C) 2017  SImount <info@simount.com>
**    
**    MIT License
**
**========================================================================================

Equ SISH.VERSION To "[ SISH v0.17.0 ]"

$IFDEF U2__UNIVERSE
	!! For UniVerse
	$INCLUDE UNIVERSE.INCLUDE TERMINFO
	$INCLUDE UNIVERSE.INCLUDE ATFUNCTIONS.H
	
	EQU ACCOUNT.FILE To "UV.ACCOUNT"
	EQU SAVEDLISTS.FILE To "&SAVEDLISTS&"
	EQU STACK.FILE To "stacks"
$ELSE
	!! For OpenQM compatibility
	
	$CATALOGUE SISH GLOBAL

	$MODE CASE.SENSITIVE,CONDITIONAL.STATEMENTS,UV.LOCATE
	
	$INCLUDE SYSCOM KEYS.H
	$INCLUDE SYSCOM TERMINFO.H
	
	!! 関数名の単純の置換
	EQU FMTDP Lit "FMTDW"
	EQU LenDP Lit "DISPLAY.WIDTH"
	EQU LenSDP Lit "DISPLAY.WIDTHS"
	EQU UniSeq Lit "Seq"
	
	EQU KEY.MOVE.CURSOR.UP To TermInfo(T$KEY.UP)
	EQU KEY.MOVE.CURSOR.DOWN To TermInfo(T$KEY.DOWN)
	EQU KEY.MOVE.CURSOR.LEFT To TermInfo(T$KEY.LEFT)
	EQU KEY.MOVE.CURSOR.RIGHT To TermInfo(T$KEY.RIGHT)
	EQU KEY.MOVE.CURSOR.TO.HOME To TermInfo(T$KEY.HOME)
	EQU KEY.MOVE.CURSOR.TO.LAST.LINE To TermInfo(T$KEY.END)
	EQU KEY.FUNCTION.1 To TermInfo(T$KEY.F1)
	EQU KEY.FUNCTION.2 To TermInfo(T$KEY.F2)
	EQU KEY.FUNCTION.3 To TermInfo(T$KEY.F3)
	EQU KEY.FUNCTION.4 To TermInfo(T$KEY.F4)
	EQU KEY.FUNCTION.5 To TermInfo(T$KEY.F5)
	EQU KEY.FUNCTION.6 To TermInfo(T$KEY.F6)
	EQU KEY.FUNCTION.7 To TermInfo(T$KEY.F7)
	EQU KEY.FUNCTION.8 To TermInfo(T$KEY.F8)
	EQU KEY.FUNCTION.9 To TermInfo(T$KEY.F9)
	EQU KEY.FUNCTION.10 To TermInfo(T$KEY.F10)
	EQU KEY.FUNCTION.11 To TermInfo(T$KEY.F11)
	EQU KEY.FUNCTION.12 To TermInfo(T$KEY.F12)
	EQU KEY.INSERT.LINE To TermInfo(T$KEY.IL)
	
	EQU ACCOUNT.FILE To "QM.ACCOUNTS"
	EQU SAVEDLISTS.FILE To "$SAVEDLISTS"
	EQU STACK.FILE To "stacks"
$ENDIF

*
* 定数定義
*

!! 論理定数
EQU True To 1
EQU False To 0
EQU BIG To 999
EQU HUGE To 9999999

!! キーコード
EQU BEL To Char(7)
EQU LF To Char(10)
EQU CR To Char(13)
EQU ESC To Char(27)
EQU CS.DEL to char(127)
EQU CTRL.A To Char(1)
EQU CTRL.B To Char(2)
EQU CTRL.C To Char(3)
EQU CTRL.D To Char(4)
EQU CTRL.E To Char(5)
EQU CTRL.F To Char(6)
EQU CTRL.G To Char(7)
EQU CTRL.H To Char(8)
EQU CTRL.I To Char(9)
EQU CTRL.J To Char(10)
EQU CTRL.K To Char(11)
EQU CTRL.L To Char(12)
EQU CTRL.M To Char(13)
EQU CTRL.N To Char(14)
EQU CTRL.O To Char(15)
EQU CTRL.P To Char(16)
EQU CTRL.Q To Char(17)
EQU CTRL.R To Char(18)
EQU CTRL.S To Char(19)
EQU CTRL.T To Char(20)
EQU CTRL.U To Char(21)
EQU CTRL.V To Char(22)
EQU CTRL.W To Char(23)
EQU CTRL.X To Char(24)
EQU CTRL.Y To Char(25)
EQU CTRL.Z To Char(26)
EQU CRLF To CR:LF

!! 制御シーケンス
Equ CSI To ESC:'['
Equ ESC.CUR.TOP To CSI:"1;2H" ;** カーソルを画面のトップに持ってくる制御
Equ ESC.CRT.MOVE_NEXT_LINE To CRLF
Equ ESC.CRT.CLEAR To CSI:"1;2H":CHAR(8):CSI:"0J"

!! OS Switch
Equ OS.GATES To SYSTEM(91)

* Actions
* 組み込みアクションが追加されるなら必ずメンテナンスする
*
	Equ A.LEFT To 1
	Equ A.RIGHT To 2
	Equ A.UP To 3
	Equ A.DOWN To 4
	Equ A.HOME To 5
	Equ A.END To 6
	Equ A.NEXTPAGE To 7
	Equ A.PREVPAGE To 8
	Equ A.NEXTHALF To 9
	Equ A.PREVHALF To 10
	Equ A.NEXTWORD To 11
	Equ A.PREVWORD To 12
	Equ A.NEXTSTMT To 13
	Equ A.PREVSTMT To 14
	Equ A.NEXTCHAR To 15
	Equ A.PREVCHAR To 16
	Equ A.TOP To 17
	Equ A.BOTTOM To 18
	Equ A.SEL_LEFT To 19
	Equ A.SEL_RIGHT To 20
	Equ A.SEL_UP To 21
	Equ A.SEL_DOWN To 22
	Equ A.SEL_HOME To 23
	Equ A.SEL_END To 24
	Equ A.SEL_NEXTWORD To 25
	Equ A.SEL_PREVWORD To 26
	Equ A.SEL_NEXTSTMT To 27
	Equ A.SEL_PREVSTMT To 28
	Equ A.SEL_NEXTPAGE To 29
	Equ A.SEL_PREVPAGE To 30
	Equ A.SEL_NEXTHALF To 31
	Equ A.SEL_PREVHALF To 32
	Equ A.SEL_NEXTCHAR To 33
	Equ A.SEL_PREVCHAR To 34
	Equ A.SEL_TOP To 35
	Equ A.SEL_BOTTOM To 36
	Equ A.SCROLL_MID To 37
	Equ A.NEWLINE To 38
	Equ A.INSCHAR To 39
	Equ A.DELETELINE To 40
	Equ A.BACKSPACE To 41
	Equ A.DELETECHAR To 42
	Equ A.CUT To 43
	Equ A.COPY To 44
	Equ A.SEND_PASTE To 45
	Equ A.PASTE To 46
	Equ A.PASTE_LOCAL To 47
	Equ A.UNDO To 48
	Equ A.REDO To 49
	Equ A.SEL_ALL To 50
  Equ A.SEL_EXPAND To 51
	
** 共通入力アクションの追加ポイント
	Equ ENUM.INPUT.ACTION.LAST To 51

  Equ A.CANCEL To 52
  Equ A.TAB To 53
  Equ A.SHIFT_TAB To 54
  Equ A.THEME To 55
  Equ A.INSVMC To 56
  Equ A.INSSMC To 57
  Equ A.INSTMC To 58
  Equ A.TEMPLATE To 59
  Equ A.COMMENT To 60
  Equ A.SEARCH To 61
  Equ A.REPEAT To 62
  Equ A.REVERSE To 63
  Equ A.REPLACE To 64
  Equ A.BUFFER To 65
  Equ A.OUTLINE To 66
  Equ A.GOLINE To 67
  Equ A.GO_DECLARATION To 68
  Equ A.NEXTJUMP To 69
  Equ A.PREVJUMP To 70
  Equ A.SAVE To 71
  Equ A.HELP To 72
  Equ A.COMPILE To 73
  Equ A.RELOAD To 74
  Equ A.ACTION To 75
  Equ A.EXIT To 76
  Equ A.CLOSEBUF To 77
  Equ A.DIVE To 78
  Equ A.CASEINVERT To 79
  Equ A.FIT.TERM To 80
  Equ A.WORD_HOKAN To 81
* ↑ここに追加していく
  Equ ACTION.ENUM.LAST To 82

!! 外部設定の読み込み
$INCLUDE SISH.SETTING.H

** ================================================================================
** Shell Main
** ================================================================================
Shell.Main:

*--------------------------------------------------------------------------
*   Full Screen Editor System
*--------------------------------------------------------------------------
	EQU Rec To Bufs(CurBuf)                            ;** 編集対象レコード
	EQU X To Xs(CurBuf)                                ;** カーソルX位置(内部)
	EQU DP_X To DP_Xs(CurBuf)                          ;** 表示カーソルX位置
	EQU Y To Ys(CurBuf)                                ;** カーソルY位置
	EQU Top To Tops(CurBuf)                            ;** スクロールY位置
	EQU XOffSet To XOffSets(CurBuf)                    ;** スクロールX位置
	EQU Lines To RecLines(CurBuf)                      ;** 最大行数
	EQU EditCmdStack To EditCmdStacks(CurBuf)          ;** UndoRedoスタック
	EQU EditCmdPos To EditCmdPoss(CurBuf)              ;** UndoRedoスタック位置
	EQU StartRec To StartRecs(CurBuf)                  ;** 編集開始時点レコード
	EQU DIRec To DIRecs(CurBuf)                        ;** 辞書情報レコード
	EQU TgtFld To TgtFlds(CurBuf)                      ;** 編集対象フィールド
	
	!! シェルと共用
	EQU cmdline To Bufs(52)
	EQU curPos To Xs(52)
	
	!! Buffer Information
	EQU BI.USED To 1
	EQU BI.FILE To 2
	EQU BI.ITEM To 3
	EQU BI.NEW To 4
	EQU BI.CHANGED To 5
	EQU BI.BLOCKSTART To 6
	EQU BI.BLOCKEND To 7
	EQU BI.READONLY To 8
	EQU BI.BOOKMARK To 9
	EQU BI.HIWORD To 10
	EQU BI.WIDE To 11
	EQU BI.CAPTURE To 12
	EQU BI.PARSETYPE To 13
	EQU BI.ACCOUNT To 14
	EQU BI.LOCKED To 15
	EQU BI.FIELDFIX To 16
	EQU BI.VALUEFIX To 17
	EQU BI.PBUFNO To 18
	EQU BI.INDENTTYPE To 19
	EQU BI.INDENTSIZE To 20
	
	EQU BufInfo To BufInfos(CurBuf)
	EQU Changed To BufInfo<BI.CHANGED>
	EQU IsNew To BufInfo<BI.NEW>
	EQU ReadOnly To BufInfo<BI.READONLY>
	EQU BookMark To BufInfo<BI.BOOKMARK>
	EQU IndentType To BufInfo<BI.INDENTTYPE>
	EQU STDTAB To BufInfo<BI.INDENTSIZE>
	EQU STDINDENT TO STDTAB * 1        ; * other indents
	EQU STDFIRSTINDENT To 0

	EQU biInfoWide To Sum(BufInfo<11>) ;* 情報エリア横幅
	EQU biInfoWide.lineNo To BufInfo<11,1> ;* 行数エリア横幅
	EQU biInfoWide.dict To BufInfo<11,2> ;* 辞書表示エリア横幅
	
	EQU CMD.STACK.SIZE To 1000 ;** コマンドスタックのサイズ
	EQU MAXWINDOWS To 50
	EQU BUFFS To 52
	EQU CMD_BUF To BUFFS
	COMMON /SISH.EDITOR/ initEnvEDS,lruBuffList,jumpHistory,jumpHistoryPos,currentJumpData,CurBuf,BufInfos(BUFFS),Bufs(BUFFS),Ys(BUFFS),Xs(BUFFS),DP_Xs(BUFFS),Tops(BUFFS),XOffSets(BUFFS),RecLines(BUFFS),EditCmdStacks(BUFFS),EditCmdPoss(BUFFS),StartRecs(BUFFS),ys(BUFFS),TgtFlds(BUFFS),DIRecs(BUFFS)
	If initEnvEDS Else
		initEnvEDS = @TRUE
		lruBuffList = "" ; !! バッファの直近順List
		jumpHistory = "" ; !! ジャンプ履歴
		jumpHistoryPos = 0 ; !! ジャンプ履歴位置
		currentJumpData = "" ;** 現在のジャンプデータ
		CurBuf = 1
		Mat BufInfos = ""
		Mat Bufs = ""
		Mat Xs = 0
		Mat DP_Xs = 0
		Mat Ys = 0
		Mat Tops = 0
		Mat XOffSets = 1
		Mat EditCmdStacks = ""
		Mat EditCmdPoss = 1
		Mat StartRecs = ""
		Mat DIRecs = ""
		Mat TgtFlds = ""
	End
	
	
  EQU CRT.BUFF.FLUSH Lit "ESC:'[?12l':ESC:'[?25l':crtBuff:ESC:'[?25h'" ;** <--- カーソル消すと処理が遅くなってしまう
!! 	EQU CRT.BUFF.FLUSH Lit "crtBuff" 

	Equ Depth Lit "(@CRTHIGH - 2)"
	Equ Width Lit "(@CRTWIDE - biInfoWide)"
	
	EQU AddKeyWord Lit "KEYWORDS<-1> = "
	EQU AddFunc Lit "FUNCS<-1> = "
	
	EQU SI.NONE To '0'
	EQU SI.LABEL To '1'
	EQU SI.COMMENT To '2'
	EQU SI.NUMBER To '3'
	EQU SI.STRING To '4'
	EQU SI.KEY To '5'
	EQU SI.OPERATOR To '6'
	EQU SI.FUNCTION To '7'
	EQU SI.DIRECTIVE To '8'
	EQU SI.SELECTION To '9'
	EQU SI.SEARCH To 'a'
	EQU SI.DOC To 'b'
	EQU SI.VMK To 'c'
	EQU SI.SMK To 'd'
	EQU SI.KAKKO To 'e'
	
	EQU PARSE.DATA To "Item"
	EQU PARSE.BASIC To "Basic"
	EQU PARSE.PROC To "Proc"
	EQU PARSE.PARA To "PA"

	MY_COMMAND = Trim(@COMMAND[' ',1,1]) ;** 自コマンド名(SISH)

	keyQueue = ""         ;** 右クリックペースト用のキーキュー
	inputBox = ""         ;** １行入力用バッファ
	clipboard = ""        ;** ローカルクリップボードファ
	kakko = ""
	moveChar = "" ;** Move To Char モード
	pendingCh = ""
	bPrevEsc = @FALSE ;** 前回のキー入力が制御シーケンスだったかどうか
	bOverlay = @FALSE ;** Insert/Overlay Mode
	editerCmd = ""
		
	crtBuff = ""
	
	EQU REDRAW.ALL To -1
	Redraw = 0
	
	GoSub InitTerminal
	GoSub Initialise  
	
	EQU PY Lit "@CRTHIGH - 2"
	EQU LISTDEPTH Lit "Depth - 2"
	
	* セッショングローバル
	COMMON /SISH.SHELL/ cmdStack,ShInfo
	
	Equ bAutoTermSize To ShInfo<1> ;** 端末サイズ自動設定機能 ON/OFF
	Equ prevPath To ShInfo<3> ;** 前回のアカウントパス
	Equ bInvert To ShInfo<4> ;** 大文字小文字変換機能 ON/OFF
	Equ bTimer To ShInfo<5> ;** 時間計測機能 ON/OFF
	Equ theme To ShInfo<6> ;** テーマNo
	
	If cmdStack=0 Then
		cmdStack = ""
		bAutoTermSize = @TRUE
		bInvert = @TRUE ;** デフォルト反転モード
		bTimer = @FALSE
		theme = 1
		Crt SISH.VERSION
	End
	
	cmdStackList.DispCnt = @CRTWIDE ;** コマンドスタックリスト表示のデフォルト値
	prevPath = "" ;** 前回のアカウントパスは一度クリアする
	
	** DICT.DESCの取得
	Open 'DICT', 'VOC' To fpD.VOC Else Stop "Cannot Open 'DICT.VOC'"
	Read descIType From fpD.VOC,'DESC' Else Stop "Cannot Read 'DESC' in 'DICT.VOC'"
	Read typeIType From fpD.VOC,'TYPE' Else Stop "Cannot Read 'TYPE' in 'DICT.VOC'"
	Close fpD.VOC
	
	** VOCファイルを開く
	Open 'VOC' To VOC Else Abort
$IFDEF U2__UNIVERSE
	** UV.ACCOUNTを見れるようにする
	ReadV dummy From VOC,'UV.ACCOUNT',0 Else
		rec = "Q"
		rec<2> = "UV"
		rec<3> = "UV.ACCOUNT"
		Write rec To VOC,'UV.ACCOUNT' On Error Abort
	End
$ENDIF

$IFNDEF U2__UNIVERSE
	!! SERVER一覧を取得
	serverListIds = ""
	serverList = ""
	Execute "LIST.SERVERS" CAPTURING out
	out = out[@FM,2,*]
	For Each line In out
		line = Trim(line)
		serverListIds<-1> = line[' ',1,1]
		serverList<-1> = line[' ',5,1]:"@":line[' ',2,1] ;** user@host
	Next line
$ENDIF

	prevListStackCmd = ".L" ;** 直前のstack一覧コマンド
	prevFileName = "" ;** 直前のコマンドのファイル名

	bFirstCurTop = @TRUE ;** カーソルを画面の最上部に初めての移動か
	bAutoCommand = @FALSE ;** コマンドを実行してエディタに戻る
	bAutoEditor = @FALSE ;** 自動でエディタ起動
	kakkoChList = \()[]<>{}''""\:"\\" ;** 対応する括弧定義

	!! Themeの反映
	If theme Then
		noThemePopup = @TRUE
		GoSub Set.Theme
	End
	noThemePopup = @FALSE
	
	!! 大文字小文字変換の初期化
	Perform "PTERM CASE ":If bInvert Then "INVERT" Else "NOINVERT"

Shell.Input.Begin:

	** Ctrl+C のIntruputを @28(Ctrl+\ or Break) に変更
	** 自動ページングをON
$IFDEF U2__UNIVERSE
	Perform "PTERM INTR ^Q"
	assign 0 to system(1005)
	PROMPT.STR = ">"
$ELSE
	x = PTERM(3,28)
	x = PTERM(4,@FALSE)
	PROMPT.STR = ":"
$ENDIF

	bDispCandidate = @FALSE
	candidateMode = ""
	candidateFilter = ""
	slistCacheType = ""
	pageNum = 0
	
	dictName = ""

	cmdlineRows = 0
	curY = 0
	curPos = 1
	cmdline = ""
	cmdStackPos = 1
	cmdStackPage = ""
	
	selCurStart = 0
	selCurEnd = 0
	bIncSearch = "" ;** インクリメンタルサーチモード
	iSearchText = ""
	
	!!
	!! 表示の初期化
	!!
	
	** 端末のウィンドウタイトルを変更する
	If prevPath >< @PATH Then
		** 前のパスと違っている時のみ実施する
		prevPath = @PATH
		account = Convert(CHAR(92),'/',prevPath)
		logname = @LOGNAME
$IFNDEF U2__UNIVERSE
		logname = @HOSTNAME:"\":logname
$ENDIF
		title = account['/',DCount(account,'/'),1]:" @ ":logname:" (":System(18):")"
		Crt CHAR(27):"]2;":title:CHAR(7):
		
		** VOCファイルを開きなおす
		Close VOC
		Open 'VOC' To VOC Else Abort
		
		** コマンドスタック保存ファイルから復元を試みる
$IFDEF U2__UNIVERSE
		OpenPath STACK.FILE To fpStack Then
$ELSE
		OpenPath STACK.FILE ENCODING "UTF8" To fpStack Then
$ENDIF
			logFile = @LOGNAME:"$":MY_COMMAND
			cmdStack = "<NEWLINE>"
			Read stack From fpStack,logFile Then
				stack.cnt = DCount(stack,@FM)
				If stack.cnt > 10000 Then
					!! 10000件までにする
					Write stack[@FM,stack.cnt-10000,10000] To fpStack,logFile On Error Print "Cannot Write Stack Log -> ":STACK.FILE:"/":logFile
				End
				Loop
					cmdline = stack<stack.cnt,1>[21,999999]
					retCode = stack<stack.cnt,2>
$IFDEF U2__UNIVERSE
					cond = (cmdline And cmdline[1,1] <> ' ')
$ELSE
					!! OpenQM版は取り込むコマンドの精度を上げる
					cond = (cmdline And cmdline[1,1] <> ' ' cmdline And cmdline[1,1] <> ' ' And (retCode >= 0 Or retCode = -15 Or retCode = -7))
$ENDIF
					If cond Then
						cmdline = Trim(cmdline)
						Find cmdline In cmdStack Setting pos Then
						End Else
							cmdStack<-1> = cmdline ;** 重複を省いて追加
						End
					End
				While stack.cnt >= 0 And DCount(cmdStack,@FM) <= CMD.STACK.SIZE
					stack.cnt -= 1
				Repeat
			End Else
				Write "" To fpStack,logFile On Error Print "Cannot Write Stack Log -> ":STACK.FILE:"/":logFile
			End
		End
	End

	CurBuf = CMD_BUF
	
	Y = 1
	X = 1
	Top = 1
	XOffSet = 0
	Lines = If Rec = "" Then 1 Else DCount(Rec,@fm)
	EditCmdStack = "SAVED_POINT"
	EditCmdPos = 1
	crtBuff = ""
	C = "" ;** 入力文字

*
* キータイプのループ
*
Shell.KeyLoop.Start:
	Loop
		
		!! １行に固定する
		Y = 1
		
		Rec = Rec<1>
		Line = Rec
		
AutocommanLoop.Start:
		!!
		!! 表示
		!!
		!! カーソルを先頭に持ってきてクリア
		crtBuff = ""
		GoSub Clear.Cmdline.Crt
		crtBuff := HI.SHELL.ON
		
		!! プロンプト部分の構築
		prmptStr = "si"
		If bInvert Then prmptStr = UpCase(prmptStr)
		
		!! インクリメンタルサーチ
		If bIncSearch Then
			prmptStr := "(":bIncSearch:"-iSearch)`":iSearchText:"`"
		End
		
		!! コマンドスタック位置表示
		If cmdStackPos > 1 Then
			no = cmdStackPos-1
			prmptStr := " ":Fmt(no,"R%":Maximum(Len(no):@FM:2))
		End
		prmptStr := PROMPT.STR
		If System(11) Then prmptStr := PROMPT.STR ;** アクティブな選択リストあり
		
		!! コマンド行表示 (Auto Wrap) 
		cl = prmptStr : cmdline<1>
		curIndex = Len(prmptStr) + curPos - 1
		tmpX = 0
		tmpY = 0
		clLen = Len(cl)
		For i = 1 To clLen 
			c = cl[i,1]
			dispLen = LenDP(c)
			nextX = tmpX + dispLen;
			If nextX > @CRTWIDE-1 Then
				* 改行
				tmpY += 1
				tmpX = 0
				crtBuff := ESC.CRT.MOVE_NEXT_LINE
			End
			crtBuff := c
			tmpX += dispLen
			
			If i = Len(prmptStr) Then crtBuff := HI.SHELL.OFF
			
			!! カーソル位置
			If i = curIndex Then curX=tmpX; curY=tmpY
			
			!! 選択範囲
			If BufInfo<BI.BLOCKSTART> Then
				blockSt = BufInfo<BI.BLOCKSTART, 2>
				blockEd = BufInfo<BI.BLOCKEND, 2>
				If blockSt > blockEd Then tmp = blockSt; blockSt = blockEd; blockEd = tmp
				i2 = i - Len(prmptStr) + 1
				If i2 = blockSt Then crtBuff := HI.SELECT.ON
				If i2 = blockEd Then crtBuff := SGR.ALL.OFF
			End
			
		Next
		cmdlineRows = tmpY ;** 行数を格納
		
		* カーソル表示
		crtBuff := CSI:"G":CSI:curX:"C"
		If cmdlineRows - curY > 0 Then
			* @(IT$CUU)が正しいエスケープシーケンスを出力しないので、VT100のシーケンス直書き
			crtBuff := CSI:(cmdlineRows - curY):'A'
		End
		
		** CRTフラッシュ処理
		Crt CRT.BUFF.FLUSH:
		
		!! 自動的にコマンドを実行するモード
		If bAutoCommand Then GoTo Run.Command
		If bAutoEditor Then bAutoEditor = @FALSE; GoTo Launch.Editor
		
		prevC = C ;** 前回の入力文字を保持
		
		!! キー入力待ち
		GoSub GetKey
		
		Changed = False ;** コマンドラインの編集を感知する為
		
		keepSelection = @FALSE
		
		!!
		!! キーハンドリング
		!!
		Begin Case
			Case actNo = A.UP
				GoSub ACTION.CMDSTACK.NEXT
			Case actNo = A.DOWN 
				GoSub ACTION.CMDSTACK.BACK
			Case actNo = A.TOP
				cmdStackPos = 2
				GoSub ACTION.CMDSTACK.BACK
			Case actNo = A.BOTTOM
				cmdStackPos = DCount(cmdStack,@FM) - 1
				GoSub ACTION.CMDSTACK.NEXT
		** 文字入力系  
			Case actNo = A.TAB
				
				startCandidateMode = ""
				
				* 補完候補表示
				If bDispCandidate Then
					
					pageNum = 0
					
					If candidateMode = "FLATREC" Then
						candidateMode = "FIELD"
					End Else If candidateMode = "FIELD" Then
						candidateMode = "FILE"
					End Else If candidateMode = "FILE" Then
						candidateMode = "VOC"
					End Else If candidateMode = "VOC" Then
						candidateMode = ""
					End
					
				End Else
					candidateMode = "FLATREC"
					!! 連続でタブが押された
					If bFirstCurTop Then
						If prevC = C Then
							!! 前回の入力がTABなら候補表示へ
							bDispCandidate = @TRUE
						End
					End Else
						bDispCandidate = @TRUE
					End
				End
				
				GoSub TAB.HOKAN
				
			Case actNo = A.NEXTHALF Or actNo = A.NEXTPAGE
				pageNum += 1
				GoSub TAB.HOKAN
				
			Case actNo = A.PREVHALF Or actNo = A.PREVPAGE
				pageNum -= 1
				GoSub TAB.HOKAN
				
			Case actNo = A.REPEAT ;** F3 (filter)
				If Not(bFirstCurTop) Then
					PromptLine = "Input Filter (Word or Pattern)->" ; GoSub PromptLine
					inputBox = candidateFilter
					GoSub InputBox
					candidateFilter = inputBox
					GoSub TAB.HOKAN
				End
				
			Case C = CTRL.T
				GoSub ACTION.INPUT.PREV.FILENAME
				
			Case C = CTRL.R
				!! コマンド履歴逆順インクリメンタルサーチ
				If bIncSearch <> "R" Then
					If bIncSearch = "" Then
						iSearchText = cmdline[1,curPos-1]
					End
					bIncSearch = "R"
				End
				GoSub ACTION.CMDSTACK.INC.SEARCH
				
			Case C = CTRL.F
				!! コマンド履歴正順インクリメンタルサーチ
				If bIncSearch <> "F" Then
					If bIncSearch = "" Then
						iSearchText = cmdline[1,curPos-1]
					End
					bIncSearch = "F"
				End
				GoSub ACTION.CMDSTACK.INC.SEARCH
				
			Case C = CTRL.L
				!! 前回の.Lを実行
				cmdline = prevListStackCmd
				bAutoCommand = @TRUE
				bAutoEditor = @FALSE
				
			Case actNo = A.NEWLINE
				GoTo Run.Command
				
			Case actNo = A.CASEINVERT
				GoSub Act.ToggleCaseInvert
			
		** イベント
			Case actNo = A.THEME
				GoSub CUR.TOP.OF.SCREEN
				GoSub Act.SwitchTheme
				crtBuff = ESC.CUR.TOP:CHAR(8):@(-3)
				Crt crtBuff:

			Case actNo = A.FIT.TERM
				!! 端末サイズ自動設定
				GoSub AutoTermSize
				
			Case actNo = A.EXIT
				!! エディタ起動
				If Not(bFirstCurTop) Then
					** 代替画面バッファ開いてる場合は閉じる
					crtBuff = ""
					GoSub BackAltScreenBuf
					Crt crtBuff:
					bFirstCurTop = @TRUE
					bDispCandidate = @FALSE
				End
				editerCmd = ""
Launch.Editor:
				GoSub Editor.Main
			
			Case actNo = A.CANCEL
				If Not(bFirstCurTop) Then
					** 代替画面バッファ開いてる場合は閉じる
					crtBuff = ""
					GoSub BackAltScreenBuf
					Crt crtBuff:
					bFirstCurTop = @TRUE
					bDispCandidate = @FALSE
				End
				If bIncSearch Then
					bIncSearch = "" ;** 終了
					iSearchText = ""
				End
				
			Case 1
				!! 共通処理
				
				!! 大文字小文字反転処理
				If actNo = A.INSCHAR And bInvert And n <> -1 And Len(C) = 1 Then
					C = Convert("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz","abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ",C)
				End
				
				If bIncSearch Then
					!! インクリメンタルサーチモード
					If actNo = A.INSCHAR Then
						iSearchText := C
					End Else If actNo = A.BACKSPACE Then
						If Len(iSearchText) > 0 Then
							iSearchText = iSearchText[1,Len(iSearchText)-1]
						End
					End Else
						bIncSearch = "" ;** 終了
						iSearchText = ""
						GoTo Shell.KeyLoop.Start
					End
					If bIncSearch = "R" Then
						If cmdStackPos > 2 Then cmdStackPos -= 1
					End Else
						cmdStackPos += 1
					End
					GoSub ACTION.CMDSTACK.INC.SEARCH
				End Else
					GoSub Input.Actions
					If Not(bFirstCurTop) Then
						!! 入力補完処理
						GoSub TAB.HOKAN
					End
				End
			
		End Case
		
		** --------------------------
		** 選択範囲調整
		** --------------------------
		If keepSelection Then
			** 選択終了位置
			If Not(BufInfo<BI.BLOCKEND>) Then BufInfo<BI.BLOCKEND> = Y:@VM:X
		End Else
			** 選択範囲が外れた
			BufInfo<BI.BLOCKSTART> = ""
			BufInfo<BI.BLOCKEND> = ""
		End

Shell.KeyLoop.End:
	Repeat
	
GoTo Shell.KeyLoop.Start; * キー入力待ちに戻る

*---------------------------
* ターミナルサイズの自動設定
*---------------------------
AutoTermSize:
	Crt CSI:"18;;t": ;** 端末サイズ教えて
	GoSub GetKey
	If C Matches "'":ESC:"[8'...'t'" Then
		** DECSLPP -> CSI Ps1 ; Ps2 ; Ps3 t
		csiPrm = C[3,HUGE]['t',1,1]
		** 端末サイズを指定のサイズにする
		wide = csiPrm[';',3,1]
		high = csiPrm[';',2,1]
	End Else
		Return
	End
	
	If @CRTWIDE:@CRTHIGH >< wide:high Then
		!! サイズが変わった
		cmdline = "TERM ":wide:",":high
		bAutoCommand = @TRUE
	End
	
	Return

*---------------------
* コマンドラインクリア
*---------------------
Clear.Cmdline.Crt:
	For i=1 To curY
		crtBuff := CSI:'1A'
	Next
	crtBuff := CSI:'G':CSI:'2K'
	For i=1 To cmdlineRows
		crtBuff := CSI:'1B'
		crtBuff := CSI:'2K'
	Next
	For i=1 To cmdlineRows
		crtBuff := CSI:'1A'
	Next
Return

*---------------------
* コマンド実行
*---------------------
Run.Command:

	crtBuff = ""
	If Not(bFirstCurTop) Then
		** 補完候補表示していたらアプリケーションモードから戻す
		GoSub BackAltScreenBuf
	End

	cmdlines = "" ;** 複数コマンド
	If Count(cmdline,@FM) Then
		!! 複数コマンドなら先だしで１つ選ぶ
		cmdlines = cmdline
		cmdline = cmdline<1>
		Del cmdlines<1>
	End

	verb = UPCASE(Trim(cmdline)[' ',1,1])
	If verb="Q" or verb="QUIT" Then
		!! 終了
		GoTo QUIT.SHELL
	End Else If verb[1,1] = "." Then
		!! シェル内部コマンド
		k = verb[2,1]
		Begin Case
			Case k = "A"
				GoTo ACTION.CMDSTACK.APPEND
			Case k = "C"
				GoTo ACTION.CMDSTACK.CHANGE
			Case k = "D"
				GoTo ACTION.CMDSTACK.DELETE
			Case k = "G"
				GoTo ACTION.CMDSTACK.GOTO
			Case k = "L"
				GoTo ACTION.CMDSTACK.LIST
			Case k = "R"
				GoTo ACTION.CMDSTACK.READ
			Case k = "S"
				GoTo ACTION.CMDSTACK.SAVE
			Case k = "X"
				** コマンド実行
				cmd = Convert(' ','-',Trim(cmdline[3,9999]))
				n = cmd['-',1,1]
				m = cmd['-',2,1]
				
				If n = "" And m = "" Then n = 1
				If m = "" Then m = n ;** 1行にする
				If Num(n) And Num(m) Then
					min_no = Minimum(n:@FM:m)
					max_no = Maximum(n:@FM:m)
					For i = max_no To min_no Step -1
						cmdlines<-1> = If cmdStackPage<i+1> <> "" Then cmdStackPage<i+1> Else cmdStack<i+1>
					Next i
				End
				
				** 自動モードで初めからやり直し
				cmdline = cmdlines
				bAutoCommand = @TRUE
				GoTo AutocommanLoop.Start
				
			Case k = "T"
				bTimer = Not(bTimer)
				Print ""
				If bTimer Then Print "時間計測ON" Else Print "時間計測OFF"
				GoTo Run.Command.Ending
			Case k = "E"
				If Trim(cmdline) = ".E" Then GoTo Launch.Editor ;** 単純にエディタに切り替える
				!! VerbをSIEDに置換
				cmdline = "READ.BUFFER":cmdline[3,9999]
				X += 9
			Case k = "K"
				!! KeySeq表示モード
				GoSub Keys
				cmdline = ""
		End Case
	End
	
	GoSub Clear.Cmdline.Crt
	crtBuff := HI.SHELL.ON:PROMPT.STR:HI.SHELL.OFF:cmdline
	Crt crtBuff:
	
	** 空コマンドは無視
	If cmdline = "" Then
		GoSub CLEAR.FOR.PERFORM
		GoTo Run.Command.Ending
	End

	!! 先頭が空文字とピリオドでなければコマンドスタックの更新
	If cmdline[1,1] <> ' ' Then
		GoSub CmdStack.Push
	End

	bFirstCurTop = @TRUE

	GoSub CLEAR.FOR.PERFORM

	If cmdline[1,11] = "READ.BUFFER" Then
		!! スクリーンエディタの起動
		editerCmd = cmdline
		bAutoEditor = @TRUE
		GoTo After.Perform.Cmd
	End

	!! 普通のコマンド起動
	
	** Ctrl+C のIntruputを戻す
	** 自動ページングをON
$IFDEF U2__UNIVERSE
	Perform "PTERM INTR ^C"
	assign 1 to system(1005)
$ELSE
	x = PTERM(3,3)
	x = PTERM(4,@TRUE)
$ENDIF

	!! 実行前の端末サイズ
	prevCrt = @CRTHIGH:@CRTWIDE

	@USER.RETURN.CODE = 999999999
	
	If bTimer Then
		!! 時間計測開始
		startTime = Time()
		startTimeCpu = System(9)
	End
	
	!!
	!! ##### 実行 ######
	!!
$IFDEF U2__UNIVERSE
	Perform cmdline
$ELSE
	Execute cmdline TRAPPING ABORTS
$ENDIF

	If bTimer Then
		!! 時間計測開終了
		endTime = Time()
		endTimeCpu = System(9)
		Crt "実行時間  " : (endTime - startTime) : "s  (CPU時間  " : (endTimeCpu - startTimeCpu) : "s)":ESC.CRT.MOVE_NEXT_LINE:
	End
	
	IF prevCrt <> @CRTHIGH:@CRTWIDE Then
		Crt CSI:"8;":@CRTHIGH:";":@CRTWIDE:"t":
	End
	
	!! PA なら プロンプトをクリアする
	ReadV type From VOC,verb,1 Then
		If type[1,2] = "PA" Then
$IFDEF U2__UNIVERSE
			Perform "CLEARPROMPTS"
$ELSE
			Execute "CLEARPROMPTS" STACKLIST
$ENDIF
		End
	End
	
After.Perform.Cmd:

	** コマンドスタックのファイル保存
	stackPath = STACK.FILE:"/":@LOGNAME:"$":MY_COMMAND
$IFDEF U2__UNIVERSE
	OpenSeq stackPath To fpStack Then
$ELSE
	OpenSeq stackPath ENCODING "UTF8" To fpStack Then
$ENDIF
		retCode = (If @USER.RETURN.CODE = 999999999 Then @SYSTEM.RETURN.CODE Else @USER.RETURN.CODE)
		Seek fpStack, 0, 2 Else Abort "Seek Stack Log Error"
		line = OConv(Date(),"D-YMD"):" ":OConv(Time(),"MTS"):" ":cmdline:@VM:retCode
		WriteSeq line To fpStack On Error Print "Cannot Write Stack Log -> ":STACK.FILE:"/":logFile Else ;
		CloseSeq fpStack
	End
	
	** 直前のファイル名を格納
	tmp = Trim(cmdline)[' ',2,1]
	If tmp >< "" Then
		Read rec From VOC,tmp[',',1,1] Then
			type = rec[1,1]
			If type = "F" OR type = "Q" Then prevFileName = tmp
		End
	End
	
Run.Command.Ending:
	If bAutoCommand Then
		If cmdlines # "" Then
			cmdline = cmdlines
			GoTo AutocommanLoop.Start ;** まだ続く
		End
		bAutoCommand = @FALSE
		If bAutoEditor Then
			!! エディタに戻る前に停止
			Print "Back to the editor, please press any key. :":
			GoSub GetKey
		End
	End
	
GoTo Shell.Input.Begin; * 先頭に戻る

*---------------------
* TAB補完 Action
*---------------------
TAB.HOKAN:
	
	GoSub Setting.WordInfo
	
	fpTgtAccVOC = VOC
	tgtAccVOC = "VOC"
	tgtAccFile = ACCOUNT.FILE
	
$IFNDEF U2__UNIVERSE
	If bDispCandidate Or actNo = A.TAB Then
		!! OSディレクトリ補完
		path = Convert('\','/',nowWord)
		If (Count(path,'/') AND Count(path,":")=0) Or nowWord[1,5] = "PATH:" Then
			If path[1,5] = "PATH:" Then
				path = path[6,99]
				nowWord = nowWord[6,99]
			End
			filter = UpCase(Last(path,'/'))
			filter.len = Len(filter)
			parent = path[1,Len(path)-filter.len]
			dirPath = parent
			If dirPath = "" Then dirPath = "./"
	
			GoSub GetDirList
			
			If list Then
				slist = ""
				slistU = ""
				dlist = ""
				a = Index(nowWord,'/')
				If a = 0 Then a = 9999
				b = Index(nowWord,'\')
				If b = 0 Then b = 9999
				pdelim = If a < b Then '/' Else '\'
				For Each line In list Delimiter @FM
					If UpCase(line[1,filter.len]) = filter Then
						id = line<1,1>:(If line<1,2>="D" Then pdelim Else " ")
						slist<-1> = id
						slistU<-1> = UpCase(id)
						dlist<-1> = ""
					End
				Next line
				
				nowWord = nowWord[Len(parent)+1,99]
				GoSub Setting.WordInfo2
				
				dispType = "OS Path"
				
				If bDispCandidate Then
					!! 候補表示モード
					candidateMode = startCandidateMode
					GoSub DispCandidate.Common
				End Else
					If actNo = A.TAB Then
						!! タブキーによりオートコンプリートする
						GoSub Prev.Match.Filter
						GoSub AUTO.COMPLATE
					End
				End
				
				Return
			End
		End
	End
$ENDIF

	If nowWordPos <= 1 Then
		
		* Verbの補完
		
		tgtVocTypes = "V,R,S,PA,PQ,M"
		GoSub Get.SList.From.Voc
		dispType = "Verb"
		
		!! SISH専用コマンド
		id = ""
		desc = ""
		id<-1> = ".A"
		desc<-1> = "コマンドの末尾にテキストを追記"
		id<-1> = ".C"
		desc<-1> = "コマンドの文字列置換"
		id<-1> = ".E "
		desc<-1> = "エディタ起動"
		id<-1> = ".G"
		desc<-1> = "指定位置のコマンド履歴に移動"
		id<-1> = ".K"
		desc<-1> = "キーシーケンス確認モード"
		id<-1> = ".L"
		desc<-1> = "コマンド履歴の一覧表示"
		id<-1> = ".R"
		desc<-1> = "コマンドを履歴の先頭に読み込む"
		id<-1> = ".S "
		desc<-1> = "コマンド履歴をVOCにPAとして保存"
		id<-1> = ".T"
		desc<-1> = "時間計測モードON/OFF"
		id<-1> = ".X"
		desc<-1> = "コマンド履歴を実行"
		idU = UpCase(id)
		
		Locate idU<1> In slistU By "AL" Setting no Else
			Ins id Before slist<no>
			Ins idU Before slistU<no>
			Ins desc Before dlist<no>
		End
		
		id = "READ.BUFFER"
		desc = "エディタのバッファに指定のファイルを読み込む(SISH内部コマンド)"
		idU = UpCase(id)
		Locate idU In slistU By "AL" Setting no Else
			Ins id Before slist<no>
			Ins idU Before slistU<no>
			Ins desc Before dlist<no>
		End
		
		If bDispCandidate Then
			!! 候補表示モード
			candidateMode = startCandidateMode
			GoSub DispCandidate.Common
		End Else
			If actNo = A.TAB Then
				!! タブキーによりオートコンプリートする
				GoSub Prev.Match.Filter
				GoSub AUTO.COMPLATE
			End
		End
		
	End Else
	
		* Verbは決定済み
		words = Convert(", ",@FM:@FM,cmdline);
		
		** 初めの単語がLOGTOならアカウント補完
		If UpCase(words<1>)="LOGTO" Then
			
Account.Hokan:
			slist = ""
			slistU = ""
			dlist = ""
			Open tgtAccFile TO fpACCOUNT Then
				SelectV fpACCOUNT To sp
				Loop
					ReadNext @ID From sp Else Exit
					id = @ID
					If tgtAccFile <> ACCOUNT.FILE Then
						id := ":"
					End
					idU = UpCase(id)
					Locate idU In slistU By "AL" Setting no Else
						Ins idU Before slistU<no>
						Ins id Before slist<no>
						Read @RECORD From fpACCOUNT,@ID Then
$IFDEF U2__UNIVERSE
							desc = "===> ":@RECORD<11>:" ":@RECORD<15>
$ELSE
							desc = "===> ":@RECORD<1>:" ":@RECORD<2>
$ENDIF
							Ins desc Before dlist<no>
						End
					End
				Repeat
				Close fpACCOUNT
			End
			If bDispCandidate Then
			
				candidateMode = startCandidateMode
				dispType = "ACCOUNT ":tgtAccFile
				GoSub DispCandidate.Common
			
			End Else
				If actNo = A.TAB Then
					!! タブキーによりオートコンプリートする
					GoSub Prev.Match.Filter
					GoSub AUTO.COMPLATE
				End
			End
			GoTo TAB.HOKAN.END
		End
		
		** -- 特殊補完の前処理 --
		
		!! 対象の辞書を確定する
		dictType = "DICT";
		dictName = "";
		fpDICT = 0;
		Find "USING" In words Setting idx Then
			* USING使用
			If UpCase(words<idx+1>)="DICT" Then word = words<idx+2> Else word = words<idx+1>; dictType="";
			If word><nowWord Then
				Open dictType,word To fpDICT Then
					dictName = word
				End
			End
		End Else
			For i = 1 To 999
				word = Remove(words, sep);
				If word >< nowWord Then
					Open dictType,word To fpDICT Then
						dictName = word
						Exit
					End
				End
				If sep=0 Then Exit;
			Next i
		End
		
$IFNDEF U2__UNIVERSE
		If Count(nowWord,"%") Then
			!! Linkフィールドか確認する(OpenQM)
			lastId = ""
			linkDictName = dictName
			
			lTypeFld = Convert("%",@FM,nowWord)
			Loop
				lastId = Remove(lTypeFld,sep)
				rec = Raise(Trans("DICT ":linkDictName,lastId,-1,"X"))
				If rec[1,1] = "L" Then
					linkDictName = rec<3>
					Read rec From VOC,linkDictName Then
						If rec[1,1] = "F" And rec<3> Then
							Continue
						End
					End
				End
			While sep
			Repeat
			
			If linkDictName <> dictName Then
				!! Linkの辞書ファイルに差し替える
				Open "DICT",linkDictName To fpDICT Then
					dictName = linkDictName
					nowWord = lastId
					GoSub Setting.WordInfo2
					candidateMode = "FIELD"
				End Else
					Open "DICT",dictName To fpDICT Then ;
				End
			End
		End
$ENDIF
		
		!! ファイルの検索先ターゲットアカウント情報
		
$IFNDEF U2__UNIVERSE
		If Count(nowWord,":") Then
			!! 拡張ファイルフォーマットか確認する(OpenQM)
			cnt = Count(nowWord,":")
			If cnt = 1 Then
				tmpName = nowWord[":",1,1]:":VOC"
				Open tmpName To fpTemp Then
					!! 対象のVOCをすり替える
					fpTgtAccVOC = fpTemp
					tgtAccVOC = tmpName
					nowWord = nowWord[":",2,*]
					GoSub Setting.WordInfo2
				End Else
					!! サーバ名か確認する
					tmpName = nowWord[":",1,1]
					Locate tmpName In serverListIds<1> By "AL" Then
						!! アカウントのみ補完する特殊モード
						nowWord = nowWord[":",2,*]
						tgtAccFile = tmpName:":QMSYS:QM.ACCOUNTS"
						GoSub Setting.WordInfo2
						GoTo Account.Hokan
					End
				End
			End Else If cnt => 2 Then
				tmpName = nowWord[":",1,2]:":VOC"
				Open tmpName To fpTemp Then
					!! 対象のVOCをすり替える
					fpTgtAccVOC = fpTemp
					tgtAccVOC = tmpName
					nowWord = nowWord[":",3,*]
					GoSub Setting.WordInfo2
				End
			End
		End
$ENDIF
		
		* 補完候補表示
		If bDispCandidate Then
			
			* 状態別候補表示処理
			Begin Case
			
			** 特殊補完
			Case candidateMode="FLATREC"
				
				** 直前の単語がマルチパートファイルか調べる
				prevWord = words<nowWordPos-1>
				Read rec From VOC,prevWord Then
					If rec<1>[1,1] = "F" And rec<4>[1,1] = "M" Then
						slist = ""
						slistU = ""
						dlist = ""

						mpFile = prevWord
						nowWord = mpFile:",":nowWord
						nowWord.length = Len(nowWord)
						list = Splice(Reuse(mpFile),",",Convert(@VM,@FM,rec<7>))
						Loop
							v = Remove(list,sep)
							If v[1,nowWord.length] = nowWord Then
								slist<-1> = v
								slistU<-1> = UpCase(v)
							End
						While sep Do Repeat
						
						dispType = "MultiPart ":mpFile
						GoSub DispCandidate.Common
						
						GoTo TAB.HOKAN.END
					End
				End
				
				GoSub Get.SList.FLATFILE
				
				dispType = "Directory ":flatFile
				
			* フィールド補完
			Case candidateMode="FIELD"
				
				GoSub Get.SList.FIELD
				
				dispType = dictType:" ":dictName:" "
				
			* FILE補完
			Case candidateMode="FILE"
				
				GoSub Get.SList.FILE
				
				dispType = "FILE"

			* VOC補完
			Case candidateMode="VOC"
				
				GoSub Get.SList.VOC
				
				dispType = "VOC"

			Case candidateMode=""
				
				slist = ""
				dispType = ""
				bDispCandidate = @FALSE
				
			End Case
		
			GoSub DispCandidate.Common
			
		End Else
			If actNo = A.TAB Then
				* オートコンプリート
				
				GoSub Get.SList.VOC
				GoSub Prev.Match.Filter
				slistAll = slist
				
				GoSub Get.SList.FILE
				GoSub Marge.SlistAll
				
				GoSub Get.SList.FIELD
				GoSub Marge.SlistAll
				
				GoSub Get.SList.FLATFILE
				GoSub Marge.SlistAll
				
				* オートコンプリート
				slist = slistAll
				GoSub AUTO.COMPLATE
				
			End
		End
		
		Close fpDICT
	End

TAB.HOKAN.END:

Return

Marge.SlistAll:
	Loop
		id = Remove(slist,sep)
		idU = Remove(slistU,sep)
		If idU[1,nowWord.len] = nowWordU Then
			Locate id In slistAll By "AL" Setting i Else Ins id Before slistAll<i>
		End
	While sep
	Repeat
Return

DispCandidate.Common:

	GoSub Prev.Match.Filter
	If candidateFilter Then
		!! フィルタによる絞り込み
		GoSub Match.CancidateFilter
	End
	
	If actNo = A.INSCHAR Then
		actNo = 0
		!! 文字入力により自動的にオートコンプリートする
		commonWord = ""
		GoSub AUTO.COMPLATE
		If commonWord And nowWord <> commonWord Then
			GoSub Setting.WordInfo
			GoSub Prev.Match.Filter
			If dispType = "OS Path" Then
				bDispCandidate = @TRUE
				GoTo TAB.HOKAN ;** 連続で候補表示する
			End
		End
	End

	!! 0件なら次のモードを試してみる
	If slist = "" And bDispCandidate And startCandidateMode <> candidateMode Then
		If Not(startCandidateMode) Then startCandidateMode = candidateMode
		If candidateMode = "FLATREC" Then
			candidateMode = "FIELD"
		End Else If candidateMode = "FIELD" Then
			candidateMode = "FILE"
		End Else If candidateMode = "FILE" Then
			candidateMode = "VOC"
		End Else If candidateMode = "VOC" Then
			candidateMode = ""
		End
		GoTo TAB.HOKAN
	End
	
	!! 描画
	GoSub CUR.TOP.OF.SCREEN

	dispRowNum = @CRTHIGH - cmdlineRows - 2
	
	crtBuff = ""
	crtBuff := @(0,1)
	allNum = DCount(slist,@FM)
	If allNum = 0 Then
		!! 候補なし
		dispType = ""
		allNum = 1
		allPageNum = 0

		!! TODO ヘルプファイルがあればヘルプ表示する
		
$IFNDEF U2__UNIVERSE
		@ID = Field(Trim(cmdline),' ',1)
		Read @RECORD From VOC,@ID Then
			!! Verb決定済み
			dispType = "Help"
			lines = ""
			type = @RECORD[1,1]
			If type Matches "P":@VM:"S" Then
				!! PH PQ S
				maxCnt = DCount(@RECORD,@FM)
				maxLen = Len(maxCnt)
				For i = 2 To maxCnt
 					lines<-1> = "  ":Fmt(i,"R%":maxLen):": ":@RECORD<i>
				Next i
			End Else If type = "V" Then
				If @RECORD<2> = "CS" Then
					!! Localカタログ
					srcPath = Change(Convert("\","/",@RECORD<3>),".OUT/","/")
					id = Last(srcPath,'/')
					path = srcPath[1,Len(srcPath)-Len(id)]
					OpenPath path Encoding "UTF8.A" To fp Then
						Read rec From fp,id Then
							maxCnt = DCount(rec,@FM)
							bDoc = @FALSE
							For i = 1 To maxCnt
								line = rec<i>
								If line Matches "...**...==..." Then ;** "** ==========" ~ "** ==========" まで
									lines<-1> = "  ":line[Index(line,"**",1)+2,999] ;** 先頭の"**"を省く
									If Not(bDoc) Then bDoc = @TRUE Else Exit
								End Else
									line = line[Index(line,"**",1)+2,999] ;** 先頭の"**"を省く
									xpos = Index(line,"**",1)
									If xpos Then
										line = line[1,xpos-1] ;** 次の"**"移行はコメントとして省く
									End
									line = Change(line,CHAR(9),Space(DEFAULT.INDENT)) ;** Tab -> space
									If bDoc Then lines<-1> = "  ":line
								End
							Next i
						End
						Close fp
					End
				End Else
					lines<1> = "  コマンドの詳細は以下を参照"
					lines<2> = "  http://downloads.openqm.com/help/":DownCase(Convert('.','_',@ID)):".htm"
				End
			End
			
			!! VOCの説明を表示
			crtBuff := @(0,2):"  ":@ID:" : ":iType(descIType)
			
			!! ページング
			allNum = DCOUNT(lines,@FM)
			allPageNum = INT(allNum / (dispRowNum-4))
			If allPageNum < pageNum Then pageNum = 0
			If pageNum < 0 Then pageNum = allPageNum
			st = pageNum * (dispRowNum-4)
			off = (dispRowNum-3) - 1
			lines = lines[@FM,st,off]
			
			!! 画面表示(縦センタリング)
			lines.len = DCount(lines,@FM)
			startY = 3
			For i = 1 To lines.len
				crtBuff := @(0,startY+i+cmdlineRows):lines<i>
			Next i
			
			If allPageNum > 0 Then
				!! 再描画させる
				bDispCandidate = @TRUE
			End
			
		End
$ENDIF
	End Else
		!! 候補リスト表示処理
		
		grpId = ""
		grpDesc = ""
		
		grpCh = nowWord.len + 1 ;** グループ化対象の文字位置
		prevCh = "" ;** 前回の文字
		outCnt = 0
		For i = 1 To allNum
			ch = slistU<i>[grpCh,1]
			If ch <> "" Then
				If ch <> prevCh Then
					outCnt += 1
					grpId<outCnt> = slist<i>
					grpDesc<outCnt> = slist<i>:@SVM:dlist<i>
				End Else
					!! 共通化
					commonId = grpId<outCnt>
					nowId = slist<i>
					For j = grpCh To Len(commonId)
						If UpCase(commonId[j,1]) >< UpCase(nowId[j,1]) Then
							commonId = commonId[1,j-1]
							Exit
						End
					Next j
					grpId<outCnt> = commonId
					grpDesc<outCnt,-1> = slist<i>:@SVM:dlist<i>
				End
			End
			prevCh = ch
		Next i
		
		!! 表示情報の構築
		keyInfos = ""
		descInfos = ""
		
		If allNum > dispRowNum Then
			!! 1ページに収まらない場合はグループ化表示
			For i = 1 To Dcount(grpId,@FM)
				desc = grpDesc<i>
				cnt = DCount(desc,@VM)
				If cnt = 1 Then
					keyInfos<-1> = grpId<i>
					descInfos<-1> = Len(grpId<i>):@VM:desc<1,1,2>
				End Else
					keyInfos<-1> = grpId<i>:"...(":cnt:")"
					ids = ""
					Loop
						id = Remove(desc,sep)
						non = Remove(desc,s)
						ids := If id[1] = " " Then id Else id:" "
					While sep
					Repeat
					descInfos<-1> = Len(grpId<i>):@VM:ids
				End
			Next i
		End Else
			prevCh = ""
			!! 1次元目
			Loop
				commonId = Remove(grpId,sep1)
				!! 2次元目
				Loop
					id = Remove(grpDesc,sep2)
					desc = Remove(grpDesc,s)
					keyInfos<-1> = id
					descInfos<-1> = Len(commonId):@VM:desc
				While sep2 >= 3 ;** VM以上
				Repeat
			While sep1
			Repeat
		End
		
		!! ページング
		allNum = DCOUNT(keyInfos,@FM)
		allPageNum = INT(allNum / dispRowNum)
		If allPageNum < pageNum Then pageNum = 0
		If pageNum < 0 Then pageNum = allPageNum
		st = pageNum * dispRowNum
		off = dispRowNum - 1
		keyInfos = keyInfos[@FM,st,off]
		descInfos = descInfos[@FM,st,off]
		
		sp = 2
		col1 = Maximum(LenSDP(keyInfos))
		col2 = @CRTWIDE - col1
		col2W = (col2 - sp):"T"
		
		!! Header
		crtBuff := @(0,1+cmdlineRows)
		crtBuff := Str("-",col1):Str(" ",sp):Str("-",col2)
		
		For i = 1 To dispRowNum
			id = keyInfos<i>
			If id = "" Then Exit
			
			!! id
			crtBuff := @(0,1+i+cmdlineRows)
			crtBuff := id[1,nowWord.len]
			crtBuff := ESC:"[1m"
			
			ch = id[grpCh,1]
			If prevCh <> ch Then
				!! アルファベット強調表示
				crtBuff := ESC:"[":FG.ORANGE:"m":ch:ESC:"[":FG.DEFAULT:"m"
			End Else
				crtBuff := ch
			End
			prevCh = ch
			
			crtBuff := id[nowWord.len+2,descInfos<i,1>-grpCh]
			crtBuff := SGR.ALL.OFF
			crtBuff := id[nowWord.len+2+descInfos<i,1>-grpCh,99]
			
			!! desc
			crtBuff := @(col1+sp,1+i+cmdlineRows)
			crtBuff := FMTDP(Convert(@VM," ",descInfos<i,2>),col2W)[@TM,1,1]
		Next
		
	End
	
	crtBuff := @(-3):@(0,@CRTHIGH-1):HI.STATUS.ON:@(-4)
	
	!! 右側（優先度低）
	opDesc = ""
	If allPageNum > 0 Then opDesc := "[PgDown]-NextPage / [PgUp]-PrevPage / "
	If dispType And allNum Then opDesc := "[Tab]-NextType / "
	opDesc := "[F3]-Filter / [Esc]-Back"
	If @CRTWIDE-LenDP(opDesc)-1 > 5 Then 
		crtBuff := @(@CRTWIDE-LenDP(opDesc)-1,@CRTHIGH):opDesc
	End
	
	!! 左側（優先度高）
	crtBuff := @(0,@CRTHIGH-1)
	If dispType And allNum Then
		crtBuff := (If dispType <> "Help" Then "Type: " Else " "):dispType
		If allPageNum > 0 Then crtBuff := " | ":(pageNum+1):" / ":(allPageNum+1)
		crtBuff := " | "
	End
	If candidateFilter Then crtBuff := "Filter: ":candidateFilter:" | "
	
	crtBuff := SGR.ALL.OFF
	crtBuff := @(0,0)
	Crt crtBuff:
	
Return

Setting.WordInfo:
	fullLine = Convert(',',' ',cmdline)
	If actNo = A.INSCHAR And C = Char(32) Then
		!! SPが入力された
		nowLine = fullLine[1,curPos-2]          ;** カーソルまでのコマンドライン
		nowWordPos = DCount(nowLine, ' ')       ;** カーソル上の単語位置
		nowWord = nowLine[' ',nowWordPos,1]:" " ;** カーソル上の単語（カーソル位置まで）
	End Else
		nowLine = fullLine[1,curPos-1]          ;** カーソルまでのコマンドライン
		nowWordPos = DCount(nowLine, ' ')       ;** カーソル上の単語位置
		nowWord = nowLine[' ',nowWordPos,1]     ;** カーソル上の単語（カーソル位置まで）
	End
Setting.WordInfo2:
	nowWordU = UpCase(nowWord)             ;** カーソル上の単語大文字（カーソル位置まで）
	nowWord.len = Len(nowWord)             ;** カーソル上の単語長（カーソル位置まで）
	fullWord = fullLine[' ',nowWordPos,1]  ;** カーソル上のフル単語
Return

ExecCmd:
$IFDEF U2__UNIVERSE
	Execute cmd, OUT>NULL
$ELSE
	Execute cmd SILENT STACKLIST
$ENDIF
Return

Prev.Match.Filter:
	If Len(nowWordU) = 0 Then Return
	slistU.old = slistU
	slist.old = slist
	dlist.old = dlist
	slistU = ""
	slist = ""
	dlist = ""
	Loop
		idU = Remove(slistU.old,sep)
		id = Remove(slist.old,s)
		desc = Remove(dlist.old,s)
		If idU[1,nowWord.len] = nowWordU Then
			!! NO.CASEで前方一致
			slistU<-1> = idU
			slist<-1> = id
			dlist<-1> = desc
		End
	While sep
	Repeat
Return

Match.CancidateFilter:
	filterU = UpCase(candidateFilter)
	slistU.old = slistU
	slist.old = slist
	dlist.old = dlist
	slistU = ""
	slist = ""
	dlist = ""
	Loop
		id = Remove(slist.old,sep)
		idU = Remove(slistU.old,s)
		desc = Remove(dlist.old,s)
		If Index(Trim(idU):@FM:UpCase(desc),filterU,1) Or Trim(id) Matches candidateFilter Or desc Matches candidateFilter Then
			slist<-1> = id
			slistU<-1> = idU
			dlist<-1> = desc
		End
	While sep
	Repeat
Return

Get.SList.From.Voc:
	slist = ""
	slistU = ""
	dlist = ""
	tgt = Convert(',',@VM,tgtVocTypes)
	SelectV VOC To sp
	Loop
		ReadNext @ID From sp Else Exit
		Read @RECORD From VOC,@ID Then
			type = iType(typeIType)
			m1 = type<1,1> Matches tgt
			m2 = type<1,2> Matches tgt
			If m1 Or m2 Then
				id = @ID:" "
				idU = UpCase(id)
				Locate idU In slistU By "AL" Setting no Else
					Ins id Before slist<no>
					Ins idU Before slistU<no>
					desc = iType(descIType)
					If m2 Then
						desc = If m1 Then desc<1,1>:" ":desc<1,2> Else desc<1,2>
					End
					Ins desc Before dlist<no>
				End
			End
		End
	Repeat
Return

Get.SList.From.Voc2:
	slist = ""
	slistU = ""
	dlist = ""
	tgt = Convert(',',@VM,tgtVocTypes)
	SelectV fpTgtAccVOC To sp
	Loop
		ReadNext @ID From sp Else Exit
		Read @RECORD From fpTgtAccVOC,@ID Then
			type = iType(typeIType)
			m1 = type<1,1> Matches tgt
			m2 = type<1,2> Matches tgt
			If m1 Or m2 Then
				@ID := " "
				idU = UpCase(@ID)
				Locate idU In slistU By "AL" Setting no Else
					Ins idU Before slistU<no>
					Ins @ID Before slist<no>
					desc = iType(descIType)
					If m2 Then
						desc = If m1 Then desc<1,1>:" ":desc<1,2> Else desc<1,2>
					End
					Ins desc Before dlist<no>
				End
			End
		End
	Repeat
Return

Get.SList.VOC:
	tgtVocTypes = "V,R,S,K,PA,PQ,PH,M,D"
	GoSub Get.SList.From.Voc
Return

Get.SList.FILE:

	If slistCacheType = "F ":tgtAccVOC Then
		slist = slistCache
		slistU = slistUCache
		dlist = dlistCache
	End Else
		tgtVocTypes = "F,Q"
		GoSub Get.SList.From.Voc2
		slistCache = slist
		slistUCache = slistU
		dlistCache = dlist
		slistCacheType = "F ":tgtAccVOC
	End
	
$IFNDEF U2__UNIVERSE
	If tgtAccVOC = "VOC" Then
		** ACCOUNTファイル
		Open ACCOUNT.FILE TO fpACCOUNT Then
			SelectV fpACCOUNT To sp
			Loop
				ReadNext @ID From sp Else Exit
				Read @RECORD From fpACCOUNT,@ID Then
					@ID := ":"
					idU = UpCase(@ID)
					Locate idU In slistU By "AL" Setting no Else
						Ins idU Before slistU<no>
						Ins @ID Before slist<no>
						Ins @RECORD<1>:" ":@RECORD<2> Before dlist<no>
					End
				End
			Repeat
			Close n
		End
		** $SERVERSファイル
		cnt = DCount(serverListIds,@FM)
		For i = 1 To cnt
			@ID = serverListIds<i>:":"
			idU = UpCase(@ID)
			desc = serverList<i>
			Locate idU In slistU By "AL" Setting no Else
				Ins idU Before slistU<no>
				Ins @ID Before slist<no>
				Ins desc Before dlist<no>
			End
		Next i
	End
$ENDIF

Return

Get.SList.FIELD:
	slist = ""
	slistU = ""
	dlist = ""
	If dictName Then
		SelectV fpDICT To sp
		Loop
			ReadNext @ID From sp Else Exit
			Read @RECORD From fpDICT,@ID Then
				If Count("DILPCEAS",@RECORD[1,1]) Then
					If @RECORD[1,1] = "L" Then
						@ID := "%"
						!! ---> Ref Table
						desc = "---> ":@RECORD<3>
					End Else
						@ID := " "
						If Count("DIE",@RECORD[1,1]) Then
							!! Type S/M Assoc Description
							desc = FMT(@RECORD[1,1],"3L"):FMT(@RECORD<6>,"2L"):@RECORD<7>:" ":@RECORD<4>
						End Else If @RECORD[1,2] = "PH" Then
							desc = FMT("PH","3L"):@RECORD<2>
						End
					End
					idU = UpCase(@ID)
					Locate idU In slistU By "AL" Setting no Else
						Ins idU Before slistU<no>
						Ins @ID Before slist<no>
						Ins desc Before dlist<no>
					End
				End
			End
		Repeat
	End
Return

Get.SList.FLATFILE:

	** 単語を遡ってフラットファイルか調べる
	flatFile = ""
	For wordPos = nowWordPos - 1 To 1 Step -1
		Open words<wordPos> To fpFlat Then
			fileType = FileInfo(fpFlat,3)
			If fileType = 4 Then
				flatFile = words<wordPos>
				Exit
			End
		End
	Next
	
	If flatFile = "" Then
		If UpCase(words<1>) Matches Convert(" ",@VM,"RUN BASIC CATALOG DELETE.CATALOG CATALOGUE DELETE.CATALOGUE") Then
			!! VerbがBasic系でフラットファイル指定がない場合は BP.OUT を候補に入れる
			Open "BP.OUT" To fpFlat Then
				fileType = FileInfo(fpFlat,3)
				If fileType = 4 Then
					flatFile = "BP.OUT"
				End
			End
		End Else If UpCase(words<1>) Matches Convert(" ",@VM,"GET.LIST SAVE.LIST COPY.LIST SORT.LIST EDIT.LIST") Then
			!! VerbがSaved.List系でフラットファイル指定がない場合は $SAVEDLIST に入れる
			Open SAVEDLISTS.FILE To fpFlat Then
				fileType = FileInfo(fpFlat,3)
				If fileType = 4 Then
					flatFile = SAVEDLISTS.FILE
				End
			End
		End
	End
	
	slist = ""
	slistU = ""
	dlist = ""
	If flatFile Then
!! 		showDesc = Not(flatFile[4] = ".OUT")
		SelectV fpFlat To sp
		Loop
			ReadNext @ID From sp Else Exit
			idU = UpCase(@ID)
			Locate idU In slistU By "AL" Setting no Else
				Ins idU Before slistU<no>
				Ins @ID:" " Before slist<no>
!! 重くなる時があるのでやめる
!! 				If showDesc Then
!! 					ReadV f1 From fpFlat,@ID,1 Then
!! 						Ins f1 Before dlist<no>
!! 					End Else
!! 						Ins "-" Before dlist<no>
!! 					End
!! 				End
			End
		Repeat
	End
	Close fpFlat
Return

*--------------------------------
* シェルの終了
*--------------------------------
QUIT.SHELL:
	
	** 反転入力モードに戻す
$IFDEF U2__UNIVERSE
	Ttyget ttys Then
		If ttys<1,1> = 3 Then; * EMULATE mode
			ttys<4,4> = @TRUE; * Invert
			Ttyset ttys Else Null
		End
	End
$ELSE
	x = PTERM(3,3)
	x = PTERM(2,@TRUE)
$ENDIF

	If Not(bFirstCurTop) Then
		** 代替画面バッファ開いてる場合は閉じる
		Crt ESC:"[?1049l"
	End
	
	** テーマをリセット
	Crt ESC:"]R":ESC:"[?69l"
	
	** Shellを抜ける
	Print ""
	Stop

*--------------------------------
* コマンドスタック進む Action
*--------------------------------
ACTION.CMDSTACK.NEXT:
	
	If DCount(cmdStack,@FM) > cmdStackPos Then
		If Trim(cmdline)[1,1] <> "." Then
			cmdStackPage<cmdStackPos> = cmdline ;** 現在行の保存
		End
		cmdStackPos += 1
		If DCount(cmdStackPage,@FM) < cmdStackPos Then
			If cmdStackPage<cmdStackPos> = "" Then
				cmdStackPage<cmdStackPos> = cmdStack<cmdStackPos>
			End
		End
		cmdline = cmdStackPage<cmdStackPos>
		curPos = Len(cmdline) + 1
	End
	
Return

*--------------------------------
* コマンドスタック戻る Action
*--------------------------------
ACTION.CMDSTACK.BACK:
	
	If 1<cmdStackPos Then
		If Trim(cmdline)[1,1] <> "." Then
			cmdStackPage<cmdStackPos> = cmdline ;** 現在行の保存
		End
		cmdStackPos -= 1
		cmdline = cmdStackPage<cmdStackPos>
		curPos = Len(cmdline) + 1
	End
	
Return

*--------------------------------
* コマンドスタック一覧表示 Action
*--------------------------------
ACTION.CMDSTACK.LIST:
	
	!! 範囲パラメータの習得
	f1 = MatchField(cmdline,"'.L'0N...",2)
	f2 = MatchField(cmdline,"'.L'0N,0N...",4)
	If f2 Then
		cmdStackList.DispCnt<1> = f1 + 1
		cmdStackList.DispCnt<2> = f2 - 1
	End Else If f1 Then
		cmdStackList.DispCnt<1> = cmdStackPos + 1
		cmdStackList.DispCnt<2> = f1 - 1
	End Else If Trim(cmdline) = ".L" Then
		!! 前回のパラメータを利用
	End Else
		!! List VOC
		id = Trim(cmdline[' ',2,999])
		Read rec From VOC,id Then
			!! Print Voc
			BufInfo<BI.PARSETYPE> = If rec[1,2] = "PA" Then PARSE.PARA Else PARSE.DATA
			Row = ""
			Print ""
			
			!! 1行目はすべてコメント
			cnt = DCount(rec,@FM)
			Print "001  ":HI.COMMENT.ON:rec<1>
			
			!! 2行目以降を汎用ハイライト
			For i = 2 To cnt
				Line = rec<i>
				GoSub ParseLine
				Print SGR.ALL.OFF:(i "R%3"):"  ":PLine
			Next i
			GoTo Run.Command.Ending
		End
	End
	
	!! 最大値チェック
	cmdStackList.DispCnt<2> = Minimum(cmdStackList.DispCnt<2>:@FM:(@CRTHIGH-2))
	
	filterWord = cmdline[' ',2,999]
	filterWordU = UpCase(filterWord)
	
	result = ""
	cnt = 0
	cmdStack.len = DCount(cmdStack,@FM)
	For i = cmdStackList.DispCnt<1> To cmdStack.len
		If cmdStackPage<i> <> "" Then
			cmd = cmdStackPage<i>
			modify = If cmd <> cmdStack<i> Then "*" Else " "
		End Else 
			cmd = cmdStack<i>
			modify = " "
		End
		If cmd = "" Then Exit
		If filterWord >< "" Then
			If Not(Index(UpCase(cmd),filterWordU,1) Or cmd Matches filterWord) Then Continue
		End
		result<-1> = (i-1):@VM:cmd:@VM:modify
		cnt += 1
		If cmdStackList.DispCnt<2> < cnt Then Exit
	Next
	w = Maximum(Len(i):@FM:2)
	
	!! 画面出力
	Print ""
	For i = cnt To 1 Step -1
		Print result<i,3>:FMT(result<i,1>,w:"R"):" ":result<i,2>
	Next i

	!! コマンドを保存
	prevListStackCmd = cmdline

	!! 現在行の調整
	GoSub ACTION.CMDSTACK.NEXT
	GoSub ACTION.CMDSTACK.BACK
	
GoTo Run.Command.Ending

*--------------------------------
* コマンドスタックジャンプ Action
*--------------------------------
ACTION.CMDSTACK.GOTO:
	
	no = MatchField(cmdline,"'.G'0N...",2)
	cmdline = ""
	curPos = 1
	If no <> "" And DCount(cmdStack,@FM) > no + 1 Then
		cmdStackPos = 1
		Loop
			GoSub ACTION.CMDSTACK.NEXT
			If cmdStackPos = no + 1 Then Exit
		Repeat
	End
	GoTo Shell.KeyLoop.End

*--------------------------------
* コマンドスタックインクリ検索 Action
*--------------------------------
ACTION.CMDSTACK.INC.SEARCH:
	
	If iSearchText Then
		stackPos = cmdStackPos
		If bIncSearch = "R" Then
			!! 履歴遡り
			Loop
				GoSub ACTION.CMDSTACK.NEXT
				If cmdline Matches "...":iSearchText:"..." Then Exit
				If DCount(cmdStack,@FM) <= cmdStackPos Then
					!! 見つからなかった
					cmdStackPos = stackPos
					cmdline = cmdStackPage<cmdStackPos>
					Exit
				End
			Repeat
		End Else
			!! 履歴遡り
			Loop
				GoSub ACTION.CMDSTACK.BACK
				If cmdline Matches "...":iSearchText:"..." Then Exit
				If 1 >= cmdStackPos Then
					!! 見つからなかった
					cmdStackPos = stackPos
					cmdline = cmdStackPage<cmdStackPos>
					Exit
				End
			Repeat
		End
	End
	
	Return

*--------------------------------
* コマンドスタック行のAPPEND Action
*--------------------------------
ACTION.CMDSTACK.APPEND:

	no = MatchField(cmdline,"'.A'0N...",2)
	If no="" Then no=1
	
	If cmdStackPage<no+1> = "" Then cmdStackPage<no+1> = cmdStack<no+1>
	cmdStackPage<no+1> := cmdline[4+Len(no),9999]

	!! 一覧表示
	cmdline = ".L":no:",1"
	GoTo ACTION.CMDSTACK.LIST

*--------------------------------
* コマンドスタック行のSAVE Action
*--------------------------------
ACTION.CMDSTACK.SAVE:
	
	cmd = Trim(cmdline[4,9999])
	
	startNo = MatchField(cmdline,"'.S'0N...",2)
	endNo   = MatchField(cmdline,"'.S'0N'-'0N...",4)
	paName  = Trim(cmdline[' ',2,1])
	
	If paName <> "" Then

		If endNo = "" Then endNo = 1
		
		startNo += 1
		endNo += 1
		
		If startNo < endNo Then
			a = startNo
			startNo = endNo
			endNo = a
		End
		
		Print ""
		ReadU rec From VOC,paName Then
			Print 'Item "':paName:'" already exists in VOC.'
			Print " Overwirte (Y)":
			Input ans
			If UpCase(Trim(ans)) = "Y" Else GoTo Shell.KeyLoop.End
			rec = rec<1> ;** 1行目を残す
		End Else
			rec = "PA Created at ":OConv(Date(),"D-YMD"):" ":OConv(Time(),"MTS"):" by ":@LOGNAME:"@":@ACCOUNT
		End
		For i = startNo To endNo Step -1
			rec<-1> = If cmdStackPage<i> = "" Then cmdStack<i> Else cmdStackPage<i>
		Next
		Write rec To VOC,paName On Error Print "Cannot Write to VOC."
		Print 'Item "':paName:'" Saved in VOC.'
		
	End
	
GoTo Shell.Input.Begin ;* キーループに戻る


*--------------------------------
* コマンドスタック行の読込 Action
*--------------------------------
ACTION.CMDSTACK.READ:

	cmdline = Trim(cmdline)
	n = MatchField(cmdline,"'.R'0N...",2)
	m = MatchField(cmdline,"'.R'0N'-'0N...",4)
	
	cmdlines = ""
	cmdlines_page = ""
	If cmdline = ".R" Then
		!! Duplicate Case
		cmdlines = cmdStack<2>
		cmdlines_page = cmdlines
	End Else If cmdline[1,3] = ".R " Then
		!! VOCからリード Case
		name = Trim(cmdline[4])
		Read rec From VOC,name Then
			If rec[1,1] = 'P' Or rec[1,1] = 'S' Then
				cmdlines = rec[@FM,2,9999]
				cmdlines_page = cmdlines
			End
		End
	End Else If n Then
		!! Stackからリード Case
		If m = "" Then m = n ;** 1行にする
		If Num(n) And Num(m) Then
			min_no = Minimum(n:@FM:m)
			max_no = Maximum(n:@FM:m)
			For i = max_no To min_no Step -1
				cmd = cmdStack<i+1>
				If cmdStackPage<i+1> <> "" Then
					cmdlines_page<-1> = cmdStackPage<i+1>
					Del cmdStackPage<i+1> ;** 移動の為削除
				End Else
					cmdlines_page<-1> = cmd
				End
				cmdlines<-1> = cmd
				Del cmdStack<i+1>
			Next i
		End
	End Else
		Return
	End
	
	!! スタックの先頭に挿入
	cmdcnt = DCount(cmdlines,@FM)
	For i = 1 To cmdcnt
		Ins cmdlines<i> Before cmdStack<2>
		Ins cmdlines_page<i> Before cmdStackPage<2>
	Next i
	
	!! 一覧表示
	IF cmdcnt > 0 Then
		cmdline = ".L1,":cmdcnt
		GoTo ACTION.CMDSTACK.LIST
	End
	
GoTo Shell.Input.Begin ;* キーループに戻る

*--------------------------------
* コマンドスタック行の削除 Action
*--------------------------------
ACTION.CMDSTACK.DELETE:

	cmdline = Trim(cmdline)
	
	If cmdline[1,3] = ".D " Then
		!! VOCから削除
		name = Trim(cmdline[4,BIG])
		Read rec From VOC,name Then
			If rec[1,2] = "PA" Or rec[1,1] = "S" Then
				Delete VOC,name
				Print 'Item "':name:'" Deleted From VOC.'
			End
		End
	End Else If n Then
		!! 番号指定で削除
		n = MatchField(cmdline,"'.D'0N...",2)
		m = MatchField(cmdline,"'.D'0N'-'0N...",4)
		
		If n = "" Then n = 1 ;** デフォルトはトップ位置
		If m = "" Then m = n ;** 1行にする
		If Num(n) And Num(m) Then
			min_no = Minimum(n:@FM:m)
			max_no = Maximum(n:@FM:m)
			For i = max_no To min_no Step -1
				Del cmdStack<i+1>
				Del cmdStackPage<i+1>
			Next i
		End
	End

GoTo Shell.Input.Begin ;* キーループに戻る


*--------------------------------
* コマンドスタック行の置換 Action
*--------------------------------
ACTION.CMDSTACK.CHANGE:

	no = MatchField(cmdline[3,9999],"0N...",1)
	cmd = Trim(cmdline[3+Len(no),9999])
	delim = cmd[1,1]
	If Index("/!@#$%&*\:=+-?(){}[]^'|,",delim,1)>0 Else Print " <-- valid delimiter"; GoTo Shell.Input.Begin; * 先頭に戻る

	old=cmd[delim,2,1]
	new=cmd[delim,3,1]
	opt=cmd[delim,4,1]

	If no="" Then no=1
	
	If cmdStackPage<no+1> = "" Then cmdStackPage<no+1> = cmdStack<no+1>
	If opt="G" Then
		cmdStackPage<no+1> = Change(cmdStackPage<no+1>,old,new)
	End Else
		cmdStackPage<no+1> = Change(cmdStackPage<no+1>,old,new,1,1)
	End

	!! 一覧表示
	cmdline = ".L":no:",1"
	GoTo ACTION.CMDSTACK.LIST

* コマンドスタックにつむ
CmdStack.Push:
	cnt =  DCount(cmdline,@FM)
	For i = 1 To cnt
		cmd = cmdline<i>
		Find cmd In cmdStack Setting pos Then
			** 存在するので上位に持ってくる為に削除
			Del cmdStack<pos>
		End
		cmdStack<1> = cmd
		Ins "<NEWLINE>" Before cmdStack<1>
	Next i
	cmdStack = cmdStack[@FM,1,CMD.STACK.SIZE]
	cmdStackPage = cmdStackPage[@FM,1,CMD.STACK.SIZE]
	Return

*--------------------------------
* 直前のファイル名を入力
*--------------------------------
ACTION.INPUT.PREV.FILENAME:
	If prevFileName><"" Then
		InsBuffer = prevFileName
		head = cmdline[1,curPos]
		tail = cmdline[curPos+1,9999]
		If head[1] >< " " Then InsBuffer = " ":InsBuffer ;** headの末端が空白でないなら空白を挿入
		If tail[1,1] >< " " Then InsBuffer = InsBuffer:" " ;** tailの先頭が空白でないなら空白を挿入
		GoSub InsertLines
	End
Return

*--------------------------------
* 補完処理 共通
*--------------------------------
AUTO.COMPLATE:
	
	* 候補なし
	If slist = "" Then Return
	
	If DCount(slist,@FM) = 1 Then
		separator = ""
		Read rec From VOC,slist Then
			** マルチパートファイルは','で続ける
			If rec<1>[1,1]="F" And rec<4>[1,1]="M" Then separator = ","
		End Else If Trans("DICT ":dictName,slist,1,'X')[1,1] = "L" Then
			** L-Typeなら'%'で続ける
			separator = "%"
		End
		commonWord = slist : separator ;* 候補は１つなので確定
		bDispCandidate = @FALSE
		slist = ""
		
	End Else
		If nowWord = slist<1> Then
			commonWord = slist<1>
		End Else
			commonWord = Remove(slist,sep);
			Loop
				verb = Remove(slist,sep);
				If verb><"" Then
					For i = 1 To Len(verb)
						If UpCase(commonWord[i,1]) >< UpCase(verb[i,1]) Then
							commonWord = commonWord[1,i-1];
							Exit;
						End
					Next i
				End
				If sep = 0 Then Exit;
			Repeat
		End
	End

	If nowWord = commonWord Then Return
	
	!! 単語置換
	BufInfo<BI.BLOCKSTART, 1> = Y
	BufInfo<BI.BLOCKSTART, 2> = X - Len(nowWord)
	BufInfo<BI.BLOCKEND, 1> = Y
	BufInfo<BI.BLOCKEND, 2> = X
	InsBuffer = commonWord
	GoSub InsertLines

	!! 誤操作が多いので溜まっているキーキューをクリアする
!! 	Loop
!! $IFDEF U2__UNIVERSE
!! 		Input test,-1
!! $ElSE
!! 		test = KeyReady()
!! $ENDIF
!! 	While test Do
!! 		k = KeyIn()
!! 	Repeat
	Loop
		GoSub GetCh.Timeout
		While ch <> ""
	Repeat

Return

CLEAR.FOR.PERFORM:
	If cmdlineRows - curY > 0 Then
		Crt @(IT$CUD, cmdlineRows - curY):
	End
	Crt
	Crt @(IT$CLEOS):
Return

** -----------------------------------
** カーソルを画面の最上部に移動する
** -----------------------------------
CUR.TOP.OF.SCREEN:
	
	** コマンド実行後１回目だけはクリア画面を呼ぶ
	If bFirstCurTop Then
		crtBuff = ""
		GoSub GoAltScreenBuf ;** 代替画面バッファ
		crtBuff := @(0,0):@(-1)
		Crt crtBuff:
		bFirstCurTop = @FALSE
	End Else
		Crt CSI:"J":ESC.CUR.TOP:@(-3):
	End
	
Return

** ================================================================================
** Editor.Main
** ================================================================================
Editor.Main:
	
*-------------------------------------------------------------------------
*  Set up
*-------------------------------------------------------------------------
	LastCapture = 0
	ItemList = ""
	FileName = ""
	FldInfo = ""
	DiveValuePos = ""
	ParentBufNo = ""
	StatusMessage = ""
	
*-------------------------------------------------------------------------
*  Parse Command Line
*-------------------------------------------------------------------------
ParseCommandLine:
	
	args = Convert(' ',@FM,Trim(editerCmd)[' ',2,HUGE])
	CFileName = Remove(args,s)
	Begin Case
		Case CFileName = ""
		Case 1
			DICT = ""
			If CFileName="DICT" Then
				DICT = "DICT"
				CFileName = Remove(args,s)
			End
			If CFileName <> "" Then
				Open DICT,CFileName To TempFL Else
					Crt "Cannot open ":CFileName
					Return
				End
				FileName = CFileName
				If DICT><"" Then FileName = "DICT ":CFileName
			End
			
			dictFileName = If DICT Then "DICT.DICT" Else "DICT ":FileName

			!! アクティブな選択リストから取得      
			If System(11) Then
				ReadList tmp Then ItemList<-1> = tmp
			End
			
			Loop
				arg = Trim(Remove(args,s))
				If arg = "*" Then
					Select TempFL
					ReadList tmp Then ItemList<-1> = tmp
				End Else If arg >< "" Then
					If Not(DICT) And (Trans(dictFileName,arg,0,'X') Or arg Matches "F1N0N") Then
						!! 辞書にある引数はフィールドとみなす(F1 F2 等は特別)
						FldInfo<-1> = arg
					End Else
						ItemList<-1> = arg
					End
				End
			While s Do
			Repeat
			
			Convert @FM To " " In FldInfo
		
	End Case

	If FileName = "" And ItemList = "" Then
		!! 引数指定がない
		If Not(lruBuffList) Then
			!! バッファがない場合は新規で開く
			GoSub DoNew
		End Else
			!! バッファがある場合は以前開いていたものを開く
			Found = lruBuffList<1> ;** 直近を開く
			GoSub ChangeBuf
		End
	End Else If FileName >< "" And ItemList = "" Then
		!! Item名がない場合はリストから選択
		GoSub DoOpen                    ; * presents a list
		If Not(Found) Then GoSub DoNew
	End Else
		Loop
			Remove ItemName From ItemList Setting s
			GoSub DoRead
		While s Do
		Repeat
	End

	biInfoWide.lineNo = 5 ;** 行番号表示の桁数
	biInfoWide.dict = 0

	DIRec = ""
	SearchString = ""
	Replacing = False
	ignoreCase = False
	searchReverse = False
	
	GoSub GoAltScreenBuf ;** 代替画面バッファ
	
	!! Brackets Paste Mode on
	crtBuff := CSI:"?2004h"
	
!! 	** Mouse Tracking on
!! 	crtBuff := CSI:"?1006h"
	
	Crt crtBuff:
	
	GoSub DoShowDictInfo
	
	GoSub ShowWindow

	!! Editorメインループ  
	AllDone = False
	Loop
	Until AllDone Do
		GoSub Enters
	Repeat
	
	crtBuff = ""
	
	** Brackets Paste Mode off
	crtBuff := CSI:"?2004l"
	
!! 	** Mouse Tracking off
!! 	crtBuff := CSI:"?1006l"
	
	GoSub BackAltScreenBuf ;** 代替画面バッファから戻る
	Crt crtBuff:
	
	CurBuf = CMD_BUF
	
	Return
	
GoAltScreenBuf:
	crtBuff := ESC:"[?1049h"
	crtBuff := ESC:"[?1h"
	crtBuff := ESC:"[?6h"
	crtBuff := ESC:"[?69h"
	crtBuff := ESC:"="
	crtBuff := ESC:"[1;":@CRTHIGH:"r"
	Return

BackAltScreenBuf:
	crtBuff = ESC:"[?1l"
	crtBuff := ESC:"[?1l"
	crtBuff := ESC:">"
	crtBuff := ESC:"[?12l"
	crtBuff := ESC:"[?25h"
	crtBuff := ESC:"[?1049l"
	Return

*--------------------------------------------------------------------------
* Action
*--------------------------------------------------------------------------
Action: 
	MenuLine = "Buffer Edit Ins Code Navi Tools Mark eXit or ESC :"
	GoSub MenuLine
	Menu = Upcase(C)
	Begin Case
		Case Menu = "B"
			GoSub FileMenu
		Case Menu = "E"
			GoSub EditMenu
		Case Menu = "I"
			GoSub InsMenu
		Case Menu = "C"
			GoSub CodeMenu
		Case Menu = "N"
			GoSub SearchMenu
		Case Menu = "T"
			GoSub ToolsMenu
		Case Menu = "M"
			GoSub BookMenu
		Case Menu = "X"
			GoSub Act.Exit
		End Case
	Return
*--------------------------------------------------------------------------
* BookMenu
*--------------------------------------------------------------------------
BookMenu: 
	MenuLine = "Set Go :"
	GoSub MenuLine
	C = UpCase(C)
	Begin Case
		Case C = "S"
			BookMark = Y
		Case C = "G"
			Top = BookMark
			Y = BookMark
			X = 1
			XOffSet = 1
			GoSub PrintPage
		End Case
	Return
*--------------------------------------------------------------------------
* CodeMenu
*--------------------------------------------------------------------------
CodeMenu: 
	MenuLine = "Build Catalog Format Words Mode Indent Help :"
	GoSub MenuLine
	C = UpCase(C)
	Begin Case
		Case C = "B"
			GoSub Act.Compile
		Case C = "C"
			GoSub Catalog
		Case C = "F"
			GoSub Format
		Case C = "W"
			GoSub Act.ShowWordHokan
		Case C = "M"
			GoSub ChangeModeMenu
		Case C = "I"
			GoSub ChangeIndentMenu
		Case C = "H"
			GoSub Act.ShowHelp
		End Case
	Return
*--------------------------------------------------------------------------
* ChangeModeMenu
*--------------------------------------------------------------------------
ChangeModeMenu: 
	MenuLine = "Basic Pragraph Data :"
	GoSub MenuLine
	C = UpCase(C)
	Begin Case
		Case C = "B"
			BufInfo<BI.PARSETYPE> = PARSE.BASIC
			GoSub ShowWindow
		Case C = "P"
			BufInfo<BI.PARSETYPE> = PARSE.PARA
			GoSub ShowWindow
		Case C = "D"
			BufInfo<BI.PARSETYPE> = PARSE.DATA
			GoSub ShowWindow
		End Case
	Return
*--------------------------------------------------------------------------
* ChangeModeMenu
*--------------------------------------------------------------------------
ChangeIndentMenu: 
	MenuLine = "Tab Spaces :"
	GoSub MenuLine
	C = UpCase(C)
	Begin Case
		Case C = "T"
			IndentType = "Tab"
		Case C = "S"
			IndentType = "Spaces"
	End Case
	PromptLine = "Input Indent Size ->"
	GoSub PromptLine
	inputBox = ""
	GoSub InputBox
	If inputBox Matches "0N" Then
		STDTAB = inputBox
	End
	GoSub ShowWindow
	Return
*--------------------------------------------------------------------------
* CheckSave
*--------------------------------------------------------------------------
CheckSave: 
	PromptLine = "Record has changed - Save changes (Y/N) :"; GoSub PromptLine
	GoSub GetKey
	Ok = TriMF(UpCase(C))[1,1] = "Y"
	If Ok Then GoSub SaveItem
Return
*--------------------------------------------------------------------------
* Catalog
*--------------------------------------------------------------------------
Catalog: 
	FileName = BufInfo<BI.FILE>
	ItemName = BufInfo<BI.ITEM>
	MenuLine = "Local, Global, Remote, Normal catalog :"
	GoSub MenuLine
	Crt @(0,0):@(-3):
	Ok = UpCase(TrimF(C))[1,1]
	Begin Case
		Case Ok = "G"
			cmdline = "CATALOG ":FileName:" *":ItemName:" ":ItemName
		Case Ok = "R"
			Write "R":@FM:FileName:@FM:ItemName On VOC, ItemName
			GoSub ShowWindow
			Return
		Case Ok = "L"
			cmdline = "CATALOG ":FileName:" ":ItemName:" LOCAL"
		Case Ok = "N"
			cmdline = "CATALOG ":FileName:" ":ItemName:" LOCAL"
		Case 1
			GoSub ShowWindow
			Return
		End Case
	bAutoCommand = @TRUE
	bAutoEditor = @TRUE
	GoSub Act.Exit
Return

*--------------------------------------------------------------------------
* OConv
*--------------------------------------------------------------------------
DoOConv:

	GoSub GET.SELECTION.STRING
	If selString = "" Then
		StatusMessage = "Need Selection For OConv Source Data"
		Return
	End

	PromptLine = "Input Conversion Code ->"
	GoSub PromptLine
	inputBox = ""
	GoSub InputBox
	inputVal = inputBox
	
	InsBuffer = OConvS(Convert(CHAR(10),@FM,selString),inputVal)
	GoSub InsertLines

Return
*--------------------------------------------------------------------------
* IConv
*--------------------------------------------------------------------------
DoIConv:

	GoSub GET.SELECTION.STRING
	If selString = "" Then
		StatusMessage = "Need Selection For IConv Source Data"
		Return
	End

	PromptLine = "Input Conversion Code ->"
	GoSub PromptLine
	inputBox = ""
	GoSub InputBox
	inputVal = inputBox
	
	InsBuffer = IConvS(Convert(CHAR(10),@FM,selString),inputVal)
	GoSub InsertLines
	
Return
	
*--------------------------------------------------------------------------
* Get Selection String
*--------------------------------------------------------------------------
GET.SELECTION.STRING:

	selString = ""
	blockStart = ""
	If BufInfo<BI.BLOCKSTART> Then
		blockStart = Raise(BufInfo<BI.BLOCKSTART>)
		blockEnd = Raise(BufInfo<BI.BLOCKEND>)
		If blockStart<1> > blockEnd<1> Then tmp = blockStart; blockStart = blockEnd; blockEnd = tmp
		
		If blockStart<1> = blockEnd<1> Then
			** １行内での選択
			If blockStart<2> > blockEnd<2> Then
				tmp = blockStart; blockStart = blockEnd; blockEnd = tmp
			End
			len = blockEnd<2> - blockStart<2>
			selString = Rec<blockStart<1>>[blockStart<2>,len]
		End Else
			
			** 開始行
			Row = blockStart<1>
			selString = Rec<Row>[blockStart<2>,HUGE]
			
			** 中行
			For Row = Row+1 To blockEnd<1> - 1
				selString := @FM:Rec<Row>
			Next
			
			** 最終行
			selString := @FM
			If blockEnd<2> > 1 Then selString := Rec<blockEnd<1>>[1,blockEnd<2>-1]
			
			selString = Convert(@FM,CHAR(10),selString)
		
		End
		
	End
	
Return

*--------------------------------------------------------------------------
* StackEditCmd
*--------------------------------------------------------------------------
StackEditCmd:
	
	** editコマンドを実行する
	GoSub DoEditCmd
	
	If EditCmdPos > 1 Then
		EditCmdStack = EditCmdStack[@FM,EditCmdPos,HUGE]
		EditCmdPos = 1
	End
	** RedoとUndoをペアでスタックに登録
	Ins Convert(@FM,@SVM,editCmd):@VM:Convert(@FM,@SVM,undoCmd) Before EditCmdStack<1>
	
!!   StatusMessage = Convert(@FM:@VM:CHAR(10),"|,\",EditCmdStack)
	
	If Changed Else Changed = True; Redraw.StatusLine = @TRUE
		
Return

*--------------------------------------------------------------------------
* DoEditCmd
*--------------------------------------------------------------------------
DoEditCmd:
	
	undoCmd = "" ;** Out : Undo用コマンド
	
	Loop
		stY = Remove(editCmd,sep)
		stX = Remove(editCmd,sep)
		endY = Remove(editCmd,sep)
		endX = Remove(editCmd,sep)
		strings = Convert(CHAR(28):CHAR(29):CHAR(31),@SM:@VM:@IM,Remove(editCmd,sep))
		curFlg = Remove(editCmd,sep)
		
		prevStrings = "" ;** 置換前の文字列
		prevCurFlg = "1"
		
		If endY >< "" Then
			**
			** 選択範囲削除
			**
			
			If stY = endY Then
				** １行内での選択
				If stX > endX Then tmp = stX; stX = endX; endX = tmp; prevCurFlg=""
				
				prevStrings = Rec<stY>[stX,endX-stX]
				If stX = Len(Rec<stY>)+1 & stX + 1 = endX Then
					** 改行の削除
					prevStrings = CHAR(10)
					Rec<stY> := Rec<stY+1>
					Del Rec<stY+1>
					Redraw = REDRAW.ALL
				End Else
					Rec<stY> = Rec<stY>[1,stX-1]:Rec<stY>[endX,HUGE]
					If Redraw >< REDRAW.ALL Then Redraw<-1> = stY
				End
				
			End Else
				If stY > endY Then tmp = stY; stY = endY; endY = tmp; tmp = stX; stX = endX; endX = tmp; prevCurFlg=""
				
				** 開始行
				Row = stY
				prevStrings = Rec<Row>[stX,HUGE]
				
				** 中行
				For Row = Row+1 To endY - 1
					prevStrings := CHAR(10):Rec<Row>
				Next
				
				** 最終行
				prevStrings := CHAR(10)
				If endX > 1 Then prevStrings := Rec<endY>[1,endX-1]
				
				** 開始行と最終行つなげる
				Rec<stY> = Rec<stY>[1,stX-1]:Rec<endY>[endX,HUGE]
				
				** 中行削除
				rangeY = endY - stY
				For i = 1 To rangeY
					Del Rec<stY+1>
				Next
				
				Redraw = REDRAW.ALL
			End
		
			** 最終カーソル位置を反映する
			Y = stY
			If Not(curFlg & stX = endX) Then
				!! 開始X位置と終了X位置が同じ場合はXを移動させない
				X = stX
			End Else
				moveY = @TRUE
			End

		End
		
		endY = stY
		endX = stX
		
		cmd = ""
		cmd<1> = stY
		cmd<2> = stX
			
		If strings >< "" Then
			**
			** 文字列挿入
			**
			
			strings = Convert(CHAR(10):CHAR(13),@FM:@FM,Change(strings,CHAR(13):CHAR(10),CHAR(10)))
			If stX > 1 Then
				Rec<stY> = Rec<stY>[1,stX-1]:strings:Rec<stY>[stX,HUGE]
			End Else
				Rec<stY> = strings:Rec<stY>
			End
			stringRows = DCount(strings,@FM)
			If stringRows = 1 Then
				** 単一行
				endX += Len(strings)
				If Redraw >< REDRAW.ALL Then Redraw<-1> = stY
			End Else
				** 複数行
				endY += stringRows - 1
				endline = strings<stringRows>
				endX = Len(endline) + 1
				Redraw = REDRAW.ALL
			End
			
			If curFlg Else
				** 最終カーソル位置を反映する
				Y = endY
				X = endX
			End
			
			cmd<3> = endY
			cmd<4> = endX
			
		End Else
			
			cmd<3> = ""
			cmd<4> = ""
			
		End
		
		cmd<5> = Convert(@IM:@FM:@VM:@SM,CHAR(31):CHAR(10):CHAR(29):CHAR(28),prevStrings)
		cmd<6> = prevCurFlg
		
		Ins cmd Before undoCmd<1> ;** 逆順に追加していく
		
	While sep Repeat
	
Return

*--------------------------------------------------------------------------
* GetJumpData
*--------------------------------------------------------------------------
GetJumpData:
	jumpData = @PATH
	If IsNew Then
		jumpData<1,2> = "<<New>>"
		jumpData<1,3> = CurBuf
	End Else
		jumpData<1,2> = BufInfo<BI.FILE>
		jumpData<1,3> = BufInfo<BI.ITEM>
	End
	jumpData<1,4> = Y
	jumpData<1,5> = X
	jumpData<1,6> = Rec<Y>[X,1]
	jumpData<1,7> = Lines
	jumpData<1,8> = Top
	jumpData<1,9> = XOffSet
	If jumpData<1,2> = "" And jumpData<1,3> = "" Then jumpData = ""
Return

*--------------------------------------------------------------------------
* StackJumpHistory
*--------------------------------------------------------------------------
StackJumpHistory: ;** Jump履歴の蓄積
	
	jumpHistoryPos = 0
	
	!! 重複は排除してスタックに積む
	GoSub GetJumpData
	If jumpData >< "" And jumpData >< jumpHistory<1> Then
		Ins jumpData Before jumpHistory<1>
		Del jumpHistory<31> ;** Jump履歴は30個までとする
	End

Return

*--------------------------------------------------------------------------
* RestoreFromJumpData
*--------------------------------------------------------------------------
RestoreFromJumpData: ;** jumpDataからカーソル位置を復元

	If jumpData = "" Then Return
	
	!! Accountが違っていたら開くことはできない
	If jumpData<1> >< @PATH Then Return
	
	!! 現在のファイルでなかったらレコードを開く
	If Not(jumpData<2> = BufInfo<BI.FILE> And jumpData<3> = BufInfo<BI.ITEM>) Then
		If jumpData<2> = "<<New>>" Then
			!! バッファ指定
			Found = jumpData<3>
			If Not(BufInfos(Found)<BI.USED>) Then Return 
			CurBuf = Found
		End Else
			!! レコード指定
			FileName = jumpData<2>
			ItemName = jumpData<3>
			GoSub DoRead.Without.Jump
			If Not(Found) Then Return
		End
	End
	
	!! カーソル位置の整合性チェック
	tY = jumpData<4>
	tX = jumpData<5>
	If Rec<tY>[tX,1] >< jumpData<6> Then
		If Line >< jumpData<7> Then
			!! 行数の変化を補正して再チェック
			tY += Lines - jumpData<7>
			If Rec<tY>[tX,1] >< jumpData<6> Then Return
		End Else Return
	End
	
	!! カーソル移動実行
	Y = tY
	X = tX
	keepDP_X = X
	Top = jumpData<8>
	XOffSet = jumpData<9>
	
	Top = Y - Int(Depth / 2) ;** センタリング
	If Top < 1 Then Top = 1
	
	jumpData = "" ;** JumpできたらjumpDataをクリアする

Return

*---------------------------------------------------------------------------
* DoConfig - configure terminal
*---------------------------------------------------------------------------
DoConfig: 
	Return
*--------------------------------------------------------------------------
* DoInsert
*--------------------------------------------------------------------------
DoInsert: 
	GoSub GetFile
	If FileName = "" then Return
	GoSub GetItem
	If ItemName = "" Then Return
	Read Temp From TFL, ItemName Else
		StatusMessage = "Cannot Read ":FileName:" ":ItemName
		Redraw = REDRAW.ALL
		Return
	End
	InsBuffer = Temp
	GoSub InsertLines
Return
	
*--------------------------------------------------------------------------
* DoRead
*--------------------------------------------------------------------------
DoRead:

	!! 現在位置をJump履歴に格納
	GoSub StackJumpHistory

	GoSub DoRead.Without.Jump
	
	!! 見つからなかった場合は格納したJump履歴を消す
	If Not(Found) Then Del jumpHistory<1>
	
Return

*--------------------------------------------------------------------------
* DoRead.Without.Jump
*--------------------------------------------------------------------------
DoRead.Without.Jump:

	Found = False
	
	!! Buffer内にすでに該当のItemが存在するか調べる
	listCnt = DCount(lruBuffList,@FM)
	For I = 1 To listCnt Until Found
		no = lruBuffList<I>
		info = BufInfos(no)
		If info<BI.USED> Then
			If @PATH = info<BI.ACCOUNT> And info<BI.ITEM> = ItemName And info<BI.FILE> = FileName And info<BI.FIELDFIX> = FldInfo And info<BI.PBUFNO> = ParentBufNo And info<BI.VALUEFIX> = DiveValuePos Then
				Found = no
				GoSub ChangeBuf
				Return
			End
		End
	Next

	If FileName = "" And ItemName = "" Then
		!! 新規作成
		GoSub DoNew
		Return
	End
	
	!! 空きBuffer取得
	GoSub GetFreeBuf
	If Not(Found) Then
		StatusMessage = "Cannot Get Free Buffer"
		Return
	End
	
	CurBuf = Found ;** CurBufをセット
	IsNew = False

	!! バッファ番号を直近リストの先頭に設定
	Ins CurBuf Before lruBuffList<1>
	
	GoSub Common.OpenFile
	GoSub ReadItem
	
Return

** ファイルを開くの共通化
Common.OpenFile:
	
$IFDEF U2__UNIVERSE
	Open FileName To FL Else
		StatusMessage = "Cannot Open ":FileName
		Return
	End
$ELSE
	If FileName[1,5] = "PATH:" Then
		!! PATH:なら READ:自動認識 WRITE:UTF8
		Open FileName ENCODING "UTF8.A" To FL Else
			StatusMessage = "Cannot Open ":FileName
			Return
		End
	End Else
		Open FileName To FL Else
			StatusMessage = "Cannot Open ":FileName
			Return
		End
	End
$ENDIF

Return

*-----------------------------------------------------------------------
*  ReadItem
*-----------------------------------------------------------------------
ReadItem:

	If ParentBufNo Then
		!! 親バッファからコピー
		Rec = Bufs(ParentBufNo)
	End Else
		!! ファイルから開く
		Read Rec From FL,ItemName Else
			Rec = ""
			IsNew = True
		End
		!!
		!! レコードの読み取り
		!! 更新ロックが取れるか一度試して取れなければReadOnlyにする
		!!
		RecordLockU FL,ItemName Locked
			StatusMessage = "Record previously Locked by ":Status():", Open as Read Only mode"
			ReadOnly = True 
		End
		Release FL, ItemName ;** 更新ロックは常時保持はしない
	End

	GoSub StartBuf

	!! 改行コードが残っていたら自動除外
	Convert CHAR(10):CHAR(13) To '' In Rec

	TgtFld = "" ;** フィールドのリスト 
	If FldInfo Then
		!! フィールド指定モード
		dictFileName = "DICT ":FileName

		list = Convert(' ',@FM,FldInfo)
		cnt = DCount(list,@FM)
		For i = 1 To cnt
			fldInfo = ""
			fldInfo<1> = ""      ;** 1:location
			fldInfo<2> = list<i> ;** 2:fieldId
			fldInfo<3> = ""      ;** 3:Conv 
			If fldInfo<2> Matches "F0N" Then
				fldInfo<1> = fldInfo<2>[2,9999]
			End Else
				dictRec = Raise(Trans(dictFileName,fldInfo<2>,-1,'X'))
				If dictRec[1,1] = "D" And dictRec<2> >= 1 Then
					fldInfo<1> = dictRec<2> ;** location
					fldInfo<3> = dictRec<3> ;** Conv
				End Else If dictRec[1,2] = "PH" Then
					!! PHraseで置き換えてもう一度
					list<i> = @FM:Convert(' ',@FM,dictRec<2>)
					cnt = DCount(list,@FM)
					Continue
				End
			End
			If fldInfo<1> Then
				!! 物理位置が存在したら登録する
				TgtFld<-1> = Lower(fldInfo)
			End
		Next
		TgtFld.Cnt = DCount(TgtFld,@FM)
		
		!! マルチバリューを行展開したレコードの構築
		tmpRec = ""
		fCnt = DCount(TgtFld,@FM)
		For f = 1 To fCnt
			If BufInfo<BI.VALUEFIX> Then
				!! バリューにダイブ
				no = f + (BufInfo<BI.VALUEFIX> - 1) * fCnt
				sep = @SVM
			End Else
				!! フィールド固定モード
				no = TgtFld<f,1>
				sep = @VM
			End
			list = Rec<no>
			
			If Not(ParentBufNo) Then
				!! 物理ファイルからの場合はConversionがあれば適応
				conv = TgtFld<f,3>
				If conv Then list = OConvS(list,conv)
			End
			
			cnt = DCount(list,sep)
			For v = 1 To cnt
				tmpRec<f + (v - 1) * fCnt> = Field(list,sep,v)
			Next
		Next
		Rec = tmpRec ;** 抽出したレコードに置き換え
		
	End

	!! 現在の行数の設定
	Lines = If Rec = "" Then 1 Else DCount(Rec,@fm)

	** 辞書ならバイナリデータを削る
	If FileName[1,4] = "DICT" Then Rec = Rec[@FM,1,15] 

Return
	
*-----------------------------------------------------------------------
*  DoLock
*-----------------------------------------------------------------------
DoLock:
	
	If ReadOnly Then
		StatusMessage = "Cannot get RU Lock at Read Only mode"
		Return
	End
	
	FileName = BufInfo<BI.FILE>
	ItemName = BufInfo<BI.ITEM>
	
	!! レコード格納先ファイルのオープン
	GoSub Common.OpenFile
	
	If BufInfo<BI.LOCKED> Then    
		** ロック中ならロックを外す
		Release FL, ItemName
		BufInfo<BI.LOCKED> = @FALSE
	End Else
		** ロック中でないなら更新ロックを取得する
		If Changed Then GoSub CheckSave
		If Changed Then Return
		RecordLockU FL, ItemName Locked
			StatusMessage = "Record previously Locked by ":Status()
			Return
		End
		BufInfo<BI.LOCKED> = @TRUE
	End
	
Return

*-----------------------------------------------------------------------
*  DoList
*-----------------------------------------------------------------------
DoList: 
	LTop = 0
	LRefresh = True
	LFin = False
	Option = ""
	Loop
	Until LFin Do
		If LRefresh Then
			Crt @(0,0):@(-3):
			For LI = 1 to LISTDEPTH
				Crt @(0,LI + 1):(LI + LTop "R#5"):". ":List<LI + LTop>:
			Next
			LRefresh = False
		End
		PromptLine = "Up Down Top Bottom number or ESC :"; GoSub PromptLine
		GoSub GetKey
		Begin Case
			Case Upcase(C) = "U" Or actNo = A.UP
				If LTop >= LISTDEPTH Then
					LTop -= LISTDEPTH
					LRefresh = True
				End
			Case Upcase(C) = "D" Or actNo = A.DOWN
				LTop += LISTDEPTH
				LRefresh = True
			Case actNo = A.CANCEL
				LFin = True
			Case C Matches "1n"
				Number = C
				Crt C:
				Input C
				Number := C
				If Number Matches "1n0n" then
					If Number > 0 And Number <= DCount(List,@fm) Then
						Option = List<Number>
						LFin = True
					end
				End
			End case
	Repeat
	Return
*-----------------------------------------------------------------------
*  DoNew
*-----------------------------------------------------------------------
DoNew:  
	FileName = ""
	ItemName = ""
	GoSub GetFreeBuf
	If Not(Found) Then Return
	GoSub StackJumpHistory
	CurBuf = Found
	Ins CurBuf Before lruBuffList<1>
	Rec = ""
	GoSub StartBuf 
	IsNew = True
	Return
*-----------------------------------------------------------------------
*  DoPrint
*-----------------------------------------------------------------------
DoPrint: 
	Crt @(0,@CRTHIGH-2):
	Echo Off
	Printer On
	Echo On
	PWidth = @LptrWide - 5
	PDepth = @LptrHigh - 3
	Dc = DCount(Rec,@fm)
	PLine= ""
	PRow = 0
	PNo = 0
	PPage = 1
	Printer On
	GoSub DoPrintHeader
	Loop
		PNo += 1
	Until PNo > Dc Do
		PLine = Rec<PNo>
		SOL = @TRUE
		Loop
			If SOL Then
				OutLine = PNo "R%4":":"
			End Else
				OutLine = " ==> "
			End
			OutLine := PLine[1, PWidth]
			PLine = PLine[PWidth+1, HUGE]
			PRow += 1
			SOL = @False
			If PRow > PDepth Then
				GoSub DoPrintFooter
				GoSub DoPrintHeader
			End
			Print OutLine
		Until PLine = "" Do
		Repeat
	Repeat
	GoSub DoPrintFooter
	Crt @(0,@CRTHIGH-2):
	Printer Off
	Echo Off
	Crt @(0,@CRTHIGH-2):
	Printer Close
	Echo On
	StatusMessage = ""
	Return
*-----------------------------------------------------------------------
*  DoPrintFooter
*-----------------------------------------------------------------------
DoPrintFooter: 
	Print Str("-",@LptrWide)
	Print OConv(date(),"D4"):" Page ":PPage
	Page
	PPage += 1
	Return
*-----------------------------------------------------------------------
*  DoPrintHeader
*-----------------------------------------------------------------------
DoPrintHeader: 
	If BufInfo<BI.FILE> = "" Then
		Print "Untitled"
	End Else
		Print BufInfo<BI.FILE>:" ":BufInfo<BI.ITEM>
	End
	Print Str("-",@LptrWide)
	Print
	PRow = 3
	StatusMessage = "Printing Page ":PPage
	Return
*-----------------------------------------------------------------------
*  DoOpen
*-----------------------------------------------------------------------
DoOpen: 
	GoSub GetFile
	If FileName = "" Then Return
	GoSub GetItem
	If ItemName = "" then Return
	GoSub DoRead
	Return


*-------------------------------------------------------------------------
*  辞書による補助表示
*-------------------------------------------------------------------------
DoShowDictInfo:
	
	IF FileName = "" Then Return ;** Newバッファは無視
	
	If FileName[1,4] = "DICT" Then
		!! 辞書の場合は固定
		DIRec = Convert(",",@FM,"TYPE,LOC,CONV,NAME,FMT,S/M,ASSOC")
	End Else
		Open "DICT",FileName To fpDict Then
			If TgtFld Then
				For i=1 To DCount(TgtFld,@FM)
					Read dictRec From fpDict,TgtFld<i,2> Then
						DIRec<i> = dictRec<6>:" ":dictRec<4>:If dictRec<3> Then " {":dictRec<3>:"}" Else "" 
					End
				Next
			End
			Close fpDict
		End Else
			StatusMessage = "Cannot Open DICT ":FileName
		End
	End
	
	If DIRec Then biInfoWide.dict = Maximum(LenSDP(DIRec)) + 1

	Return

DoHideDictInfo:

	biInfoWide.dict = 0
	DIRec = ""

	Return

*-----------------------------------------------------------------------
*  InitChoiceList
*    In :
*      choiceList - 選択データ @FM区切り 1Value目が表示される
*      choiceNo - 初期選択位置
*      title - ウィンドウの色とタイトル
*-----------------------------------------------------------------------
InitChoiceList: ;** 選択リストボックス初期化

	choiceList.length = DCount(choiceList,@FM)
	tmp = ""
	For i = 1 To choiceList.length
		tmp<-1> = LenDP(choiceList<i,1>)
	Next
	winWidth = Maximum("20":@FM:tmp)
	If winWidth > Width Then winWidth = Width
	winX = Width - winWidth
	winHeight = Depth - 2
	winTop = 0
	
	crtBuff = @(winX,0):title:@(-4)
	crtBuff := @(winX,1):" "
	For i = 1 To winHeight
		crtBuff := @(winX,i+1):" "
	Next
	Crt crtBuff:
	
	For i = 1 To choiceList.length
$IFDEF U2__UNIVERSE
		choiceList<i,1> = choiceList<i,1>[1,Len(FoldDP(Convert(" ","-",choiceList<i,1>),winWidth,"UTF8")<1>)]
$ELSE
		choiceList<i,1> = choiceList<i,1>[1,Len(FoldDW(Convert(" ","-",choiceList<i,1>),winWidth)<1>)]
$ENDIF
	Next
	choiceOutList = choiceList
	choiceOutList.org = choiceList
	choiceOutList.length = choiceList.length
	winX += 1
	filter = ""
	filterPrev = ""
	C = ""
	
Return
*-----------------------------------------------------------------------
*  ProcChoiceList
*    In :
*      C - キーコード
*    Out :
*      choiceSelection - 選択された物 choiceList<choiceNo>
*      filter - フィルタ
*-----------------------------------------------------------------------
ProcChoiceList:

	!! キーイベント共通
	If C >< "" Then
		Begin Case
		
		!! インクリメンタルサーチ
			Case actNo = A.INSCHAR
				filter := C
			Case actNo = A.BACKSPACE
				filter = filter[1,Len(filter)-1]
				
		!! リストの操作
			Case actNo = A.UP
				choiceNo -= 1
			Case actNo = A.DOWN
				choiceNo += 1
			Case actNo = A.PREVSTMT
				choiceNo -= 4
			Case actNo = A.NEXTSTMT
				choiceNo += 4
			Case actNo = A.PREVPAGE
				choiceNo -= winHeight
			Case actNo = A.NEXTPAGE
				choiceNo += winHeight
			Case actNo = A.PREVHALF
				choiceNo -= Int(winHeight / 2)
			Case actNo = A.NEXTHALF
				choiceNo += Int(winHeight / 2)
			Case actNo = A.HOME
				choiceNo = 1
			Case actNo = A.END
				choiceNo = choiceOutList.length
		End Case
		C = ""
	End

	!! 選択範囲チェック
	If choiceNo < 1 Then choiceNo = 1 Else
		If choiceNo >= choiceOutList.length Then choiceNo = choiceOutList.length
	End

	!! フィルター処理
	If filter >< filterPrev Then
		choiceOutList = ""
		choiceOutList.org = ""
		filter.len = Len(filter)
		filterUpper = UpCase(filter)
		For i = 1 To choiceList.length
			line = choiceList<i>
			p = Index(UpCase(line<1,1>),filterUpper,1)
			If p Then
				choiceOutList.org<-1> = line
				line<1,1> = line<1,1>[1,p-1]:@SVM:line<1,1>[p,filter.len]:@SVM:line<1,1>[p+filter.len,9999]
				choiceOutList<-1> = line
			End
		Next
		choiceOutList.length = DCount(choiceOutList,@FM)
		choiceNo = 1
		filterPrev = filter
	End

	!! リスト表示
	tmpY = winTop + SCROLLMERGINE + 1
	If choiceNo < tmpY Then
		winTop -= tmpY - choiceNo
		If winTop < 0 Then winTop = 0
	End Else
		tmpY = winHeight + winTop - SCROLLMERGINE
		If choiceNo > tmpY Then
			winTop += choiceNo - tmpY
		End
	End
	
	crtBuff = SGR.ALL.OFF
	listLen = choiceOutList.length - winTop
	If listLen > winHeight Then listLen = winHeight
	i = 1
	Loop While i <= listLen
		selected = (choiceNo = winTop+i) ;** 選択行か？
		line = Raise(Raise(choiceOutList<winTop+i,1>))
		crtBuff := @(winX,i+1)
		crtBuff := If selected Then HI.SELECT1 Else CSI:FG.BASE01:";":BG.BASE2:";22m"
		crtBuff := line<1>
		If line<2> Then
			crtBuff := CSI:FG.RED:"m"
			crtBuff := line<2>
		End
		If line<3> Then
			crtBuff := If selected Then HI.SELECT1 Else CSI:FG.BASE01:";":BG.BASE2:";22m"
			crtBuff := line<3>
		End
		crtBuff := @(-4):SGR.ALL.OFF
		i += 1
	Repeat
	crtBuff := ESC:"[":BG.BASE2:"m"
	Loop While i <= winHeight
		crtBuff := @(winX,i+1):@(-4)
		i += 1
	Repeat
	
	!! フィルター入力欄表示
	crtBuff := @(winX,1):SGR.ALL.OFF:@(-4):filter
	Crt CRT.BUFF.FLUSH:
	
	choiceSelection = choiceOutList.org<choiceNo>
	
Return

*--------------------------------------------------------------------------
* SelectionStart:
*--------------------------------------------------------------------------
SelectionStart:

	keepSelection = @TRUE
	
	!! 未選択状態なら開始位置をセット
	If Not(BufInfo<BI.BLOCKSTART>) Then
		BufInfo<BI.BLOCKSTART> = Y:@VM:X
	End
	
	Return

*--------------------------------------------------------------------------
* GoToRangeStart:
*--------------------------------------------------------------------------
GoToRangeStart:
	!! 選択継続中でカーソルと範囲選択終了の位置が違う場合は
	!! カーソルを範囲先端に持っていく
	If BufInfo<BI.BLOCKEND> <> Y:@VM:X And keepSelection Then
		!! Go To Range Start
		GoSub GetSelBlock
		Y = blockStart<1>
		X = blockStart<2>
		BufInfo<BI.BLOCKSTART> = BufInfo<BI.BLOCKEND>
	End
	If Not(keepSelection) Then
		Redraw = REDRAW.ALL
	End
	BufInfo<BI.BLOCKEND> = ""
	Return

*--------------------------------------------------------------------------
* GoToRangeEnd:
*--------------------------------------------------------------------------
GoToRangeEnd:
	!! 選択継続中でカーソルと範囲選択終了の位置が違う場合は
	!! カーソルを範囲終端に持っていく
	If BufInfo<BI.BLOCKEND> <> Y:@VM:X And keepSelection Then
		!! Go To Range End
		GoSub GetSelBlock
		Y = blockEnd<1>
		X = blockEnd<2>
	End
	If Not(keepSelection) Then
		Redraw = REDRAW.ALL
	End
	BufInfo<BI.BLOCKEND> = ""
	Return

* *
* GetKey - Output: actNo, C, n

GetKey:
	actNo = 0
	Loop
		
		** キー入力待ち
		C = KeyIn()
		
AfterKeyWait:
		
		n = UniSeq(C) ;** １文字目の文字列数値表記
		If n > 31 Then
			actNo = A.INSCHAR
			Return
		End
		
		!! 特殊なエスケープシーケンスを拾う
		If n = 27 Then
			GoSub GetCh.Timeout ; C := ch
			If ch = "" Then
				!! 単独ESC
				Locate C in keys By 'AL' Setting i Then
					actNo = keysToAction<i,1>
					Return
				End
			End Else If ch = "[" Then
				!! CSIシーケンス開始
				GoSub GetCh.Timeout ; C := ch
				If ch = "2" Then
					GoSub GetCh.Timeout ; C := ch
					If ch = "~" Then
						!! Toggle Overlay Mode
						bOverlay = Not(bOverlay)
						If bOverlay Then
							Crt OVERLAY.MODE.SEQ:
						End Else
							Crt INS.MODE.SEQ:
						End
						Return
					End Else If ch = "0" Then
						GoSub GetCh.Timeout ; C := ch
						If ch = "0" Then
							GoSub GetCh.Timeout ; C := ch
							If ch = "~" Then
								!! Bracketed Paste
								C = ""
								Loop
									GoSub GetCh.Timeout
								While ch <> ESC And ch <> ""
									C:= ch
								Repeat
								
								GoSub GetCh.Timeout ;** [
								GoSub GetCh.Timeout ;** 2
								GoSub GetCh.Timeout ;** 0
								GoSub GetCh.Timeout ;** 1
								GoSub GetCh.Timeout ;** ~
								
								actNo = A.INSCHAR
								Return
							End
						End
					End
				End Else If ch = "8" Then
					!! [TBD] 端末サイズの取得
					If C Matches "'":ESC:"[8'...'t'" Then
						** DECSLPP -> CSI Ps1 ; Ps2 ; Ps3 t
						Return
					End
				End
!! Mause Tracking (SGR)
!! 		If C[1,3] = CSI:"<" Then
!! 			
!! 		End

			End Else If ch = "]" Then
				!! OSC
				GoSub GetCh.Timeout ; C := ch
				If ch = "5" Then
					GoSub GetCh.Timeout ; C := ch
					If ch = "2" Then
						!! OS Clipboard Paste
						C = ""
						Loop
							GoSub GetCh.Timeout ; C := ch
						While ch <> BEL And ch <> ESC And ch <> ""
						Repeat
						If ch = ESC Then GoSub GetCh.Timeout ; ** ESC+\ を読み取る
						cdata = C
						last = Len(cdata)
						data = cdata[1,last-1][';',3,1]
$IFDEF U2__UNIVERSE
						retCode = ENCODE("Base64A", "2", data, "1", InsBuffer, "1")
$ELSE
						InsBuffer = ICONV(ICONV(data, "B64"),"XUTF8")
$ENDIF
						actNo = A.PASTE ;** 挿入処理
						Return
					End
				End
			End
		End
		
		Loop
			!! キーシーケンスからアクションを取得
			Locate C in keys By 'AL' Setting i Then
				actNo = keysToAction<i,1>
				Return
			End
		While keys<i>[1,Len(C)] = C
			GoSub GetCh.Timeout
		While ch <> ""
			C := ch
		Repeat
		
Get.Key.Err:
		
		Crt @SYS.BELL:
		
$IFDEF DEBUG
		strKey = ""
		z = Len(C)
		For i = 1 To z
			c = C[i,1]
			n = Seq(c)
			If n < 32 Then strKey := '@' : Char(n + 64)
			Else strKey := c
		Next
		StatusMessage = strKey
		Nap 200
$ENDIF
		
	Repeat
	Return

GetCh.Timeout:
$IFDEF U2__UNIVERSE
	For xxx = 1 To 4
		Input test,-1
		If test Then
			ch = KeyIn()
			Return
		End
		Nap 50 ;** 50ms * 4 = 200ms
	Next xxx
	ch = ""
$ElSE
	ch = KeyIn(0.2)
$ENDIF
	Return

*--------------------------------------------------------------------------
* Enters
*--------------------------------------------------------------------------
Enters:

	** カーソル位置描画
	GoSub PrintCursor
	
	** CRTフラッシュ処理
	Crt CRT.BUFF.FLUSH:
	
	GoSub GetKey
	
!! 	Crt CSI:"?25l":
	
	crtBuff = ""
	
	Redraw = ""
	moveX = 0
	moveY = 0
	prevY = Y
	prevX = X
	IndentCh = If IndentType = "Tab" Then Char(9) Else Space(STDTAB)

	keepSelection = @FALSE
	
	!! モード別処理
	If BufInfo<BI.PARSETYPE> = PARSE.BASIC Then
		!! Basicモード
		
!! 		If actNo = A.INSCHAR Then
!! 			i = Index(kakkoChList,C,1)
!! 			If i > 0 Then
!! 				!! 開く括弧のみ閉じる括弧を自動挿入する
!! 				!! TODO 文字リテラル内はしない
!! 				If Rem(i,2) Then
!! 					InsBuffer = kakkoChList[i,2]
!! 					If C = '<' Then
!! 						inX = X-1
!! 						inY = Y
!! 						GoSub GetWord.in
!! 						If Not(Word) Then InsBuffer = ""
!! 					End
!! 					If InsBuffer Then
!! 						GoSub InsertLines
!! 						actNo = 0 ;** 処理済み
!! 					End
!! 				End
!! 			End
!! 		End
	End
	
	!! アクションを実行
	GoSub Switch.Actions
	Begin Case
		Case actNo = A.CANCEL
			GoSub Act.Action ;** メニュー表示
	End Case
	
	** --------------------------
	** X表示位置の計算
	** --------------------------
	Line = Rec<Y> ;** 現在Y行
	If moveY And prevX = X Then
		** X位置を表示位置から逆算する
		GoSub GetX.From.keepDPX
		X = outX
	End
	DP_X = If X = 1 Then 1 Else LenDP(Change(Line[1,X-1],Char(9),Space(STDTAB))) + 1
	
	moveX = (prevX >< X)
	If Not(moveY) And moveX Then
		** X位置だけが動いた場合にkeepDP_Xを変える
		keepDP_X = DP_X
	End
	
	** --------------------------
	** Xスクロール位置調整
	** --------------------------
	If moveX Then
		If DP_X < XOffSet  Then
			XOffSet -= Int((@CRTWIDE - 1) / 2)
			If XOffSet < 1 Then XOffSet = 1
			Redraw = REDRAW.ALL
		End Else
			If DP_X > Width + XOffSet - 2 then
				XOffSet += Int((@CRTWIDE - 1) / 2) 
				Redraw = REDRAW.ALL
			End
		End
	End

	** --------------------------
	** Yスクロール位置調整
	** --------------------------
	If prevY >< Y Then
		tmpY = Top + SCROLLMERGINE
		If Y < tmpY Then
			Top -= tmpY - Y
			If Top < 1 Then Top = 1
			Redraw = REDRAW.ALL
		End Else
			tmpY = Depth + Top - SCROLLMERGINE - 1
			If Y > tmpY Then
				Top += Y - tmpY
				Redraw = REDRAW.ALL
			End
		End
	End

	** --------------------------
	** 選択範囲調整
	** --------------------------
	If keepSelection Then
		** 選択終了位置
		If Not(BufInfo<BI.BLOCKEND>) Then BufInfo<BI.BLOCKEND> = Y:@VM:X
		Redraw = (If Not(moveY) And Redraw = 0 Then Y Else REDRAW.ALL)
	End Else
		If BufInfo<BI.BLOCKSTART> Then
			** 選択範囲が外れた
			BufInfo<BI.BLOCKSTART> = ""
			If moveY OR BufInfo<BI.BLOCKSTART,1> >< BufInfo<BI.BLOCKEND,1> Then
				Redraw = REDRAW.ALL
			End Else
				If Redraw >< REDRAW.ALL Then Redraw = Y
			End
		End
		BufInfo<BI.BLOCKEND> = ""
	End
	
	** 描画処理
	If Redraw = REDRAW.ALL Then
		** 全画面描画
		Lines = If Rec = "" Then 1 Else DCount(Rec,@fm)
		GoSub PrintPage
	End Else
		** 指定行描画
		If Not(Redraw) Then Redraw = Y:@FM:prevY ;** デフォルトでは前回行と今回行を描画する
		Loop
			Row = Remove(Redraw,sep)
			If Row > 0 & Row <= Lines Then
				Line = Rec<Row>
				GoSub ParseLine
				GoSub PrintLine
			End
		While sep Repeat
		GoSub PrintStatus
	End
	
	Return

*-----------------------------------------------------------------------------
*  X位置を表示位置から逆算する
*  In:  keepDP_X,Line
*  Out: outX
*-----------------------------------------------------------------------------
GetX.From.keepDPX:
	** X位置を表示位置から逆算する
	tmpX = 0
	outX = 1
	Loop
		char = Line[outX,1]
		If char = "" Then Exit
		tmpX += If char = Char(9) Then STDTAB Else LenDP(char)
	Until tmpX >= keepDP_X
		outX += 1
	Repeat
	Return

*--------------------------------------------------------------------------
* EditMenu
*--------------------------------------------------------------------------
EditMenu: 
	MenuLine = "Undo Redo (X)cut Copy Paste [paste from Local] :" ; GoSub MenuLine
	Ok = Upcase(C)
	Begin Case
		Case Ok = "U"
			GoSub Act.Undo
		Case Ok = "R"
			GoSub Act.Redo
		Case Ok = "X"
			GoSub Act.Cut
		Case Ok = "C"
			GoSub Act.Copy
		Case Ok = "P"
			GoSub Act.SendRemotePasteCmd
		Case Ok = "L"
			GoSub Act.PasteLocal
		End Case
	Return
*--------------------------------------------------------------------------
* FileMenu
*--------------------------------------------------------------------------
FileMenu: 
	If IsNew Then
		!! TODO 出来れば使用できないメニューは灰色表示にしたい
		MenuLine = "Showlist New Read Write writeAs View Close :"
	End Else
		MenuLine = "Showlist New Read Write writeAs rEload Close Lock Delete clOse_all :"
	End
	GoSub MenuLine
	Ok = Upcase(C)
	Begin Case
		Case Ok = "S"
			GoSub Act.ShowBuffList
		Case Ok = "N"
			GoSub DoNew
		Case Ok = "R"
			GoSub DoOpen
		Case Ok = "E"
			GoSub Act.Reload
		Case Ok = "W"
			GoSub SaveItem
		Case Ok = "C"
			GoSub Act.CloseBuff
		Case Ok = "A"
			GoSub SaveAs
		Case Ok = "L"
			GoSub DoLock
		Case Ok = "D"
			GoSub Delete
		Case Ok = "O"
			GoSub Act.AllCloseBuf
!!     Case Ok = "P"
!!       GoSub DoPrint
		End Case
	Return
*--------------------------------------------------------------------------
* Format
*   TODO: Undo/Redo対応
*--------------------------------------------------------------------------
Format: 
	FileName = BufInfo<BI.FILE>
	If FileName = "" Then FileName = "BP"
	GoSub Common.OpenFile
	Write Rec On FL, "%%format_temp%%"
	cmd = "FORMAT ":FileName:" %%format_temp%%"
	
$IFDEF U2__UNIVERSE
	Execute cmd, OUT>NULL
$ELSE
	Execute cmd SILENT STACKLIST
$ENDIF

	Read InsBuffer From FL, "%%format_temp%%" Else Null
	Delete FL, "%%format_temp%%"
	
	!! 全選択
	BufInfo<BI.BLOCKSTART, 1> = 1
	BufInfo<BI.BLOCKSTART, 2> = 1
	BufInfo<BI.BLOCKEND, 1> = Lines
	BufInfo<BI.BLOCKEND, 2> = Len(Rec<Y>) + 1
	
	GoSub InsertLines
	GoSub PrintPage
	
	Return
*---------------------------------------------------------------------------
* GetArgs
*---------------------------------------------------------------------------
GetArgs: 
	UArg = UpCase(CFileName)
	Begin CAse
		Case UArg = "-CONFIG"
			GoSub DoConfig
		End Case
	Return
*-----------------------------------------------------------------------
*   GetFile
*------------------------------------------------------------------------
GetFile:
	GotFile = False
	Loop
		PromptLine = "File Name, * to list or ESC ->" ; GoSub PromptLine
		inputBox = FileName
		GoSub InputBox
		NewFileName = inputBox
		Begin Case
			Case NewFileName = ""
				FileName = ""
				Redraw = REDRAW.ALL
				Return
			Case NewFileName = "*"
				PromptLine = "Selecting files ..." ; GoSub PromptLine
				Echo Off
				Crt @(0,PY-3):
				ExLine = "SSELECT VOC WITH F1 LIKE F... OR WITH F1 LIKE f..."
				ExLine := " OR WITH F1 LIKE Q... OR WITH F1 LIKE q..."
				Perform ExLine
				ReadList List Else List = ""
				Echo On
				GoSub DoList
				NewFileName = Option
		End Case
		Open NewFileName To TFL Then  
			GotFile = True
			FileName = NewFileName
		End
	Until GotFile Do
	Repeat
Return
*-----------------------------------------------------------------------
*  GetFreeBuf
*-----------------------------------------------------------------------
GetFreeBuf: 
	Found = False
	For I = 1 To MAXWINDOWS Until Found
		If Not(BufInfos(I)<BI.USED>) Then
			Found = I
		end
	Next
	If Not(Found) Then
		StatusMessage = "No Spare Buffers"
		Return
	End
	BufInfos(Found) = ""
	Return
*-----------------------------------------------------------------------
*   GetItem
*------------------------------------------------------------------------
GetItem: 
	PromptLine = "Item Name From '":FileName:"', * To List ->" ; GoSub PromptLine
	inputBox = ""
	GoSub InputBox
	ItemName = inputBox
	If ItemName = "*" Then
		PromptLine = "Selecting Items ..." ; GoSub PromptLine
		Echo Off
		Crt @(0,PY-3):
		ExLine = "SSELECT ":FileName
		Perform ExLine
		ReadList List Else List = 0
		Echo On
		GoSub DoList
		ItemName = Option
	End
	If ItemName = "" Then Redraw = REDRAW.ALL
	Return

*--------------------------------------------------------------------------
*  GetWord.in - 指定カーソル上の単語を取得する
*    [In] inX = X位置
*    [In] inY = Y位置
*  GetWord - 現在のカーソル位置を自動で設定
*--------------------------------------------------------------------------
GetWord:
	inY = Y
	inX = X
GetWord.in:
	Word = "" ;** [Out] 抽出した単語 見つからなかった場合は空
	SOW = ""  ;** [Out] 単語の開始位置
	EOW = ""  ;** [Out] 単語の終了位置
	
	Line = Rec<inY>
	ch = Line[inX,1]
	
	!! タイプチェック
	GoSub Is.Variable.Char ;** 英数字と変数に使える記号
	If flg Then type = 1 Else
		GoSub Is.Unicode.Char ;** UniCode単語
		If flg Then type = 2 Else
			GoSub Is.Mark.Char ;** 区切り記号
			If flg Then type = 3 Else
				GoSub Is.Space.Char ;** 非表示文字
				If flg Then type = 4 Else
					Return ;** 不明
				End
			End
		End
	End
	
	!! 開始位置 SOW を求める
	S = inX
	Loop
		S -= 1
		ch = Line[S,1]
	Until S <= 0
		On type GoSub Is.Variable.Char,Is.Unicode.Char,Is.Mark.Char,Is.Space.Char
	While flg
	Repeat
	SOW = S + 1
	
	!! 終了位置 EOW を求める
	S = inX
	Loop
		S += 1
		ch = Line[S,1]
	Until ch = ""
		On type GoSub Is.Variable.Char,Is.Unicode.Char,Is.Mark.Char,Is.Space.Char
	While flg
	Repeat
	EOW = SOW + S - SOW
	
	If type <> 4 Then
		Word = Line[SOW, EOW-SOW]
	End
	
	Return

Is.Variable.Char:
	flg = (ch Matches "1A":@VM:"1N" OR Count("._$%@",ch))
	Return
	
Is.Unicode.Char:
	flg = (UniSeq(ch) > 255)
	Return
	
Is.Mark.Char:
	flg = Count("=#:<>()[]{}/*+-,!;'\":'"', ch)
	Return
	
Is.Space.Char:
	flg = Count(Char(9):" ", ch)
	Return

*--------------------------------------------------------------------------------
*  Initialise
*--------------------------------------------------------------------------------
Initialise: 
	GoSub SetupDefKeyBindings
	GoSub SetupTokens
	Return
*--------------------------------------------------------------------------
* InitTerminal
*--------------------------------------------------------------------------
InitTerminal: 
	
!! 	prompt ''
	
$IFDEF U2__UNIVERSE
	Ttyget ttys Then
		If ttys<1,1> = 3 Then; * EMULATE mode
			ttys<4,4> = 0; * NO Invert
			Ttyset ttys Else Null
		End
	End
	
	IF OS.GATES Then
		** WIN
		IF Len(@(IT$CUD))=0 Then
			Perform "SET.TERM.TYPE uviterm-w MAP UTF8" ;** 制御文字が送れる端末に変更する
		End
	End
	
$ELSE
	x = PTERM(2,@FALSE)
	If System(1044) Then
		!! ECS Mode
		x = PTERM(7,1) ;** UTF8固定
	End
	Execute "TERM XTERM-EEEPC"
	x = PTERM(8,8) ;** Backspace ^H
$ENDIF
	
	Return
*--------------------------------------------------------------------------
* InsMenu
*--------------------------------------------------------------------------
InsMenu: 
	MenuLine = "Comment Join OConv IConv Date Time Record :"
	GoSub MenuLine
	C = UpCase(C)
	Begin Case
		Case Ok = "J"
			GoSub Join
		Case Ok = "C"
			GoSub Act.InsCommentOut
		Case Ok = "O"
			GoSub DoOConv
		Case Ok = "I"
			GoSub DoIConv
		Case C = "D"
			InsBuffer = Date()
			GoSub InsertLines
		Case C = "T"
			InsBuffer = Time()
			GoSub InsertLines
		Case C = "R"
			GoSub DoInsert
		End Case
	Return
*--------------------------------------------------------------------------
* InsertLines
*--------------------------------------------------------------------------
InsertLines: 
	
!! 	If InsBuffer = "" Then Return

	InsBuffer = Convert(@IM:@FM:@VM:@SM,CHAR(31):CHAR(10):CHAR(29):CHAR(28),InsBuffer)
	
	editCmd = ""
	
	If BufInfo<BI.BLOCKSTART> Then
		** 選択中
		editCmd<1> = BufInfo<BI.BLOCKEND, 1>
		editCmd<2> = BufInfo<BI.BLOCKEND, 2>
		editCmd<3> = BufInfo<BI.BLOCKSTART, 1>
		editCmd<4> = BufInfo<BI.BLOCKSTART, 2>
		editCmd<5> = InsBuffer
		editCmd<6> = ""
	End Else
		editCmd<1> = Y
		editCmd<2> = X
		If bOverlay Then
			editCmd<3> = Y
			editCmd<4> = X + (If X < Len(Rec<Y>) Then 1 Else 0)
		End Else
			editCmd<3> = ""
			editCmd<4> = ""
		End
		editCmd<5> = InsBuffer
		editCmd<6> = ""
	End
	
	GoSub StackEditCmd
	 
Return
*--------------------------------------------------------------------------
* JoinLines
*--------------------------------------------------------------------------
Join:   
	
	GoSub GET.SELECTION.STRING
	
	If selString = "" Then Return
	
	PromptLine = "Join Word ->" ; GoSub PromptLine
	inputBox = ""
	GoSub InputBox
	joinChars = inputBox
	
	joinChars = Convert(@FM,CHAR(10),joinChars)
	
	InsBuffer = Change(selString,CHAR(10),joinChars)
	
	GoSub InsertLines
	
Return

*--------------------------------------------------------------------------
* ParseLine
*   Line [in]
*   Row [in]
*   PLine [out]
*--------------------------------------------------------------------------
ParseLine:
	
	L = Len(Line)
	OldLine = Line
	Line = TrimF(Convert(Char(9),Space(STDTAB),Line))
	Mask = Space(L - Len(Line))
	
	** 選択領域がある
	selection = ""
	If BufInfo<BI.BLOCKSTART> Then
		GoSub GetSelBlock
		If blockStart<1> = Row Then
			If blockEnd<1> = Row Then
				** １行内での選択範囲
				If blockStart<2> > blockEnd<2> Then
					tmp = blockStart; blockStart = blockEnd; blockEnd = tmp
				End
				selection = blockStart<2>:@FM:blockEnd<2>
			End Else
				** 開始行が一致
				selection = blockStart<2>:@FM:BIG
			End
		End Else If blockEnd<1> = Row Then
			** 終端行が一致
			selection = 1:@FM:blockEnd<2>
		End Else If blockStart<1> < Row And blockEnd<1> > Row Then
			** 選択領域の真ん中なので開始から終了まで
			selection = 1:@FM:BIG
		End
	End
 
	ParseType = BufInfo<BI.PARSETYPE>
	Begin Case
		** --------------------
		** Basic
		** --------------------
		Case ParseType = PARSE.BASIC
			!! Label
			Word = Line[";",1,1][" ",1,1]
			If Word Matches "1N0N" Or Word Matches "1A0X':'" Then
				len = Len(Word)
				Mask := Str(SI.LABEL,len)
				Line = Line[len+1,BIG]
				Word = Line[" ",1,1]
			End
			Begin Case   
				!! Comment & Directive
				Case Count("*!",Word[1,1])
					If Count(Line,'@@') Then
						Mask := Str(SI.DOC, L)
					End Else
						Mask := Str(SI.COMMENT, L)
					End
				Case Count("$#",Word[1,1])
					Mask = Str(SI.DIRECTIVE, L)
				Case 1
					Dc = Count(Line,";")
					If Not(Dc) Then
						Mask := Space(L)
					End Else
						FoundComment = False
						For Z = 1 To Dc Until FoundComment
							Word = TrimF(Line[";",Z+1,1])
							If Count("*!",Word[1,1]) Then
								FoundComment = Z
							End
						Next
						If FoundComment Then
							Mask := Space(Len(Line[";",1, FoundComment])):Str(SI.COMMENT, L)
						End Else
							Mask := Space(L)
						End
					End
			End Case
			!! Word
			Lin = Convert(PUNCS,Str(@fm,Len(PUNCS)), UpCase(OldLine))
			Dc3 = Dcount(Lin,@fm)
			For Q = 1 To Dc3
				Word = Lin[@fm,Q,1]
				St = Col1()+ 1
				If St > 1 Then
					If Mask[St-1,1] = " " And OldLine[St-1,1] <> " " Then
						Mask[St-1,1] = SI.OPERATOR           ; * operators too
					End
				End
				Begin Case
					Case Word[1,1] = ''
					Case Index(STRQTS,Word[1,1],1)
						Ix = Index(Lin[St+1,HUGE],Word[1,1],1)
						If Ix Then
							If Mask[St,1] = " " Then
								Q = DCount(Lin[1, Ix+St],@fm)
								Mask[St, Ix+1] = Str(SI.STRING, Ix+1)
							End
						End
					Case Word Matches "1N0N"
						If Mask[St,1] = " " Then
							Mask[St, Len(Word)] = Str(SI.NUMBER, Len(Word))
						End
					Case 1
						Locate Word In KEYWORDS By "AL" Setting Pos Then
							If Mask[St,1] = " " Then
								Mask[St, Len(Word)] = Str(SI.KEY, Len(Word))
							End
						End Else
							Locate Word In FUNCS by "AL" Setting Pos Then
								If Mask[St,1] = " " then
									Mask[St,Len(Word)] = Str(SI.FUNCTION, Len(Word))
								End
							End
						End
				End Case
			Next
		** --------------------
		** Paragraph
		** --------------------
		Case ParseType = PARSE.PARA
			
			!! 全行系
			OLine = Line
			Line.len = Len(Line)
			C2 = Line[1,2]
			If C2 = "PA" Then
				Mask := Str(SI.COMMENT,Line.len)
			End Else If C2 = "* " Then
				Mask := Str(SI.COMMENT,Line.len)
			End Else
				!! 普通のコマンド文
				
				!! ラベル
				Word = Line[" ",1,1]
				If Word Matches "1N0N" Or Word Matches "1A0X':'" Then
					Mask := Str(SI.LABEL,Len(Word)):" "
					Line = Line[" ",2,BIG]
					Word = Line[" ",1,1]
				End
				
				!! 制御構文
				If Word = "IF" Then
					idx = Index(Line,"THEN",1)
					If idx Then
						Mask := Str(SI.KEY,2)
						Mask := Space(idx-3)
						Mask := Str(SI.KEY,4):" "
						Line = Line[idx+5,BIG]
						Word = Line[" ",1,1]
					End
				End Else If Word = "LOOP" Then
					Mask := Str(SI.KEY,4)
					Line = Line[4,BIG]
					Word = Line[" ",1,1]
				End Else If Word = "REPEAT" Then
					Mask := Str(SI.KEY,6)
					Line = Line[6,BIG]
					Word = Line[" ",1,1]
				End
				
				!! 補助構文
				If Word Matches "DISPLAY":@VM:"STOP":@VM:"ABORT" Then
					!! 以降を強調
					Mask := Str(SI.STRING,Line.len)
				End Else If Word = "GO" Then
					!! ラベルを強調
					Mask := Str(SI.KEY,3)
					Mask := Str(SI.LABEL,Line.len)
				End Else
					Mask := Space(Line.len)
				End
				
				!! インラインプロンプト強調
				offset = 0
				Line = OLine
				Loop
					idx = Index(Line,"<<",1)
					If idx Then
						idx2 = Index(Line[idx,BIG],">>",1)
						If idx2 Then
							Mask[offset + idx,idx2+1] = Str(SI.DOC,idx2+1)
							offset += idx+idx2-1
							Line = Line[idx+idx2,BIG]
						End Else
							Exit
						End
					End Else
						Exit
					End
				Repeat
				
			End
			

		** --------------------
		** Data
		** --------------------
		Case ParseType = PARSE.DATA
			len = Len(Line)
			For i = 1 To len
				C = Line[i,1]
				Begin Case
					Case C = @VM
						Mask := SI.VMK
					Case C = @SM
						Mask := SI.SMK
					Case 1
						Mask := " "
				End Case
			Next
			
		Case 1
			Mask = Space(Len(OldLine))
	End Case
			
	** 検索ハイライト
	Word = BufInfo<BI.HIWORD>
	If Word <> "" Then
		Oc = 1
		Loop
			Ix = If ignoreCase Then Index(DownCase(OldLine),Word,Oc) Else Index(OldLine,Word,Oc)
		While Ix Do
			Oc += 1
			Mask[Ix, Len(Word)] = Str(SI.SEARCH, Len(Word))
		Repeat
	End
	
	** カーソル行の場合に処理
	If Row = Y Then
		kakko = ""
		** 対応する括弧の表示
		If ParseType = PARSE.BASIC Then
			stCh = OldLine[X,1] ;** 現在カーソル文字の再取得
			If stCh >< "" Then
				ki = Index(kakkoChList,stCh,1) 
				If ki Then
					
					If ki >= 9 Then
						!! 文字リテラル
						moveDir = If Rem(Count(OldLine[1,X],stCh),2) Then 1 Else -1
						enCh = stCh
						sign = SI.KAKKO
					End Else
						!! 対応する括弧
						moveDir = If Rem(ki,2) = 1 Then 1 Else -1
						enCh = kakkoChList[ki+moveDir,1]
						sign = SI.KAKKO
					End
					
					!! 終了位置を探す
					nestCnt = 0
					enPos = X
					exitPos = If moveDir = 1 Then Len(OldLine) Else 1
					For enPos = X + moveDir To exitPos Step moveDir
						ch = OldLine[enPos,1]
						If ki < 9 And Mask[enPos,1] = SI.STRING Then Continue ;** 文字リテラル中はスキップ
						If ch = enCh Then
							If nestCnt > 0 Then
								nestCnt -= 1 ;** ネストを減らす
							End Else
								Mask[X,1] = sign
								Mask[enPos,1] = sign
								kakko<1,1> = X
								kakko<2,1> = enPos
								Exit
							End
						End Else If ch = stCh Then
							nestCnt += 1 ;** ネストを増やす
						End
					Next
				End
			End
		End
	End
	
	!! XOffset位置ずらし
	Line = ""
	tmpMask = ""
	iXOffSet = 1 ;** 内部Xオフセット
	rX = 1 ;** 表示X
	iX = 1 ;** 内部X
	Loop
		char = OldLine[iX,1]
		If char = "" Then
			If CurBuf < MAXWINDOWS And Row <> Lines Then
				Line := Char(10)
			End
			Exit
		End
		If XOffSet = rX Then
			iXOffSet = iX ;** Xオフセットの表示位置を保存
		End
		rX += If char = Char(9) Then STDTAB Else LenDP(char)
		If rX >= XOffSet + 1 Then
			Line := char
			tmpMask := Mask[iX,1]
		End
	While rX <= (XOffSet + Width - 2)
		iX += 1
	Repeat
	Mask = tmpMask
	
	If selection And selection<1> < iXOffSet Then
		selection<1> = iXOffSet
	End

	HI.OFF = CSI:FG.BASE01:";":BG.BASE3:";22m"
	repTabCh = "»":Space(STDTAB-1)
	PLine = ""
	Old = ""
	L = Len(Line)
	For K = 1 to L
		
		!! 選択範囲
		If K = 1 Or K = selection<2> - iXOffSet + 1 Then
			!! 選択終了
			HI.Default = HI.OFF
			HI.Light = ESC:"[":FG.BASE2:"m"
			HI.Search = HI.SEARCH.ON
			PLine := ESC:"[49m"
			Old = ""
			!! 行全体のハイライト
			If Mask[1,1] = SI.DIRECTIVE Then
				HI.Light = ESC:"[":FG.BASE3:"m"
				HI.Default = HI.DIR.ON
				PLine := HI.DIR.ON
				Old = SI.DIRECTIVE
			End
		End
			If K = selection<1> - iXOffSet + 1 And selection<1> <> selection<2> Then
			!! 選択開始
			HI.Default = HI.SELECT.ON
			HI.Light = ESC:"[":FG.BASE00:"m"
			HI.Search = HI.SEARCH.SEL
			PLine := HI.Default
			Old = ""
		End

		!! Maskによる色付け
		C = Mask[K,1]
		If C <> Old Then
			Begin Case
				Case Old = SI.KAKKO
					PLine := HI.KAKKO.OFF
				Case Old = SI.LABEL
					PLine := HI.LABEL.OFF
				Case Old = SI.COMMENT
					PLine := HI.COMMENT.OFF
				Case Old = SI.KEY
					PLine := HI.KEY.OFF
				Case Old = SI.STRING
					PLine := HI.STRING.OFF
				Case Old = SI.NUMBER
					PLine := HI.NUMBER.OFF
				Case Old = SI.OPERATOR
					PLine := HI.OP.OFF
				Case Old = SI.SEARCH
					PLine := HI.SEARCH.OFF
				Case Old = SI.VMK
					PLine := HI.VMK.OFF
				Case Old = SI.SMK
					PLine := HI.SMK.OFF
			End Case
			PLine := HI.Default
			Begin Case
				Case C = SI.KAKKO
					PLine := HI.KAKKO.ON
				Case C = SI.LABEL
					PLine := HI.LABEL.ON
				Case C = SI.COMMENT
					PLine := HI.COMMENT.ON
				Case C = SI.KEY
					PLine := HI.KEY.ON
				Case C = SI.STRING
					PLine := HI.STRING.ON
				Case C = SI.NUMBER
					PLine := HI.NUMBER.ON
				case C = SI.OPERATOR
					PLine := HI.OP.ON
				Case C = SI.FUNCTION
					PLine := HI.FUNC.ON
				Case C = SI.SEARCH
					PLine := HI.Search
				Case C = SI.DOC
					PLine := HI.DOC.ON
				Case C = SI.VMK
					PLine := HI.VMK.ON
				Case C = SI.SMK
					PLine := HI.SMK.ON
			End case
			Old = Mask[K,1]
		End
		c = Line[K,1]
		If c = Char(9) Then
			!! 文字の描画(タブの場合は表示形式に置換)
			PLine := HI.Light:repTabCh:HI.Default
			Old = ""
		End Else If c = Char(10) Then
			!! 改行の表示
			If selection<2> = BIG Then
				PLine := HI.Light
			End Else
				PLine := HI.OFF:ESC:"[":FG.BASE2:"m"
			End
			PLine := "↲"
		End Else
			PLine := c
		End
	Next
	PLine := HI.OFF
Return

*--------------------------------------------------------------------------
* GetSelBlock:選択領域取得
* OUT : blockStart
*       blockEnd
*--------------------------------------------------------------------------
GetSelBlock:
	blockStart = Raise(BufInfo<BI.BLOCKSTART>)
	blockEnd = Raise(BufInfo<BI.BLOCKEND>)
	!! 選択開始 -> 終了 順にSWAP  
	If blockStart<1> * 100000 + blockStart<2> > blockEnd<1> * 100000 + blockEnd<2> Then
		tmp = blockStart; blockStart = blockEnd; blockEnd = tmp
	End
	Return
	
*--------------------------------------------------------------------------
* PrintPage
*--------------------------------------------------------------------------
PrintPage:
	GoSub PrintTextArea
	Redraw.StatusLine = @TRUE
	GoSub PrintStatus
	Return

*--------------------------------------------------------------------------
* PrintTextArea
*--------------------------------------------------------------------------
PrintTextArea:
	For I = 1 To Depth
		Row = Top + I - 1
		If Row > Lines Then crtBuff := ESC:"[0J"; Exit
		Line = Rec<Row>
		GoSub ParseLine
		GoSub PrintLine
	Next
	Return

*--------------------------------------------------------------------------
* PrintLine
*--------------------------------------------------------------------------
PrintLine:
	crtBuff := @(0,Row - Top) ;* 行の開始
	!! 行情報部の色指定
	If Row = Y Then
		!! 現在行
		crtBuff := CSI:FG.YELLOW:";":BG.BASE2:'m'
	End Else
		crtBuff := CSI:FG.BASE1:';':BG.BASE2:'m'
	End
	If TgtFld Then
		!! フィールド指定モード
		inY = Row
		GoSub GetDAPos
		bShowUnderline = fldCnt > 1 And fIdx = fldCnt
		If bShowUnderline Then
			!! 複数フィールドの最終行に下線を入れる
			crtBuff := ESC:'[4m'
		End
		If BufInfo<BI.VALUEFIX> Then
			str = "<":fPos:",":BufInfo<BI.VALUEFIX>:",":vPos:"> "
			crtBuff := str "11L"
			biInfoWide.lineNo = 11
		End Else
			str = "<":fPos:",":vPos:"> "
			crtBuff := str "8L"
			biInfoWide.lineNo = 8
		End
		If DIRec Then
			!! 辞書表示
			crtBuff := FMTDP(DIRec<fIdx>,biInfoWide.dict:"L")
		End
		If bShowUnderline Then
			!! 下線を消す
			crtBuff := ESC:'[4m'
		End
	End Else
		biInfoWide.lineNo = 5
		crtBuff := (Row "4R"):" " ;* 行番号
		If DIRec Then
			!! 辞書表示
			crtBuff := FMTDP(DIRec<Row>,biInfoWide.dict:"L")
		End
	End
	crtBuff := SGR.ALL.OFF ;* 行情報部の色指定解除
	!! TABの可視化
	crtBuff := PLine:@(-4) ;** 内容の描画
	Return

*--------------------------------------------------------------------------
* ダイナミックアレイでの位置を返す
*--------------------------------------------------------------------------
GetDAPos:
	fldCnt = Dcount(TgtFld,@FM)
	fIdx = Mod((inY-1),fldCnt)+1
	fPos = TgtFld<fIdx,1>
	vPos = Int((inY-1)/fldCnt)+1
	Return
	
*--------------------------------------------------------------------------
* PrintStatus
*--------------------------------------------------------------------------
PrintStatus:
	If Redraw.StatusLine Then
		
		fileSentence = CurBuf:" > "
		If Changed Then fileSentence := "*"
		If BufInfo<BI.FILE> <> "" Then
			fileSentence := BufInfo<BI.FILE>
			fileSentence := " ":BufInfo<BI.ITEM>
			If BufInfo<BI.PBUFNO> Then fileSentence := " (pno=":BufInfo<BI.PBUFNO>:")"
			If BufInfo<BI.FIELDFIX> Then fileSentence := " {":BufInfo<BI.FIELDFIX>:"}"
			If BufInfo<BI.VALUEFIX> Then fileSentence := ",V":BufInfo<BI.VALUEFIX>
			If BufInfo<BI.ACCOUNT> >< @PATH Then fileSentence := " [":BufInfo<BI.ACCOUNT>:"]"
		End Else
			If BufInfo<BI.CAPTURE> <> "" Then
				fileSentence := BufInfo<BI.CAPTURE>
			End Else
				fileSentence := "(Untitled)" 
			End
		End
		If IsNew Then fileSentence := "(New)"
		
		SLine = ""
		If BufInfo<BI.LOCKED> Then SLine := " | Locked"
		If ReadOnly Then SLine := " | R/Only"
		SLine := " | ":BufInfo<BI.PARSETYPE>:" ":IndentType:":":STDTAB:" "
		
		crtBuff := @(0, PY):HI.STATUS.ON
		crtBuff := FMTDP(fileSentence,"L#":@CRTWIDE-21-Len(SLine))
		crtBuff := SLine:"| "
		
		Redraw.StatusLine = @FALSE
	End Else
		crtBuff := @(@CRTWIDE-19,PY): HI.STATUS.ON
	End

	!! 文字コード情報B
	cd = UniSeq(Rec<Y>[X,1])
	If cd = 0 Then cd = 10 ;** 改行コードにする
	hex = OConv(cd,'MX')
	crtBuff := (hex (If cd < 255 Then "R  %%" Else "R%%%%")):" | "
	
	!! カーソル情報
	curInfo = ""
	If BufInfo<BI.FIELDFIX> Then
		!! フィールド固定モード
		inY = Y
		GoSub GetDAPos
		curInfo = "<":fPos
		If BufInfo<BI.VALUEFIX> Then
			curInfo := ",":BufInfo<BI.VALUEFIX>
		End
		curInfo := ",":vPos:">.":DP_X
	End Else
		curInfo := Y:".":DP_X
	End
	crtBuff := curInfo "L#11"
	crtBuff := HI.STATUS.OFF
	
	!! ステータスメッセージ
	If StatusMessage >< "" Then
		crtBuff := @(0, PY+1):ESC:"[":BG.RED:";":FG.BASE3:"m":StatusMessage:SGR.ALL.OFF:@(-4)
		StatusMessage = ""
	End Else
		crtBuff := @(0, PY+1):@(-4)
	End
	Return

*-----------------------------------------------------------------------
*  PrintCursor
*-----------------------------------------------------------------------
PrintCursor:
!! 	crtBuff := @(biInfoWide + DP_X - XOffSet, Y - Top):CSI:"?12l":CSI:"?25h"
	crtBuff := @(biInfoWide + DP_X - XOffSet, Y - Top)
	Return

*-----------------------------------------------------------------------
*  MenuLine
*-----------------------------------------------------------------------
MenuLine:
	crtBuff = HI.STATUS.ON
	f = @TRUE
	For i=1 To HUGE
		ch = MenuLine[i,1]
		If ch = '' Then Exit
		If f Then
			If ch = 'E' And MenuLine[i,3] = "ESC" Then
				crtBuff := ESC:"[1;":FG.BASE2:"mESC":ESC:"[22m":HI.STATUS.ON
				f = @FALSE
				i += 2
			End Else If ((ch >= 'A' And ch <= 'Z') or ch = '!') Then
				crtBuff := ESC:"[1;":FG.BASE2:"m":ch:ESC:"[22m":HI.STATUS.ON
				f = @FALSE
			End Else 
				crtBuff := ch
			End
		End Else
			If ch = ' ' Then f = @TRUE
			crtBuff := ch
		End
	Next
	Crt @(0,PY):crtBuff:SGR.ALL.OFF:@(-4):
	GoSub GetKey
	Redraw.StatusLine = @TRUE
	GoSub PrintStatus
	Crt crtBuff:
	Return
*-----------------------------------------------------------------------
*  PromptLine
*-----------------------------------------------------------------------
PromptLine: 
	Crt @(0,PY+1):ESC:"[":BG.BASE2:"m":PromptLine:SGR.ALL.OFF:@(-4):
	Redraw.StatusLine = @TRUE
	Return
*-----------------------------------------------------------------------
*  SaveAs
*-----------------------------------------------------------------------
SaveAs: 
	TempFileName = BufInfo<BI.FILE>
	TempItemName = BufInfo<BI.ITEM>
	GoSub GetFile
	If FileName = "" Then
		BufInfo<BI.FILE> = TempFileName
		Return
	End
	BufInfo<BI.ITEM> = ""
	GoSub SaveItem
	If BufInfo<BI.FILE> = "" Then
		BufInfo<BI.FILE> = TempFileName
	End
	If BufInfo<BI.ITEM> = "" Then
		BufInfo<BI.ITEM> = TempItemName
	End
	Return
*--------------------------------------------------------------------------
* SaveItem
*--------------------------------------------------------------------------
SaveItem:

	Redraw.StatusLine = @TRUE
	
	If ReadOnly Then
		StatusMessage = "File is marked as Read Only - Cannot save"  
		Return
	End
	
	If BufInfo<BI.PBUFNO> Then
		!! 親バッファ保存モード
		
		!! 親が存在するかチェック
		pno = BufInfo<BI.PBUFNO>
		If Not(BufInfos(pno)<BI.USED>) Then
			StatusMessage = "Parent BufferNo already closed - Cannot save"  
			Return
		End
		
	End Else
		!! 親バッファ保存モードではない
		
		FileName = BufInfo<BI.FILE>
		If FileName = "" Then
			GoSub GetFile
			If FileName = "" Then Return
		End
		ItemName = BufInfo<BI.ITEM>
		If ItemName = "" Then
			PromptLine = "Item Name From '":FileName:"' ->" ; GoSub PromptLine
			inputBox = ""
			GoSub InputBox
			ItemName = inputBox
			If ItemName = "" then Return
		End
		
		!! アカウント違いの警告
		If BufInfo<BI.ACCOUNT> >< "" Then
			If Not(BufInfo<BI.ACCOUNT> Matches Quote(@ACCOUNT):@VM:Quote(@PATH)) Then 
				PromptLine = "This Item Read from Different Account! - Save in This Account (Y) :":@(-4) ; GoSub PromptLine 
				GoSub GetKey
				If TrimF(UpCase(C))[1,1] = "Y" Else Return
			End
		End
	
		!! ToDo Backup
		
		!!
		!! 保存処理
		!!   更新ロックがかかっていたらエラー
		!!   編集前時と比較して違っていれば他のセッションで変更があったとみなす(楽観的ロック)
		!!
		GoSub Common.OpenFile
		Crt @(0, PY):
		ReadU prevRec From FL, ItemName On Error Return Locked
			StatusMessage = "Record previously Locked by ":Status():", Do Not Saved"
			Return
		End Then
			Convert CHAR(10):CHAR(13) To '' In Rec ;** 改行コードが残っていたら自動除外
		End Else
			prevRec = ""
		End
		
	End
	
	If TgtFld Then
		!! フィールド指定モード
		
		saveRec = StartRec ;** 開始時点レコードに対して上書きする

		fldCnt = Dcount(TgtFld,@FM) ;** 固定フィールド数
		
		If BufInfo<BI.VALUEFIX> Then
			!! サブバリュー編集モード
			
			!! 集める
			tmp = ""
			cnt = DCount(Rec,@FM)
			For i = 1 To cnt
				fIdx = Mod((i-1),fldCnt)+1
				svno = Int((i-1)/fldCnt)+1
				If Rec<i> Then
					tmp<fIdx,1,svno> = Rec<i>
				End
			Next

			offset = (BufInfo<BI.VALUEFIX> - 1) * fldCnt + 1

			!! バッファポインタを一時的に切り替える    
			stackCurBuf = CurBuf ;** 現在のBuffNoをスタック
			CurBuf = BufInfo<BI.PBUFNO>
			
			editCmd = ""
			For i = 1 To fldCnt
				fno = offset + (i - 1)
				cmd = ""
				cmd<1> = fno
				cmd<2> = 1
				cmd<3> = fno
				cmd<4> = Len(Rec<fno>) + 1
				cmd<5> = Convert(@IM:@FM:@VM:@SM,CHAR(31):CHAR(10):CHAR(29):CHAR(28),tmp<i>)
				cmd<6> = ""
				editCmd<-1> = cmd
			Next
	
			GoSub StackEditCmd
			
			saveRec = Rec
			
			!! バッファポインタを元に戻す
			CurBuf = stackCurBuf
			
		End Else
			!! バリュー編集モード
			!! 縦一列になっているのを2次元に戻す
			For i = 1 To fldCnt
				fno = TgtFld<i,1>
				saveRec<fno> = ""
			Next
			cnt = DCount(Rec,@FM)
			For i = 1 To cnt
				fno = TgtFld<(Mod((i-1),fldCnt)+1),1>
				vno = Int((i-1)/fldCnt)+1
				If Rec<i> Then
					saveRec<fno,vno> = Rec<i>
				End
			Next
			
			If BufInfo<BI.PBUFNO> Then
				!! 親バッファに保存
		
				flist = TgtFld
				cnt = DCount(flist,@FM)
		
				!! バッファポインタを一時的に切り替える    
				stackCurBuf = CurBuf ;** 現在のBuffNoをスタック
				CurBuf = BufInfo<BI.PBUFNO>
				
				editCmd = ""
				For i = 1 To cnt
					fno = flist<i,1>
					cmd = ""
					cmd<1> = fno
					cmd<2> = 1
					cmd<3> = fno
					cmd<4> = Len(Rec<fno>) + 1
					cmd<5> = Convert(@IM:@FM:@VM:@SM,CHAR(31):CHAR(10):CHAR(29):CHAR(28),saveRec<fno>)
					cmd<6> = ""
					editCmd<-1> = cmd
				Next
		
				GoSub StackEditCmd
				
				saveRec = Rec
				
				!! バッファポインタを元に戻す
				CurBuf = stackCurBuf
				
			End Else
				!! ファイル書き込みモード
				
				!! Conversion
				For i = 1 To fldCnt
					fno = TgtFld<i,1>
					conv = TgtFld<i,3>
					If conv Then saveRec<fno> = IConvS(saveRec<fno>,conv)
				Next
			End
			
		End
		
	End Else
		!! 通常モード
		saveRec = Rec ;** 保存対象レコード
	End
	
	If Not(BufInfo<BI.PBUFNO>) Then
		!! ファイルに保存
		If prevRec >< saveRec Then
			!! 現在のレコード内容と違いがある場合だけ更新する
!!			If prevRec >< StartRec Then
!!				StatusMessage = "Record previously Changed by Another, Cannot Save This Modify"
!!				ReadOnly = True
!!				Return
!!			End
			If BufInfo<BI.LOCKED> Then
				WriteU saveRec On FL, ItemName On Error Return
			End Else
				Write saveRec On FL, ItemName On Error Return
			End
		End
	End

	!! Bufferの初期化処理  
	BufInfo<BI.FILE> = FileName
	BufInfo<BI.ITEM> = ItemName
	BufInfo<BI.CAPTURE> = ""
	BufInfo<BI.ACCOUNT> = @PATH
	Changed = False
	IsNew = False
	StartRec = saveRec
	
	!! 編集スタックの調整
	If EditCmdPos > 1 Then
		EditCmdStack = EditCmdStack[@FM,EditCmdPos,HUGE]
		EditCmdPos = 1
	End
	Find "SAVED_POINT" In EditCmdStack Setting f Then Del EditCmdStack<f>
	Ins "SAVED_POINT" Before EditCmdStack<1>
	EditCmdPos = 1
	
	GoSub PrintStatus
	Return
*--------------------------------------------------------------------------
* Delete
*--------------------------------------------------------------------------
Delete: 
	PromptLine = "Are you sure you wish to DELETE this item (Y/N) :"
	GoSub PromptLine
	GoSub GetKey
	
	If UpCase(C) = "Y" Else Return
	
	FileName = BufInfo<BI.FILE>
	ItemName = BufInfo<BI.ITEM>
	If FileName = "" Then Return
	If ItemName = "" Then Return
	
	GoSub Common.OpenFile
	Crt @(0, PY):
	ReadU prevRec From FL, ItemName On Error Return Locked
		StatusMessage = "Record previously Locked by ":Status():", Cannot Save"
		Return
	End Then
		Convert CHAR(10):CHAR(13) To '' In Rec ;** 改行コードが残っていたら自動除外
	End Else
		prevRec = ""
	End
	
	If prevRec >< StartRec Then
		StatusMessage = "Record previously Changed by Another, Cannot Save This Modify"
		Return
	End
	Delete FL, ItemName
	
	StatusMessage = "Deleted ":FileName:" ":ItemName
	GoSub Act.CloseBuff
	Return

*--------------------------------------------------------------------------
* SearchMenu
*--------------------------------------------------------------------------
SearchMenu: 
	MenuLine = "Find Again reVerse Replace | goLineno goDeclaration Outline :" ; GoSub MenuLine
	Ok = Upcase(C)
	Begin Case
		Case Ok = "F"
			Replacing = False
			SearchString=""
			GoSub Act.Search
		Case Ok = "A"
			searchReverse = False
			GoSub Act.Search
		Case Ok = "V"
			searchReverse = True
			GoSub Act.Search
		Case Ok = "R"
			Replacing = True
			GoSub Act.Search
		Case Ok = "L"
			GoSub Act.GoLine
		Case Ok = "D"
			GoSub Act.GoDeclaration
		Case Ok = "O"
			GoSub Act.ShowOutline
		End Case
	Return
	
* -----------------------------------------------------------------------
*  Setup Default Key Bindings

SetupDefKeyBindings:
	GoSub LoadKeyBindings
	Return

* -----------------------------------------------------------------------
* LoadKeyBindings

LoadKeyBindings:
	
	keys = ''
	keysToAction = ''
	err = @false
	
	!! 空白 -> @VM
	list = Convert(' ',@VM,TrimS(keySeq))
	
	action = 1
	Loop
		Remove z From list Setting delim
		
		n = Len(z)
		If n Then
			
			!! エスケープ戻す
			For i = 1 To n
				If z = '@@' Then
					z = Char(0)
				End Else If z[i,1] = '@' Then
					j = index('ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_',z[i+1,1],1)
					If j Then
						z = z[1,i-1] : char(j) : z[i+2,999]
						n -= 1
					End Else If z[i,2] = '@@' Then 
						z = z[1,i] : z[i+2,999]
					End
				End
			Next
			
			!! シーケンス解析
			n = seq(z[1,1])
			If n > 31 And n < 127 Then
			   Display "Key binding for action ":action:" does not start with a control character"
			   err = @TRUE
			End Else
				Locate z In keys By 'AL' Setting i Then
					Display "Duplicate key bindings. Actions ":keysToAction<i>:" and ":action
					err = @true
				End Else
					Ins z Before keys<i>
					Ins action Before keysToAction<i>
				End
			End
		End
	While delim
		If delim = 2 Then action += 1
	While action <= ACTION.ENUM.LAST
	Repeat
	
	Return

*-----------------------------------------------------------------------
*  SetupTokens
*-----------------------------------------------------------------------
SetupTokens: 
	KEYWORDS = ""
	AddKeyWord "ABORT"
	AddKeyWord "AND"
	AddKeyWord "BEGIN"
	AddKeyWord "BY"
	AddKeyWord "CALL"
	AddKeyWord "CASE"
	AddKeyWord "CATCH"
	AddKeyWord "CLEAR"
	AddKeyWord "CLEARFILE"
	AddKeyWord "CLEARSELECT"
	AddKeyWord "COMMIT"
	AddKeyWord "CONVERT"
	AddKeyWord "CREATE"
	AddKeyWord "CREATING.SEQKEY"
	AddKeyWord "CRT"
	AddKeyWord "DEL"
	AddKeyWord "DELETE"
	AddKeyWord "DELETELIST"
	AddKeyWord "DELETEU"
	AddKeyWord "DELIMITER"
	AddKeyWord "DIM"
	AddKeyWord "DO"
	AddKeyWord "EACH"
	AddKeyWord "ELSE"
	AddKeyWord "END"
	AddKeyWord "ENTER"
	AddKeyWord "EQU"
	AddKeyWord "EQUATE"
	AddKeyWord "ERROR"
	AddKeyWord "EXECUTE"
	AddKeyWord "EXIT"
	AddKeyWord "FIND"
	AddKeyWord "FINDSTR"
	AddKeyWord "FOR"
	AddKeyWord "FROM"
	AddKeyWord "FUNCTION"
	AddKeyWord "GOSUB"
	AddKeyWord "GOTO"
	AddKeyWord "IF"
	AddKeyWord "IN"
	AddKeyWord "INPUT"
	AddKeyWord "INS"
	AddKeyWord "LIKE"
	AddKeyWord "LOCAL"
	AddKeyWord "LOCATE"
	AddKeyWord "LOCKED"
	AddKeyWord "LOOP"
	AddKeyWord "MATCHES"
	AddKeyWord "NEXT"
	AddKeyWord "ON"
	AddKeyWord "OPEN"
	AddKeyWord "OPENDEV"
	AddKeyWord "OPENPATH"
	AddKeyWord "OPENSEQ"
	AddKeyWord "OR"
	AddKeyWord "PERFORM"
	AddKeyWord "PRINT"
	AddKeyWord "PRINTER"
	AddKeyWord "PRIVATE"
	AddKeyWord "PROGRAM"
	AddKeyWord "READ"
	AddKeyWord "READBLK"
	AddKeyWord "READLIST"
	AddKeyWord "READNEXT"
	AddKeyWord "READSEQ"
	AddKeyWord "READU"
	AddKeyWord "READV"
	AddKeyWord "READVU"
	AddKeyWord "RECORDLOCKL"
	AddKeyWord "RECORDLOCKU"
	AddKeyWord "RELEASE"
	AddKeyWord "REPEAT"
	AddKeyWord "RETURN"
	AddKeyWord "ROLLBACK"
	AddKeyWord "SELECT"
	AddKeyWord "SETTING"
	AddKeyWord "SSELECT"
	AddKeyWord "STATUS"
	AddKeyWord "STOP"
	AddKeyWord "SUBROUTINE"
	AddKeyWord "THEN"
	AddKeyWord "THROW"
	AddKeyWord "TO"
	AddKeyWord "TRANSACTION"
	AddKeyWord "TRY"
	AddKeyWord "UNTIL"
	AddKeyWord "WHILE"
	AddKeyWord "WRITE"
	AddKeyWord "WRITEBLK"
	AddKeyWord "WRITESEQ"
	AddKeyWord "WRITEU"
	AddKeyWord "WRITEV"
	AddKeyWord "WRITEVU"
	FUNCS = ""

	PUNCS = ", []()<>{}=+-/*:;^#!":Char(9)
	STRQTS = "'\":'"'
	Return
*-----------------------------------------------------------------------
*  ShowText
*-----------------------------------------------------------------------
ShowText: 
	LTop = 0
	LRefresh = True
	LFin = False
	Loop
		If LRefresh Then
			Crt @(0,0):@(-3):
			For TextLine = 1 To LISTDEPTH
				Crt @(0,TextLine):Text<TextLine + LTop>[1, Width]
			Next TextLine
			LRefresh = False
		End
		MenuLine = "Up Down or Esc :" 
		GoSub MenuLine
		Begin Case
			Case Upcase(C) = "U" Or actNo = A.UP
				If LTop >= LISTDEPTH Then
					LTop -= LISTDEPTH
					LRefresh = True
				End
			Case Upcase(C) = "D" Or actNo = A.DOWN
				LTop += LISTDEPTH
				LRefresh = True
			Case actNo = A.CANCEL
				LFin = True
			End case
	Until LFin Do
	Repeat
	Crt @(0,2):@(-3):
	GoSub ShowWindow
	Return
*-----------------------------------------------------------------------
*  Showwindow
*-----------------------------------------------------------------------
ShowWindow: 
	GoSub PrintPage
	Crt crtBuff:
	Return
*-----------------------------------------------------------------------
*  StartBuf
*-----------------------------------------------------------------------
StartBuf: 

	BufInfo<BI.FILE> = FileName
	BufInfo<BI.ITEM> = ItemName
	BufInfo<BI.PBUFNO> = ParentBufNo
	BufInfo<BI.FIELDFIX> = FldInfo
	BufInfo<BI.VALUEFIX> = DiveValuePos
	BufInfo<BI.USED> = True
	BufInfo<BI.BLOCKSTART> = False
	BufInfo<BI.READONLY> = False
	BufInfo<BI.CAPTURE> = If FileName = "" Then "(Untitled) [Create At ":OConv(Date(),"D-YMD[,2]"):" ":OConv(Time(),"MTS"):"]" Else ""

	!! アカウントの設定
	!! ショートネームがあればそちらを採用なければフルパス
	BufInfo<BI.ACCOUNT> = @PATH
	Open ACCOUNT.FILE To fpAcc Then
		Read rec From fpAcc,@ACCOUNT Then
			BufInfo<BI.ACCOUNT> = @ACCOUNT
		End
	End
	Close fpAcc
	
	Changed = False
	BufInfo<BI.LOCKED> = @FALSE
	DIRec = ""

	DiveValuePos = ""
	
	!! ParseTypeの自動判定
	ParseType = PARSE.DATA
	** Basic
	If FileName >< "" Then
$IFDEF U2__UNIVERSE
		Equ OBJ.FILENAME Lit 'FileName:".O"'
$ElSE
		Equ OBJ.FILENAME Lit 'FileName:".OUT"'
$ENDIF
		Open OBJ.FILENAME To fpBP.O Then
			Close fpBP.O
			ParseType = PARSE.BASIC
		End Else
			If FileName Matches "BP..." Or ItemName Matches "...'.H'" Then 
				ParseType = PARSE.BASIC
			End
		End
	End
	** Paragraph
	If Rec [1,2] = "PA" Then ParseType = PARSE.PARA
	BufInfo<BI.PARSETYPE> = ParseType
	BufInfo<BI.INDENTTYPE> = If ParseType = PARSE.DATA Then "Tab" Else DEFAULT.INDENT.TYPE
	BufInfo<BI.INDENTSIZE> = DEFAULT.INDENT
	
	Y = 1
	X = 1
	DP_X = 1
	keepDP_X = 1
	Top = 1
	XOffSet = 1
	Lines = If Rec = "" Then 1 Else DCount(Rec,@fm)
	EditCmdStack = "SAVED_POINT"
	EditCmdPos = 1
	StartRec = Rec
	
	Return
*-----------------------------------------------------------------------
*  ChangeBuf
*-----------------------------------------------------------------------
ChangeBuf: 
	** LRU List 入れ替え
	Find Found In lruBuffList Setting f Then
		Del lruBuffList<f>
		Ins Found Before lruBuffList<1>
	End
	CurBuf = Found
	
	If Not(IsNew) And @PATH = BufInfo<BI.ACCOUNT> Then
		FileName = BufInfo<BI.FILE>
		ItemName = BufInfo<BI.ITEM>

		GoSub Act.Reload
		
		!! ロック処理の再実行をしておく
		BufInfo<BI.LOCKED> = If BufInfo<BI.LOCKED> Then @FALSE Else @TRUE 
		GoSub DoLock
	End
	
	keepDP_X = X

	Return
*--------------------------------------------------------------------------
* SubstCommand
*--------------------------------------------------------------------------
SubstCommand: 
	Cmd = Change(Cmd,"%f", FileName)
	Cmd = Change(Cmd,"%i", ItemName)
	GoSub SubstPrompts
	Cmd = Change(Cmd,"|",@FM)
	Return
*---------------------------------------------------------------------------
* SubstPrompts
*---------------------------------------------------------------------------
SubstPrompts: 
	PromptList = ""
	NP = 0
	Loop
		NP += 1
		CIx = Index(Cmd,"{",NP)
	While CIx Do
		Temp = (Cmd["{",NP+1,1]["}",1,1])
		Locate Temp In PromptList Setting Pos ELse
			PromptList<-1> = Temp
		End
	Repeat
	For PromptNo = 1 To DCount(PromptList,@FM)
		PromptLine = PromptList<PromptNo> ; GoSub PromptLine
		Input Temp
		Cmd = Change(Cmd,"{":PromptList<PromptNo>:"}",Temp)
	Next
	RETURN
*--------------------------------------------------------------------------
* ToolsMenu
*--------------------------------------------------------------------------
ToolsMenu: 
	MenuLine = "Theme Keys :"
	GoSub MenuLine
	C = UpCase(C)
	Begin Case
		Case C = "T"
			GoSub ThemeMenu
		Case C = "K"
			GoSub Keys
			GoSub ShowWindow
		End Case
	Return
*--------------------------------------------------------------------------
* ThemeMenu
*--------------------------------------------------------------------------
ThemeMenu: 
	MenuLine = "1.Default 2.Solarized-dark 3.Solarized-light :"
	GoSub MenuLine
	If Not(C Matches "1N") Then Return
	theme = C
	GoSub Act.SwitchTheme
	Return
*---------------------------------------------------------------------------
* Keys
*---------------------------------------------------------------------------
Keys:   
	Crt @(-1):
!! 	Crt "Cursor Keys:"
!! 	KeyName = "Left"
!! 	KeyName = "Left" ; Key = K.LEFT ; GoSub ShowKey
!! 	KeyName = "Right" ; Key = K.RIGHT ; GoSub ShowKey
!! 	KeyName = "Up" ; Key = K.UP ; GoSub ShowKey
!! 	KeyName = "Down" ; Key = K.DOWN ; GoSub ShowKey
!! 	KeyName = "End" ; Key = K.END ; GoSub ShowKey
!! 	KeyName = "Home" ; Key= K.HOME ; GoSub ShowKey
!! 	KeyName = "Page Up" ; Key = K.PREVPAGE ; GoSub ShowKey
!! 	KeyName = "Next Word" ; Key = K.NEXTWORD ; GoSub ShowKey
!! 	KeyName = "Prev Word" ; Key = K.PREVWORD ; GoSub ShowKey

	actNo = 0	
	strKey = ""
	Loop
		a = @(0, PY-2):@(-13):"SHOW Key Sequence When Press Key (Exit->ESC):":@(-14):" "
		a := strKey
		If actNo Then a:= " actNo->":actNo
		a := @(-4)
		Crt a
		
		C = KeyIn()
		Loop
			GoSub GetCh.Timeout
		While ch <> ""
			C := ch
		Repeat

		If C = ESC Then Exit
		
		!! 文字列形式にエスケープ
		strKey = ""
		z = Len(C)
		For i = 1 To z
			c = C[i,1]
			n = Seq(c)
			Print n:" ":
			If n < 32 Then strKey := '@' : Char(n + 64)
			Else strKey := c
		Next
		Print @(-4)
		
		!! キーシーケンスからアクションを取得
		Locate C in keys By 'AL' Setting i Then
			actNo = keysToAction<i,1>
		End Else 
			actNo = 0
		End
		
	Repeat
	Return
	
!! ShowKey: 
!! 	Convert "'" To "" In Key
!! 	Crt KeyName "L#20" :
!! 	For U = 1 to Len(Key)
!! 		Crt Seq(Key[U,1]):";":
!! 	Next
!! 	Crt
!! 	Return

*--------------------------------------------------------------------------
* InputBox
*   In :
*     inputBox -> 初期入力値
*   OUT : 
*     inputBox -> 確定された入力データ
*--------------------------------------------------------------------------
InputBox:

	prevCurBuf = CurBuf
	CurBuf = MAXWINDOWS + 1
		
	Rec = inputBox
	Y = 1
	X = Len(Rec)+1
	Top = 1
	XOffSet = 1
	Lines = If Rec = "" Then 1 Else DCount(Rec,@fm)
	EditCmdStack = "SAVED_POINT"
	EditCmdPos = 1
	crtBuff = ""
	If inputBox >< "" Then
		BufInfo<BI.BLOCKSTART> = Y:@VM:1
		BufInfo<BI.BLOCKEND> = Y:@VM:X
	End

	!! カーソル位置を保存
	Crt ESC:"[s":
	
	Loop
		
		!! １行に固定する
		Y = 1
		Rec = Rec<1>
		
		GoSub Draw.InputBox
		
		GoSub GetKey
		
		keepSelection = False
		
		Begin Case
			!! Cancel
			Case actNo = A.CANCEL
				actNo = 0
				inputBox = ""
				GoTo InputBox.Ending
				
			!! Confirm
			Case actNo = A.NEWLINE
				inputBox = Rec
				GoTo InputBox.Ending
				
			!! WordHokan
			Case actNo = A.WORD_HOKAN
				
				!! 現在カーソル位置から単語の先頭までの単語を取得
				GoSub Get.CurrentWord
				
				!! 置換範囲を描画
				BufInfo<BI.BLOCKSTART> = Y:@VM:stX
				BufInfo<BI.BLOCKEND> = Y:@VM:X
				GoSub Draw.InputBox
				
				CurBuf = prevCurBuf
				
				!! 現在ファイルの単語一覧を取得
				lineList = Rec
				GoSub Get.WordList
				
				CurBuf = MAXWINDOWS + 1
				
				InsBuffer = ""
				
				GoSub Core.ShowWordHokan
				
				If InsBuffer <> "" Then
					GoSub InsertLines
				End
				
				If CMD_BUF <> prevCurBuf Then
					!! エディタモードなら再描画
					CurBuf = prevCurBuf
					GoSub PrintTextArea
					Crt CRT.BUFF.FLUSH:
					CurBuf = MAXWINDOWS + 1
				End
				
			!! 共通アクション
			Case 1
				GoSub Input.Actions
				
		End Case
		
		** --------------------------
		** 選択範囲調整
		** --------------------------
		If keepSelection Then
			** 選択終了位置
			If Not(BufInfo<BI.BLOCKEND>) Then BufInfo<BI.BLOCKEND> = Y:@VM:X
		End Else
			** 選択範囲が外れた
			BufInfo<BI.BLOCKSTART> = ""
			BufInfo<BI.BLOCKEND> = ""
		End
		
	Repeat

InputBox.Ending:
	
	CurBuf = prevCurBuf
	
Return

Draw.InputBox:

	!! 選択範囲の描画
	Line = Rec
	Row = 1
	GoSub ParseLine
	
	!! 表示
	crtBuff = ESC:"[u" ;** カーソル位置を復元
	crtBuff := PLine:@(-4) ;** 文字列の描画
	If Len(Rec) >= X Then crtBuff := @(-9,LenDP(Rec[X,HUGE])) ;** 実際のカーソル位置に戻す
	 
	** CRTフラッシュ処理
	Crt CRT.BUFF.FLUSH:
	
	Return

*--------------------------------------------------------------------------
* Input.Actions
* Switch.Actions

Input.Actions:
	
	If actNo > ENUM.INPUT.ACTION.LAST Then Return
	
Switch.Actions:
	
	If actNo = 0 Then Return
	
	On actNo Goto Act.Left,               ;** Cursor Left
								Act.Right,
								Act.Up,
								Act.Down,
								Act.Home,
								Act.End,
								Act.NextPage,
								Act.PrevPage,
								Act.NextHalf,
								Act.PrevHalf,
								Act.NextWord,
								Act.PrevWord,
								Act.NextStmt,
								Act.PrevStmt,
								Act.NextChar,
								Act.PrevChar,
								Act.Top,
								Act.Bottom,
								Act.SelLeft,
								Act.SelRight,
								Act.SelUp,
								Act.SelDown,
								Act.SelHome,
								Act.SelEnd,
								Act.SelNextWord,
								Act.SelPrevWord,
								Act.SelNextStmt,
								Act.SelPrevStmt,
								Act.SelNextPage,
								Act.SelPrevPage,
								Act.SelNextHalf,
								Act.SelPrevHalf,
								Act.SelNextChar,
								Act.SelPrevChar,
								Act.SelTop,
								Act.SelBottom,
								Act.ScrollMid,
								Act.NewLine,
								Act.InsertChar,
								Act.DelLine,
								Act.DelBackCh,
								Act.DelCh,
								Act.Cut,
								Act.Copy,
								Act.SendRemotePasteCmd,
								Act.Paste,
								Act.PasteLocal,
								Act.Undo,
								Act.Redo,
								Act.SelAll,
								Act.SelExpand,	
								Act.Cancel,
								Act.Tab,
								Act.ShiftTab,
								Act.SwitchTheme,
								Act.InsVMC,
								Act.InsSMC,
								Act.InsTMC,
								Act.InsTemplate,
								Act.InsCommentOut,
								Act.Search,
								Act.Repeat,
								Act.Reverse,
								Act.Replace,
								Act.ShowBuffList,
								Act.ShowOutline,
								Act.GoLine,
								Act.GoDeclaration,
								Act.GoNextJumpHist,
								Act.GoPrevJumpHist,
								Act.Save,
								Act.ShowHelp,
								Act.Compile,
								Act.Reload,
								Act.Action,
								Act.Exit,
								Act.CloseBuff,
								Act.GoDive,
								Act.ToggleCaseInvert,
								Act.Fit.Term,
								Act.ShowWordHokan
NULL.Action:
	Return

* **************************************************************************
* Act.Left

Act.Fit.Term:
	GoSub AutoTermSize
	IF bAutoCommand Then
		bAutoEditor = @TRUE
		GoSub Act.Exit
	End
	Return

* **************************************************************************
* Act.Left

Act.SelLeft:
	GoSub SelectionStart
Act.Left:
	If BufInfo<BI.BLOCKEND> Then
		prevPos = Y:@FM:X
		GoSub GoToRangeStart
		If prevPos <> Y:@FM:X Then Return ;** Go To Range Start Then Stop
	End

	If X > 1 Then X -= 1 Else
		If Y > 1 Then
			Y -= 1 ; X = Len(Rec<Y>) + 1
		End
	End
	Return

* **************************************************************************
* Act.Right

Act.SelRight:
	GoSub SelectionStart
Act.Right:
	If BufInfo<BI.BLOCKEND> Then
		prevPos = Y:@FM:X
		GoSub GoToRangeEnd
		If prevPos <> Y:@FM:X Then Return ;** Go To Range End Then Stop
	End
	
	If Rec<Y>[X,1] = "" Then
		If Y < Lines Then Y += 1 ; X = 1
	End Else
		X += 1
	End
	Return

* **************************************************************************
* Act.Up

Act.SelUp:
	GoSub SelectionStart
Act.Up:
	If BufInfo<BI.BLOCKEND> Then
		prevPos = Y:@FM:X
		GoSub GoToRangeStart
		X = prevPos<2> ;** X位置は元に戻す
	End
	
	If Y > 1 Then
		Y -= 1
		If Y < Top + SCROLLMERGINE And Top > 1 Then
			** 高速１行上スクロール
			Top -= 1
			crtBuff := ESC:"[1;":Depth:"r":ESC:"[T":ESC:"[1;":@CRTHIGH:"r"
			Redraw<-1> = Top:@FM:prevY:@FM:Y
		End
		moveY = True
	End
	Return

* **************************************************************************
* Act.Down

Act.SelDown:
	GoSub SelectionStart
Act.Down:
	If BufInfo<BI.BLOCKEND> Then
		prevPos = Y:@FM:X
		GoSub GoToRangeEnd
		X = prevPos<2> ;** X位置は元に戻す
	End
	
	If Y < Lines Then
		Y += 1
		bottomY = Depth + Top
		If Y = bottomY - SCROLLMERGINE Then
			** 高速１行下スクロール
			Top += 1
			crtBuff := ESC:"[1;":Depth:"r":ESC:"[S":ESC:"[1;":@CRTHIGH:"r"
			Redraw<-1> = bottomY:@FM:prevY:@FM:Y
		End
		moveY = True
	End
	Return

* **************************************************************************
* Act.NextWord

Act.SelNextWord:
	GoSub SelectionStart
Act.NextWord:
	If BufInfo<BI.BLOCKEND> Then
		prevPos = Y:@FM:X
		GoSub GoToRangeEnd
		If prevPos <> Y:@FM:X Then Return ;** Go To Range End Then Stop
	End
	
	Line = Rec<Y>
	If X >= Len(Line)+1 Then
		!! 次の行へ
		If Y < Lines Then Y += 1; X = 1
	End Else
		If Line[1,X] = Space(X) Then
			!! インデント部
			
			X = Int((X-1) / STDINDENT) * STDINDENT + STDINDENT + 1
			
		End Else
			!! 非インデント部
			If kakko >< "" And X < kakko<2,1> Then
				!! 対応する括弧の後ろに移動
				X = kakko<2,1> + 1
				If BufInfo<BI.BLOCKSTART> Then BufInfo<BI.BLOCKEND> = Y:@VM:X
			End Else
				!! 単語移動
				GoSub Move.NextWord
			End
		End
	End
			
	Return

* **************************************************************************
* Act.PrevWord

Act.SelPrevWord:
	GoSub SelectionStart
Act.PrevWord:
	If BufInfo<BI.BLOCKEND> Then
		prevPos = Y:@FM:X
		GoSub GoToRangeStart
		If prevPos <> Y:@FM:X Then Return ;** Go To Range Start Then Stop
	End
	
	Line = Rec<Y>
	If X <= 1 Then
		!! 前の行へ
		If Y > 1 Then Y -= 1; X = Len(Rec<Y>)+1
	End Else
	
		If Line[1,X-1] = Space(X-1) Then
			!! インデント部
			
			X = Int((X-1) / STDINDENT) * STDINDENT - STDINDENT + 1
			
		End Else
			!! 非インデント部
			
			If kakko >< "" And X > kakko<2,1> Then
				!! 対応する括弧に移動
				X = kakko<2,1>
				If BufInfo<BI.BLOCKSTART> Then
					BufInfo<BI.BLOCKEND> = Y:@VM:X
				End
			End Else
				!! 単語移動
				GoSub Move.PrevWord
			End
		End      
	End
	
	Return

* **************************************************************************
* Act.NextStmt

Act.SelNextStmt:
	GoSub SelectionStart
Act.NextStmt:
	If BufInfo<BI.BLOCKEND> Then
		prevPos = Y:@FM:X
		GoSub GoToRangeEnd
		X = prevPos<2> ;** X位置は元に戻す
	End
	
	If Count("*!",TrimF(Rec<Y>)[1,1]) Then
		!! コメント行内
		Line = Change(Rec<Y+1>,Char(9),Space(STDTAB))
		GoSub GetX.From.keepDPX
		ch = Line[outX,1]
		If Not(Count("*!",ch)) And (ch = "" Or TrimF(Convert("*!","  ",Line)[1,outX]) = "") Then
			!! 次行がインデント内なら次に文字が出現するまで進む
			For iY = Y+1 To Lines
				Line = Change(Rec<iY>,Char(9),Space(STDTAB))
				GoSub GetX.From.keepDPX
				If Not(Line[outX,1] = "" Or TrimF(Convert("*!","  ",Line)[1,outX]) = "") Then Exit
			Next 
			Y = iY
		End Else
			!! 次行が文字なら３行進むかインデントの出現かコメント行でない場合に止める
			For iY = Y+1 To Y+4
				Line = Change(Rec<iY>,Char(9),Space(STDTAB))
				If Not(Count("*!",TrimF(Line)[1,1])) Then Exit
				GoSub GetX.From.keepDPX
				ch = Line[outX,1]
				If Not(Count("*!",ch)) And (ch = "" Or TrimF(Convert("*!","  ",Line)[1,outX]) = "") Then Exit
			Next
			Y = If iY - 1 = Y Then Y + 1 Else iY - 1
		End
	End Else
		!! コメント行外
		Line = Change(Rec<Y+1>,Char(9),Space(STDTAB))
		GoSub GetX.From.keepDPX
		If Count("*!",TrimF(Line)[1,1]) Or Line[outX,1] = "" Or TrimF(Line[1,outX]) = "" Then
			!! 次行がインデント内なら次に文字が出現するまで進む
			For iY = Y+1 To Lines
				Line = Change(Rec<iY>,Char(9),Space(STDTAB))
				If Count("*!",TrimF(Line)[1,1]) Then Continue
				GoSub GetX.From.keepDPX
				If Not(Line[outX,1] = "" Or TrimF(Line[1,outX]) = "") Then Exit
			Next 
			Y = iY
		End Else
			!! 次行が文字なら３行進むかインデントの出現かコメント行の出現で止める
			For iY = Y+1 To Y+4
				Line = Change(Rec<iY>,Char(9),Space(STDTAB))
				If Count("*!",TrimF(Line)[1,1]) Then Exit
				GoSub GetX.From.keepDPX
				If Line[outX,1] = "" Or TrimF(Line[1,outX]) = "" Then Exit
			Next
			Y = iY-1
		End
	End
	If Y > Lines Then Y = Lines
	moveY = True
	Return

* **************************************************************************
* Act.PrevStmt

Act.SelPrevStmt:
	GoSub SelectionStart
Act.PrevStmt:
	If BufInfo<BI.BLOCKEND> Then
		prevPos = Y:@FM:X
		GoSub GoToRangeStart
		X = prevPos<2> ;** X位置は元に戻す
	End
	
	If Count("*!",TrimF(Rec<Y>)[1,1]) Then
		!! コメント行内
		Line = Rec<Y-1>
		ch = Line[X,1]
		If Not(Count("*!",ch)) And (ch = "" Or TrimF(Convert("*!","  ",Line)[1,X]) = "") Then
			!! 次行がインデント内なら次に文字が出現するまで進む
			For iY = Y-1 To 1 Step -1
				Line = Rec<iY>
				If Not(Line[X,1] = "" Or TrimF(Convert("*!","  ",Line)[1,X]) = "") Then Exit
			Next 
			Y = iY
		End Else
			!! 次行が文字なら３行進むかインデントの出現で止める
			For iY = Y-1 To Y-4 Step -1
				Line = Rec<iY>
				ch = Line[X,1] 
				If Not(Count("*!",TrimF(Line)[1,1])) Then Exit
				If Not(Count("*!",ch)) And (ch = "" Or TrimF(Convert("*!","  ",Line)[1,X]) = "") Then Exit
			Next
			Y = If iY + 1 = Y Then Y - 1 Else iY + 1
		End
	End Else
		!! コメント行外
		Line = Change(Rec<Y-1>,Char(9),Space(STDTAB))
		GoSub GetX.From.keepDPX
		If Count("*!",TrimF(Line)[1,1]) Or Line[outX,1] = "" Or TrimF(Line[1,outX]) = "" Then
			!! 次行がインデント内なら次に文字が出現するまで進む
			For iY = Y-1 To 1 Step -1
				Line = Change(Rec<iY>,Char(9),Space(STDTAB))
				If Count("*!",TrimF(Line)[1,1]) Then Continue
				GoSub GetX.From.keepDPX
				If Not(Line[outX,1] = "" Or TrimF(Line[1,outX]) = "") Then Exit
			Next 
			Y = iY
		End Else
			!! 次行が文字なら３行進むかインデントの出現で止める
			For iY = Y-1 To Y-4 Step -1
				Line = Change(Rec<iY>,Char(9),Space(STDTAB))
				If Count("*!",TrimF(Line)[1,1]) Then Exit
				GoSub GetX.From.keepDPX
				If Line[outX,1] = "" Or TrimF(Line[1,outX]) = "" Then Exit
			Next
			Y = iY+1
		End
	End
	If Y < 1 Then Y = 1
	moveY = True
	Return

* **************************************************************************
* Act.NextChar

Act.SelNextChar:
	GoSub SelectionStart
	BufInfo<BI.BLOCKEND> = ""
Act.NextChar:
	moveChar = @TRUE ;** 進むフラグ
	keepSelection = @TRUE
	Return

* **************************************************************************
* Act.PrevChar

Act.SelPrevChar:
	GoSub SelectionStart
	BufInfo<BI.BLOCKEND> = ""
Act.PrevChar:
	moveChar = @FALSE ;** 戻るフラグ
	keepSelection = @TRUE
	Return

* **************************************************************************
* Act.End

Act.SelEnd:
	GoSub SelectionStart
Act.End:
	GoSub GoToRangeEnd
	
	X = Len(Rec<Y>) + 1
	Return

* **************************************************************************
* Act.Home

Act.SelHome:
	GoSub SelectionStart
Act.Home:
	GoSub GoToRangeStart
	
	** 論理行頭を探す
	logicalX = 1
	For i= 1 To HUGE
		a = Rec<Y>[i,1]
		If a > CHAR(32) Then logicalX = i; Exit
	While a >< ""
	Next
	** 現在位置が論理行頭なら先頭行にする
	If logicalX = X Then X = 1 Else X = logicalX
	If XOffSet > 1 Then Redraw = REDRAW.ALL
	XOffSet = 1
	Return

* **************************************************************************
* Act.NextPage

Act.SelNextPage:
	GoSub SelectionStart
Act.NextPage:
	If BufInfo<BI.BLOCKEND> Then
		prevPos = Y:@FM:X
		GoSub GoToRangeEnd
		X = prevPos<2> ;** X位置は元に戻す
	End
	
	dispY = Y - Top
	Y += Depth
	If Y > Lines Then Y = Lines
	Top = Y - dispY
	moveY = True
	Redraw = REDRAW.ALL
	Return

* **************************************************************************
* Act.PrevPage

Act.SelPrevPage:
	GoSub SelectionStart
Act.PrevPage:
	If BufInfo<BI.BLOCKEND> Then
		prevPos = Y:@FM:X
		GoSub GoToRangeStart
		X = prevPos<2> ;** X位置は元に戻す
	End
	
	dispY = Y - Top
	Y -= Depth
	If Y < 1 Then Y = 1
	Top = Y - dispY
	If Top <= 0 Then Top = 1
	moveY = True
	Redraw = REDRAW.ALL
	Return

* **************************************************************************
* Act.NextHalf

Act.SelNextHalf:
	GoSub SelectionStart
Act.NextHalf:
	If BufInfo<BI.BLOCKEND> Then
		prevPos = Y:@FM:X
		GoSub GoToRangeEnd
		X = prevPos<2> ;** X位置は元に戻す
	End
	
	cnt = Int(Depth/3)
	For curMoveCnt = 1 To cnt
		GoSub Act.Down
	Next
	Return

* **************************************************************************
* Act.PrevHalf

Act.SelPrevHalf:
	GoSub SelectionStart
Act.PrevHalf:
	If BufInfo<BI.BLOCKEND> Then
		prevPos = Y:@FM:X
		GoSub GoToRangeStart
		X = prevPos<2> ;** X位置は元に戻す
	End
	
	cnt = Int(Depth/3)
	For curMoveCnt = 1 To cnt
		GoSub Act.Up
	Next
	Return

* **************************************************************************
* Act.Top

Act.SelTop:
	GoSub SelectionStart
Act.Top:
	GoSub GoToRangeStart
	
	Y = 1
	X = 1
	If prevY >< Y Then moveY = True
	Return

* **************************************************************************
* Act.Bottom

Act.SelBottom:
	GoSub SelectionStart
Act.Bottom:
	GoSub GoToRangeEnd
	
	Y = Lines
	X = Len(Rec<Y>)+1
	If prevY >< Y Then moveY = True
	Return

* **************************************************************************
* Act.SelAll
* 全選択

Act.SelAll:
	If BufInfo<BI.BLOCKSTART> = 1:@VM:1 And BufInfo<BI.BLOCKEND> = Lines:@VM:(Len(Rec<Lines>) + 1) Then
		!! 全選択解除
		keepSelection = @FALSE
	End Else
		!! 全選択
		BufInfo<BI.BLOCKSTART,1> = 1
		BufInfo<BI.BLOCKSTART,2> = 1
		BufInfo<BI.BLOCKEND,1> = Lines
		BufInfo<BI.BLOCKEND,2> = Len(Rec<Lines>) + 1
		keepSelection = @TRUE
	End
	Return

* **************************************************************************
* Act.SelExpand
* 選択範囲拡張
* -> 単語 -> 両端スペース -> 1行 -> 同一インデント行 -> なし

Act.SelExpand:
	
	If BufInfo<BI.BLOCKSTART> Then
		GoSub GetSelBlock
		If blockStart<2> = 1 And blockEnd<2> = 1 Then
			!! 行選択 -> 同一インデント行選択
			
			bChanged = @FALSE ;** 選択範囲に変化があったかどうか
			
			!! 選択先端
			iY = blockStart<1>
			line = Rec<iY>
			GoSub GetIndentCnt
			If indentCnt > 0 Then
				baseIndentCnt = indentCnt
				Loop
					iY -= 1
					line = Rec<iY>
					GoSub GetIndentCnt
				Until baseIndentCnt > indentCnt Or iY = 1
					bChanged = @TRUE
					BufInfo<BI.BLOCKSTART,1> = iY
				Repeat
			End
			
			!! 選択末端
			iY = blockEnd<1> - 1
			line = Rec<iY>
			GoSub GetIndentCnt
			If indentCnt > 0 Then
				baseIndentCnt = indentCnt
				Loop
					iY += 1
					line = Rec<iY>
					GoSub GetIndentCnt
				Until baseIndentCnt > indentCnt Or iY = Lines
					bChanged = @TRUE
					BufInfo<BI.BLOCKEND,1> = iY + 1
				Repeat
			End
			
			If Not(bChanged) Then
				!! 同一インデント行選択 -> 解除
				keepSelection = @FALSE
				Redraw = REDRAW.ALL
				Return
			End
			
		End Else
			!! 単語選択 < 行選択
			
			sY = blockStart<1>
			sX = blockStart<2>
			eY = blockEnd<1>
			eX = blockEnd<2>
			
			Line = Rec<Y>
			ch = Line[X,1]
			If Not(Count(' ':CHAR(9),ch)) Then
				!! カーソル位置が空白でなければ選択範囲を空白まで進める
				
				!! 選択開始を空白文字まで進める
				Loop
					sX -= 1
					C = Line[sX,1]
				Until sX <= 0 Or Count(' ':CHAR(9),C) Do
				Repeat
				sX += 1
				If BufInfo<BI.BLOCKSTART,1> = sY Then
					BufInfo<BI.BLOCKSTART,2> = sX
				End Else
					BufInfo<BI.BLOCKEND,2> = sX
				End
				
				!! 選択終了を空白文字まで進める
				Line = Rec<eY>
				Loop
					C = Line[eX,1]
				Until C = "" Or Count(' ':CHAR(9),C) Do
					eX += 1
				Repeat
				If BufInfo<BI.BLOCKEND,1> = eY Then
					BufInfo<BI.BLOCKEND,2> = eX
				End Else
					BufInfo<BI.BLOCKSTART,2> = eX
				End
				
			End
			
			If blockStart<2> = sX And blockEnd<2> = eX Then
				!! 選択 -> 1行選択(改行込)
				BufInfo<BI.BLOCKSTART,1> = blockStart<1>
				BufInfo<BI.BLOCKSTART,2> = 1
				BufInfo<BI.BLOCKEND,1> = blockEnd<1> + 1
				BufInfo<BI.BLOCKEND,2> = 1
			End
			
		End
	End Else
		!! 単語選択
		GoSub GetWord
		BufInfo<BI.BLOCKSTART,2> = SOW
		BufInfo<BI.BLOCKEND,2> = EOW
		BufInfo<BI.BLOCKSTART,1> = Y
		BufInfo<BI.BLOCKEND,1> = Y
	End
	keepSelection = @TRUE

Return

* **************************************************************************
* Act.Cancel

Act.Cancel:
	If BufInfo<BI.BLOCKSTART> Then
		!! 選択があれば選択解除
		keepSelection = @FALSE
		actNo = 0 ;** Cancelは無効にする
	End
	Return

* **************************************************************************
* Act.ScrollMid

Act.ScrollMid:
	GoSub StackJumpHistory ;** ジャンプ位置も記録しておく
	Top = Y - Int(Depth / 2)
	If Top < 1 Then Top = 1
	Redraw = REDRAW.ALL
	Return

* **************************************************************************
* Act.DelCh

Act.DelCh:
	
	editCmd = ""
	
	If BufInfo<BI.BLOCKSTART> Then
		** 選択中
		editCmd<1> = BufInfo<BI.BLOCKEND, 1>
		editCmd<2> = BufInfo<BI.BLOCKEND, 2>
		editCmd<3> = BufInfo<BI.BLOCKSTART, 1>
		editCmd<4> = BufInfo<BI.BLOCKSTART, 2>
	End Else
		editCmd<1> = Y
		editCmd<2> = X
		editCmd<3> = Y
		editCmd<4> = X+1
	End
	editCmd<5> = ""
	editCmd<6> = "1" ;** 選択範囲がX=1の時はカーソルX位置をキープする
	
	GoSub StackEditCmd
	
	Return

* **************************************************************************
* Act.DelBackCh

Act.DelBackCh:
	
	If Y=1 & X=1 Else
	
		editCmd = ""
		
		If BufInfo<BI.BLOCKSTART> Then
			** 選択中
			editCmd<1> = BufInfo<BI.BLOCKEND, 1>
			editCmd<2> = BufInfo<BI.BLOCKEND, 2>
			editCmd<3> = BufInfo<BI.BLOCKSTART, 1>
			editCmd<4> = BufInfo<BI.BLOCKSTART, 2>
		End Else
			editCmd<1> = Y
			editCmd<2> = X
			If X = 1 Then
				editCmd<3> = Y-1
				editCmd<4> = Len(Rec<Y-1>)+1
			End Else
				editCmd<3> = Y
				editCmd<4> = X-1
			End
		End
		editCmd<5> = ""
		editCmd<6> = ""
		
		GoSub StackEditCmd
		
	End
	
	Return

* **************************************************************************
* Act.DelLine

Act.DelLine:
	
	tmpX = X ;** X位置を維持する
	
	editCmd = ""
	editCmd<1> = Y
	editCmd<2> = 1
	editCmd<3> = Y+1
	editCmd<4> = 1
	editCmd<5> = ""
	editCmd<6> = ""
	
	GoSub StackEditCmd
	
	X = tmpX
	
	Return


* **************************************************************************
* Act.InsertChar

Act.InsertChar:
	
	If moveChar Then
		!! １文字移動割り込み処理モード
		If moveChar<2> = "" Then
			moveChar<2> = C ;** 検索文字をセット
		End
		If moveChar<2> = C Then
			ch = moveChar<2>
			iY = Y
			If moveChar<1> Then
				If BufInfo<BI.BLOCKEND> And BufInfo<BI.BLOCKEND> <> Y:@VM:X Then
					!! カーソルと範囲終了の位置が違う場合は
					!! カーソルを範囲先端に持っていく
					GoSub GetSelBlock
					Y = blockStart<1>
					X = blockStart<2>
					prevY = Y
					prevX = X
					BufInfo<BI.BLOCKSTART> = Lower(blockEnd)
				End
				!! 進む
				iX = Index(Rec<iY>[X+1,HUGE],ch,1)
				If Not(iX) Then
					endY = Y+(Depth-(Y-Top))-1
					For iY = Y+1 To endY
						iX = Index(Rec<iY>,ch,1)
						If iX Then Exit
					Next 
				End Else iX = X + iX
			End Else
				If BufInfo<BI.BLOCKEND> And BufInfo<BI.BLOCKEND> <> Y:@VM:X Then
					!! カーソルと範囲終了の位置が違う場合は
					!! カーソルを範囲先端に持っていく
					GoSub GetSelBlock
					Y = blockStart<1>
					X = blockStart<2>
					prevY = Y
					prevX = X
					BufInfo<BI.BLOCKSTART> = Lower(blockEnd)
				End
				!! 戻る
				Line = Rec<iY>[1,X-1]
				iX = Index(Line,ch,Count(Line,ch))
				If Not(iX) Then
					For iY = Y-1 To Top Step -1
						Line = Rec<iY>
						iX = Index(Line,ch,Count(Line,ch))
						If iX Then Exit
					Next 
				End
			End
			If iX Then
				Y = iY
				X = iX
			End
			BufInfo<BI.BLOCKEND> = ""
			keepSelection = @TRUE
			Return ;** !! 入力は無かった事にする
		End
		moveChar = "" ;** モード解除
	End
	
	!! 文字挿入
	InsBuffer = C
	GoSub InsertLines
	Return

* **************************************************************************
* Act.Search

Act.Search:
	Replacing = False
	searchReverse = False
	SearchString = ""
	GoSub Search.Core
	Return

* **************************************************************************
* Act.Repeat

Act.Repeat:
	searchReverse = False
	GoSub Search.Core
	Return

* **************************************************************************
* Act.Reverse

Act.Reverse:
	searchReverse = True
	GoSub Search.Core
	Return

* **************************************************************************
* Act.Replace

Act.Replace:
	Replacing = True
	SearchString = ""
	GoSub Search.Core
	Return

* --------------------------------------------------------------------------
* Search.Core

Search.Core:
	If SearchString = "" And BufInfo<BI.BLOCKSTART> Then
		** 選択されている文字列を初期値にする
		If BufInfo<BI.BLOCKSTART,1> = BufInfo<BI.BLOCKEND,1> Then
			** 単行選択であること
			startX = BufInfo<BI.BLOCKSTART,2>
			endX = BufInfo<BI.BLOCKEND, 2>
			If startX > endX Then tmp = startX; startX = endX; endX = tmp
			PromptLine = "Enter Search Text ->" ; GoSub PromptLine
			inputBox = Rec<Y>[startX, endX-startX]
			GoSub InputBox
			SearchString = inputBox
			If Replacing Then X = startX - 2
		End
	End
	
	If (SearchString = "") Then 
		PromptLine = "Enter Search Text ->" ; GoSub PromptLine
		inputBox = ""
		GoSub InputBox
		SearchString = inputBox
	End
	
	!! ハイライト文字列の設定
	BufInfo<BI.HIWORD> = SearchString
	
	!! 小文字のみの場合に大小無視
	ignoreCase = @TRUE
	len = Len(SearchString)
	For i = 1 To len
		c = SearchString[i,1]
		If 'a' <= c And c <= 'z' Or c = '.' Or c = '_' Else ignoreCase = @FALSE
	Next
	
	Redraw = REDRAW.ALL
	If SearchString = "" Then Return
	
	!!
	!! 検索ループ
	!!
	firstFound = @TRUE
	replaceCnt = 0
	skipVerify = @FALSE
	Loop

		GoSub StackJumpHistory
	
		!! 検索ロジック
		isFound = @FALSE
		If ignoreCase Then
			!! 大小無視
			If searchReverse Then
				Ix = X - 1
				For Iy = Y To 1 Step -1
					Line = DownCase(Rec<Iy>[1,Ix])
					Ix = Index(Line, SearchString, Count(Line,SearchString))
					If Ix Then
						If Not(Y = Iy And X <= Ix) Then
							Y = Iy
							X = Ix
							isFound = @TRUE
							Exit
						End
					End
					Ix = HUGE
				Next
			End Else
				Ix = X + 1
				For Iy = Y To Lines
					idx = Index(DownCase(Rec<Iy>[Ix,HUGE]), SearchString, 1)
					If idx Then
						Ix += idx - 1
						If Not(Y = Iy And X >= Ix) Then
							Y = Iy
							X = Ix
							isFound = @TRUE
							Exit
						End
					End
					Ix = 1
				Next
			End
		End Else
			!! 完全一致
			If searchReverse Then
				Ix = X - 1
				For Iy = Y To 1 Step -1
					Line = Rec<Iy>[1,Ix]
					Ix = Index(Line, SearchString, Count(Line,SearchString))
					If Ix Then
						If Not(Y = Iy And X <= Ix) Then
							Y = Iy
							X = Ix
							isFound = @TRUE
							Exit
						End
					End
					Ix = HUGE
				Next
			End Else
				SPos = Len(Rec[@fm, 1, Y-1]) + X + 2
				Ix = Index(Rec[SPos,HUGE], SearchString, 1)
				If Ix Then
					Ox = SPos + Ix - 1
					Y = DCount(Rec[1, Ox], @fm)
					X = Len(Rec[1, Ox][@fm, Y,1])
					isFound = @TRUE
				End
			End
		End
		
		!! 見つかった
		If isFound Then
			!! 検索単語を選択する
			BufInfo<BI.BLOCKSTART> = Y:@VM:X
			BufInfo<BI.BLOCKEND> = Y:@VM:X+Len(SearchString)
			keepSelection = True
			If Replacing Then
				Top = If Y > 10 Then Y - 10 Else 1
				If X < XOffSet Then XOffSet = X
				
				If X > (XOffSet + Width) Then XOffSet = X
				GoSub ShowWindow
				
				If firstFound Then
					firstFound = @FALSE
					PromptLine = "Enter Replacement ->"; GoSub PromptLine
					inputBox = ""
					GoSub InputBox
					Replacement = inputBox
					PromptLine = "All or Verify :"; GoSub PromptLine
					GoSub GetKey
					Ok = TrimF(UpCase(C[1,1]))
					If Ok = "A" Then
						!! 全単語置換
						skipVerify = @TRUE
						Y = 1 ; X = 1
						Continue
					End Else
						If Ok <> "V" Then Exit
					End
				End
				
				If skipVerify Then
					Ok = "Y"
				End Else 
					PromptLine = "Replace This Selection (Y/N/Cancel) :"; GoSub PromptLine
					GoSub GetKey
					Ok = UpCase(TrimF(C)[1,1])
				End
				
				Begin Case
					Case Ok = "Y"
						InsBuffer = Replacement
						GoSub InsertLines
					Case Ok = "N"
						X += 1
					Case 1
						Exit
				End Case
				X -= 1
				BufInfo<BI.BLOCKSTART> = Y:@VM:X
				BufInfo<BI.BLOCKEND> = Y:@VM:X+Len(SearchString)
				keepSelection = True
				replaceCnt += 1
			End Else
				Exit
			End
		End Else
			!! 見つからなかった
			
			Del jumpHistory<1> ;** Jump履歴を戻す
			
			If Y = 1 And X= 1 Then
				StatusMessage = "Search Text Not Found"
				Exit
			End
			If Replacing And skipVerify Then
				StatusMessage = replaceCnt:" Strings Replaced"
				Exit
			End
			GoSub ShowWindow
			PromptLine = "Search Text Not Found - Start from ":(If searchReverse Then "Buttom" Else "Top"):"(Y) :" ; GoSub PromptLine
			GoSub GetKey
			If UpCase(C) = "Y" Then
				If searchReverse Then
					Y = Lines; X = Len(Rec<Lines>)
				End Else
					Y = 1 ; X = 1
				End
				BufInfo<BI.BLOCKSTART> = ""
				Continue
			End Else
				Exit
			End
		End
	Repeat
	
	Return

* **************************************************************************
* Act.ShowOutline - Show a list of Outlines
*-----------------------------------------------------------------------
Act.ShowOutline:

	choiceList = ""
	For I = 1 to Lines
		Line = TrimF(Rec<I>)
		
		!! Label
		word = Line[";",1,1][" ",1,1]
		If word Matches "1n0n":@VM:"1A0X':'" Then
			choiceList<-1> = " ":Line:@VM:I
		End
		
		!! PROGRAM, SUBROUTINE, $INCLUDE
		lists = ""
		lists<-1> = "PROGRAM"
		lists<-1> = "SUBROUTINE"
		lists<-1> = "FUNCTION"
		lists<-1> = "CLASS"
		lists<-1> = "$INCLUDE"
		Convert @FM To @VM In lists
		a = CatS(lists,Reuse("..."))
		
		!! 修飾子を削る
		b = UpCase(Line)
		b = Change(b,"LOCAL","")
		b = Change(b,"PUBLIC","")
		b = Change(b,"PRIVATE","")
		b = Change(b,"SHARE","")
		b = Trimf(b)
		If b Matches a Then
			choiceList<-1> = Line:@VM:I
		End
	Next

	title = ESC:"[1;":FG.BASE3:";":BG.YELLOW:"m Outline"
	tmpList = Fields(Convert(@VM,",",choiceList),",",2)
	Locate Y In tmpList By "AR" Setting choiceNo Else choiceNo -= 1
	
	!! 選択リストボックス初期化
	GoSub InitChoiceList
	
	Loop
		
		!! 選択リストボックス処理共通
		GoSub ProcChoiceList
		
		!! キー入力待ち
		GoSub GetKey
		Begin Case
			!! Cancel
			Case actNo = A.CANCEL Or actNo = A.OUTLINE
				actNo = 0
				Exit
			!!決定
			Case actNo = A.NEWLINE
				If choiceSelection Then
					GoSub StackJumpHistory
					Y = choiceSelection<1,2>
					Top = Y - SCROLLMERGINE
					If Top <= 0 Then Top = 1
					X = 1
					keepDP_X = X
					XOffSet = 1
					Redraw = REDRAW.ALL
				End
				Exit
		End Case
		
	Repeat

	Redraw = REDRAW.ALL
	
	Return

* **************************************************************************
* Act.ShowWordHokan - Word Auto Complete
*-----------------------------------------------------------------------
Act.ShowWordHokan:
	
	!! 現在カーソル位置から単語の先頭までの単語を取得
	GoSub Get.CurrentWord
	
	!! 置換元を選択表示する
	If currentWord <> "" Then
		
		!! 単語置き換え範囲を
		BufInfo<BI.BLOCKSTART> = Y:@VM:stX
		BufInfo<BI.BLOCKEND> = Y:@VM:X
		
		!! 置換範囲を描画
		Row = Y
		GoSub ParseLine
		GoSub PrintLine
		GoSub PrintCursor
		Crt CRT.BUFF.FLUSH:
		
	End
	
	!! 単語を集める
	lineList = Rec
	GoSub Get.WordList
	
	InsBuffer = ""
	
	GoSub Core.ShowWordHokan
	
	If InsBuffer <> "" Then
		GoSub InsertLines
	End
	
	Redraw = REDRAW.ALL
	
	Return

* --------------------------
* Get.CurrentWord
* currentWord [out]
* stX [out]
Get.CurrentWord:
	
	Line = Rec<Y>
	inX = If X > 1 Then X-1 Else 1
		
	!! 単語の先頭まで進む
	Loop
		ch = Line[inX,1]
	While ch <> "" And ch Matches "1A":@VM:"1N" Or Count("._$",ch)
		inX -= 1
		If inX <= 0 Then Exit
	Repeat
	
	!! 現在の単語を設定
	stX = inX + 1
	currentWord = Line[stX,X-stX]
	
	Return

Core.ShowWordHokan:
	
	choiceList = wordList
	
	If currentWord <> "" Then
		
		!! Auto Complete
		hitWord = ""
		choiceList.length = DCount(choiceList,@FM)
		currentWordU = UpCase(currentWord)
		For i = 1 To choiceList.length
			line = choiceList<i>
			If Index(UpCase(line),currentWordU,1) Then
				If hitWord Then
					!! 1つ以上見つかったので終了
					hitWord = ""
					Exit
				End
				!! 初めて見つかった
				hitWord = line
			End
		Next i
		If hitWord Then
			!! 1つだけ見つかった場合はその単語に自動補完
			GoSub GetWord
			If Word <> hitWord And currentWord <> hitWord Then
				InsBuffer = hitWord
				Return
			End
		End
		
	End

	!! 選択リストボックス初期化
	choiceNo = 1
	title = ESC:"[1;":FG.BASE3:";":BG.YELLOW:"m Words"
	GoSub InitChoiceList
	
	filter = currentWord
	
	Loop
		
		!! 選択リストボックス処理共通
		GoSub ProcChoiceList
		
		!! キー入力待ち
		GoSub GetKey
		Begin Case
			!! Cancel
			Case actNo = A.CANCEL Or actNo = A.WORD_HOKAN
				actNo = 0
				Exit
			!! 決定
			Case actNo = A.NEWLINE
				If choiceSelection Then
					InsBuffer = choiceSelection
				End
				Exit
		End Case
		
	Repeat

	Return

* **************************************************************************
* Get.WordList     - 単語一覧取得
*   lineList [in]  - 検索対象
*   wordList [out] - 結果

Get.WordList:
	
	wordList = ""
	
	i.puncs = PUNCS
	o.puncs = Str(@FM,Len(i.puncs))
	
	!! 全行ループ
	lineList.len = DCount(lineList,@FM)
	For y = 1 To lineList.len
		line = lineList<y> ;** 1行
		line = Trim(Convert(Char(9)," ",line)) ;** Remove Tab Space
		
		If line And Not(Count("*!",line[1,1])) Then
			!! 空行とComment行でない
			
			If Count(Upcase(line),"INCLUDE") Then
				temp = Convert(" ",@FM,Trim(line))
				FindStr "INCLUDE" In Upcase(temp) Setting Ps Then
					ROL = temp[@FM,Ps+1,9]
					If ROL<2> = "" Then
						FileName = BufInfo<BI.FILE>
						ItemName = ROL<1>
					End Else
						FileName = ROL<1>
						ItemName = ROL<2>
					End
					incRec = Raise(Trans(FileName,ItemName,-1,"X"))
					If incRec Then
						!! インクルードレコードを後ろに追加
						lineList<-1> = incRec
						lineList.len += DCount(incRec,@FM)
					End
				End
			End
			
			!! 文字列リテラルの除去
			mline = ""
			line.len = Len(line)
			For i = 1 To line.len
				a = line[i,1]
				If Count(STRQTS,a) Then
					!! クォート文字が見つかったら次の対応文字まで進む
					b = Index(line[i+1,HUGE],a,1)
					i += If b Then b Else HUGE
				End Else
					mline := a
				End
			Next i
			
			!! マルチラインループ
			Convert ";" To @FM In mline
			Loop
				line = Trim(Remove(mline,s2))
				
				If line And Not(Count("*!",line[1,1])) Then
					
					!! 単語のループ
					words = Convert(i.puncs,o.puncs,line)
					Loop
						word = Remove(words,s3)
						If word Then
							ch = word[1,1]
							s = Seq(ch)
							If 65 <= s And s <= 122 And currentWord <> word Then
								!! Alphabetで始まりフィルタと完全一致しないもの
								Locate word In wordList By "AL" Setting f Else
									Ins word Before wordList<f>
								End
							End
						End
					While s3
					Repeat
					
				End
				
			While s2
			Repeat
			
		End
		
	Next y
	
	!! バッファ内のファイル名も補完対象に加える
	For I = 1 To MAXWINDOWS
		If BufInfos(I)<BI.USED> Then
			word = BufInfos(I)<BI.FILE>
			Locate word In wordList By "AL" Setting f Else
				Ins word Before wordList<f>
			End
			word = BufInfos(I)<BI.ITEM>
			Locate word In wordList By "AL" Setting f Else
				Ins word Before wordList<f>
			End
		end
	Next
	
	Return

* **************************************************************************
* Act.GoLine

Act.GoLine: 
	Redraw = REDRAW.ALL
	prevY = Y ;** GoTo前のY位置
	If TgtFld Then
		!! フィールド指定モード
		fldCnt = Dcount(TgtFld,@FM)
		If BufInfo<BI.VALUEFIX> Then
			!! バリュー固定モード
			If fldCnt = 1 Then
				!! フィールド数が１つ
				PromptLine = "SubValue No ->"
				GoSub PromptLine
				inputBox = ""
				GoSub InputBox
				Ok = TrimS(Convert(",",@FM,inputBox))
				vno = Ok<1>
			End Else
				!! フィールド数が複数
				PromptLine = "Value No : f-no,sv-no ->"
				inputBox = ""
				GoSub InputBox
				Ok = TrimS(Convert(",",@FM,inputBox))
				Ok = IfS(NumS(Ok),Ok,Reuse(""))
				fno = Ok<1>
				vno = Ok<2>
			End
			
		End Else
			If fldCnt = 1 Then
				!! フィールド数が１つ
				fno = TgtFld<1,1>
				PromptLine = "Value No : v-no[,sv-no] ->"
				GoSub PromptLine
				inputBox = ""
				GoSub InputBox
				Ok = TrimS(Convert(",",@FM,inputBox))
				Ok = IfS(NumS(Ok),Ok,Reuse(""))
				vno = Ok<1>
				svno = Ok<2>
			End Else
				PromptLine = "Value No : f-no,v-no[,sv-no] ->"
				inputBox = ""
				GoSub InputBox
				Ok = TrimS(Convert(",",@FM,inputBox))
				Ok = IfS(NumS(Ok),Ok,Reuse(""))
				fno = Ok<1>
				vno = Ok<2>
				svno = Ok<3>
			End
		End

		If fno And vno Then
			list = FieldS(Convert(@VM,",",TgtFld),",",1)
			Find fno In list Setting i Else
				!! 物理位置が見つからない
				Redraw.StatusLine = @TRUE
				StatusMessage = "Cannot find f-no"
				Return
			End
			GoSub StackJumpHistory
			lineno = i * vno
			If lineno > DCount(Rec,@fm) Then Return
			Y = lineno
			X = 1
			XOffSet = 1
			BufInfo<BI.BLOCKSTART> = Y:@VM:1
			BufInfo<BI.BLOCKEND> = Y:@VM:Len(Rec<Y>) + 1
			keepSelection = @TRUE
		End
		
	End Else
		PromptLine = "Line No : f-no[,v-no[,sv-no]] ->"
		GoSub PromptLine
		inputBox = ""
		GoSub InputBox
		Ok = inputBox
		If Ok = "" Then Return
		Ok = TrimS(Convert(",",@FM,inputBox))
		Ok = IfS(NumS(Ok),Ok,Reuse(""))
		fno = Ok<1>
		vno = Ok<2>
		svno = Ok<3>
		If fno And fno > 0 Then
			If fno > DCount(Rec,@fm) Then Return
			GoSub StackJumpHistory
			Y = fno
			X = 1
			XOffSet = 1
		End
		If vno And vno > 0 Then
			If Field(Rec<Y>,@VM,vno) Then
				X = Col1() + 1
				BufInfo<BI.BLOCKSTART> = Y:@VM:X
				BufInfo<BI.BLOCKEND> = Y:@VM:Col2()
				keepSelection = @TRUE
			End
		End
	End

	!! Goto Subvalue And Selection
	If svno And svno > 0 Then
		If Field(Rec<Y>[X,9999],@SVM,svno) Then
			x2 = X + Col2() - 1
			X = X + Col1()
			BufInfo<BI.BLOCKSTART> = Y:@VM:X
			BufInfo<BI.BLOCKEND> = Y:@VM:x2
			keepSelection = @TRUE
		End
	End

	!! 画面の中心にスクロールさせる
	If prevY <> Y Then
		Top = Y - Int(@CRTHIGH/2) + 1
		If Top < 1 Then Top = 1
	End
	
	Return

* **************************************************************************
* Act.GoDeclaration - 宣言元に行く

Act.GoDeclaration:
	
	Line = Rec<Y>
	
	!!
	!! INCLUE 行全体
	!!
	If Count(Upcase(Line),"INCLUDE") Then
		temp = Convert(" ",@FM,Trim(Line))
		FindStr "INCLUDE" In Upcase(temp) Setting Ps Then
			ROL = temp[@FM,Ps+1,9]
			If ROL<2> = "" Then
				FileName = BufInfo<BI.FILE>
				ItemName = ROL<1>
			End Else
				FileName = ROL<1>
				ItemName = ROL<2>
			End
			flg = Trans(FileName,ItemName,0,"X")
			If flg Then
				GoSub DoRead
				If Found Then Return
			End
		End
	End
	
	GoSub GetWord
	If Word Then
		!!
		!! CALL
		!!
		If Count(Upcase(Line),"CALL") Then
			temp = Convert(" ",@FM,Trim(Line))
			FindStr "CALL" In Upcase(temp) Setting Ps Then
				len = Len(Word)
				ItemName = temp<Ps+1>[1,len]
				If ItemName = Word Then
					If Word[1,1] = "@" Then
						!! InDirect Call なので変数へジャンプ
						Word = Word[2,999]
					End Else
						!! Direct Call
						FileName = BufInfo<BI.FILE> ;** 同一ファイルから検索
						flg = Trans(FileName,ItemName,0,"X")
						If flg Then
							GoSub DoRead
							If Found Then Return
						End Else
							!! TODO Buff内からも検索する
							!! かなりあいまいなのではじめに見つかったものでよい
							
						End
					End
				End
			End
		End
		
		!!
		!! ラベルJump
		!!
		If Word Matches "1A..." Then
			tmpY = 0
			tmpRec = Rec
			Loop
				FindStr Word:":" In tmpRec Setting Pos Then
					li = tmpRec<Pos>
					If Word:":" = Convert(CHAR(9):" ","",li)[1,Len(Word)+1] Then
						GoSub StackJumpHistory
						Y = tmpY + Pos
						Top = Y - 3
						X = 1
						Redraw = REDRAW.ALL
						Return
					End
					tmpY += Pos
					tmpRec = tmpRec[@FM,Pos+1,HUGE]
				End Else Exit
			Repeat
			FindStr "SUBROUTINE ":Word In UpCase(Rec) Setting Pos Then
				!! ローカルサブルーチンの可能性
				GoSub StackJumpHistory
				Y = Pos
				Top = Pos - 3
				X = 1
				Redraw = REDRAW.ALL
				Return
			End
		End
		
		!!
		!! 変数定数宣言元へJump
		!!
		Dim iRec(10),iRec.Cnt(10),iRec.Y(10)
		result = "" ;** 結果データ 1:File 2:X 3:Y
		sp = 1 ;** スタック位置
		iRec(sp) = Rec ;** 現在ファイルから開始
		GoSub Find.Definition
		If result Then
			GoSub StackJumpHistory
			If result<1> Then
				!! INCLUDE先のファイル
				FileName = result<1,1>
				ItemName = result<1,2>
				GoSub DoRead
			End
			Y = result<2>
			X = result<3>
			Redraw = REDRAW.ALL
		End

	End
	Return

* **************************************************************************
* レコード内で対象変数の宣言位置を返す
* Input:  iRec - 検索対象レコード
*         iY   - Y位置
*         Word - 対象単語
* Output: result - Jump先結果 1:ファイル 2:Y位置 3:X位置
*-----------------------------------------------------------------------------
Find.Definition:
	
	iRec.Cnt(sp) = DCount(iRec(sp),@FM) ;** 最大行数
	iX = 1
	For iRec.Y(sp) = 1 To iRec.Cnt(sp)
		Line = iRec(sp)<iRec.Y(sp)>[iX,HUGE]
		
		!! $INCLUDE の場合は再帰的に探す
		If Count(Upcase(Line),"INCLUDE") Then
			temp = Convert(" ",@FM,Trim(Line))
			FindStr "INCLUDE" In Upcase(temp) Setting Ps Then
				ROL = temp[@FM,Ps+1,9]
				If ROL<2> = "" Then
					FileName = BufInfo<BI.FILE>
					ItemName = ROL<1>
				End Else
					FileName = ROL<1>
					ItemName = ROL<2>
				End
				If sp < 10 Then
					sp += 1 ;** next Stack
					iRec(sp) = Raise(Trans(FileName,ItemName,-1,"X"))
					GoSub Find.Definition
					sp -= 1;** back Stack
					If result Then
						!! 見つかった場合
						If Not(result<1>) Then
							!! このファイルで初めて見つかったので対象ファイルを格納する
							result<1> = FileName:@VM:ItemName
						End
						Return
					End
				End
			End
		End
		
		!! 完全一致する単語を見つける
		iX = Index(Line,Word,1)
		If iX Then
			lineList = Line
			currentWord = ""
			GoSub Get.WordList
			Find Word In wordList Setting pos Then
				result<2> = iRec.Y(sp)
				result<3> = iX
				Return
			End
			
			iX += 1
			Continue
		End
		iX = 1
	Next iRec.Y(sp)

	Return


* **************************************************************************
* Act.GoPrevJumpHist - 前のJump履歴を復元

Act.GoPrevJumpHist:

	If jumpHistoryPos <= 0 Then
		!! ジャンプ戻り前の位置を保存しておく
		GoSub GetJumpData
		currentJumpData = jumpData
	End
	If jumpHistory<jumpHistoryPos+1> >< "" Then
		jumpHistoryPos += 1 ;** 1つ前へ
		jumpData = Raise(jumpHistory<jumpHistoryPos>)
		GoSub RestoreFromJumpData
		If jumpData >< "" Then
			!! それ以前のJump履歴は打ち切りにする
			jumpHistory = jumpHistory[@FM,1,jumpHistoryPos]
		End
	End
	If jumpHistoryPos < 0 Then
		jumpHistoryPos = 0
	End
	
	Redraw = REDRAW.ALL

	Return

* **************************************************************************
* Act.GoNextJumpHist - 次のJump履歴を復元

Act.GoNextJumpHist:

	If jumpHistoryPos > 1 Then
		jumpHistoryPos -= 1 ;** 1つ次へ
		jumpData = Raise(jumpHistory<jumpHistoryPos>)
	End Else
		jumpHistoryPos = 0
		jumpData = Raise(currentJumpData)
	End

	GoSub RestoreFromJumpData
	
	Redraw = REDRAW.ALL

	Return

* **************************************************************************
* Act.Copy

Act.Copy:
	
	GoSub GET.SELECTION.STRING
	
	If selString >< "" Then
		clipboard = selString ;** ローカルクリップボードに格納
		
		!! リモート端末に送信する
$IFDEF U2__UNIVERSE
		result = ""
		retCode = ENCODE("Base64A", "1", selString, "1", result, "1")
$ELSE
		result = OCONV(OCONV(selString,"XUTF8"), "B64")
$ENDIF
		Crt ESC:"]52;;":result:CHAR(7):
		
	End
	
	Return

* **************************************************************************
* Act.Cut

Act.Cut:
	
	GoSub Act.Copy
	If BufInfo<BI.BLOCKSTART> Then
		!! 選択中の物は削除する
		GoSub Act.DelCh
	End
	
	Return
	
* **************************************************************************
* Act.SendRemotePasteCmd

Act.SendRemotePasteCmd:
	!! リモート端末のクリップボードから取得を要求
	Crt ESC:"]52;0;?":CHAR(7):
	keepSelection = True
	Return
	
* **************************************************************************
* Act.PasteLocal
* Act.Paste

Act.PasteLocal:
	InsBuffer = clipboard
Act.Paste:
	startY = If BufInfo<BI.BLOCKSTART> Then Minimum(BufInfo<BI.BLOCKSTART,1>:@FM:BufInfo<BI.BLOCKEND,1>) Else Y
	GoSub InsertLines
	If X = 1 Then
		!! 挿入後改行の次にカーソルがある場合は範囲選択を残す
		BufInfo<BI.BLOCKSTART> = startY:@VM:1
		BufInfo<BI.BLOCKEND> = Y:@VM:1
		keepSelection = True
	End
	Return
	
* **************************************************************************
* Act.Undo

Act.Undo:
	
	If EditCmdStack<EditCmdPos> = "SAVED_POINT" Then EditCmdPos += 1 ;** １つ前に戻る
	editCmd = EditCmdStack<EditCmdPos,2> 
	If editCmd >< "" Then
		GoSub DoEditCmd
		Changed = True
		EditCmdPos += 1 ;** １つ前に戻る
		Changed = If EditCmdStack<EditCmdPos> = "SAVED_POINT" Then False Else True
		Redraw = REDRAW.ALL
	End
	
	Redraw.StatusLine = @TRUE
	
	Return
	
* **************************************************************************
* Act.Redo

Act.Redo:

	If EditCmdPos > 1 Then 
		If EditCmdStack<EditCmdPos-1> = "SAVED_POINT" Then
			EditCmdPos -= 1 ;** １つ先に進む
		End
		EditCmdPos -= 1 ;** １つ先に進む
		editCmd = EditCmdStack<EditCmdPos,1>
		GoSub DoEditCmd
		Changed = True
		If EditCmdStack<EditCmdPos-1> = "SAVED_POINT" Then
			Changed = False
			EditCmdPos -= 1 ;** １つ先に進む
			Redraw = REDRAW.ALL
		End
	End
	
	Redraw.StatusLine = @TRUE
	
	Return

* **************************************************************************
* Act.ShowBuffList - Print a list of the buffer

Act.ShowBuffList:

	!!
	!! 選択肢の構築
	!!
	listCnt = DCount(lruBuffList,@FM)
	choiceList = ""
	For I = 1 To listCnt
		no = lruBuffList<I>
		info = BufInfos(no)
		If info<BI.USED> Else Continue
		dispStr = no:" > "
		Begin Case
			Case info<BI.CAPTURE> <> ""
				dispStr := info<BI.CAPTURE> "L#60"
			Case 1
				If info<BI.CHANGED> Then dispStr := "*"
				If info<BI.NEW> Then dispStr := "(NEW)"
				dispStr := If info<BI.FILE> >< "" Then info<BI.FILE> Else "(Untitled)" 
				dispStr := " ":info<BI.ITEM>
				If info<BI.FIELDFIX> Then dispStr:= " {":info<BI.FIELDFIX>:"}"
				If info<BI.VALUEFIX> Then dispStr:= ",V":info<BI.VALUEFIX>
				If @PATH >< info<BI.ACCOUNT> Then dispStr:= " [":info<BI.ACCOUNT>:"]"
				If info<BI.LOCKED> Then dispStr:= " <Locked>"
		End Case
		choiceList<-1> = dispStr
	Next
	title = CSI:"1;":FG.BASE3:";":BG.BLUE:"m Choice Buffer"
	choiceNo = If DCount(choiceList,@FM) < 2 Then 1 Else 2 ;**   !! 初期値は１つ前のものにする
	
	!! 選択リストボックス初期化
	GoSub InitChoiceList
	
	Loop
		
		!! 選択リストボックス処理共通
		GoSub ProcChoiceList
		
		!! キー入力待ち
		GoSub GetKey
		Begin Case
			Case actNo = A.CANCEL ;** 抜ける
				actNo = 0
				Exit
			Case actNo = A.NEWLINE ;** 決定
				If choiceSelection Then
					Found = choiceSelection[' ',1,1]
					GoSub StackJumpHistory
					GoSub ChangeBuf
				End
				Exit
			Case actNo = A.BUFFER ;** バッファ進める
				actNo = A.DOWN
		End Case
		
	Repeat

	Redraw = REDRAW.ALL
	
	Return

* **************************************************************************
* Act.AutoIndent

Act.AutoIndent:
	
	!! 直前の行
	line = Rec<Y-1>
	GoSub GetIndentCnt
	adjustIndentCnt = indentCnt ;** 揃えるインデント数

	autoClosing = "" ;** 自動閉じ処理

	!!
	!! 直前の行の内容によりインデントを増やす
	!!
	line = line[";",1,1] ;** 複数行の時にインデントが上がるケースはまずないので無視する
	line = TrimB(Convert(Char(9)," ",line)) ;** 正規化
	lineUC = UpCase(line)
	
	If lineUC Matches "... THEN":@VM:"... ELSE" Then
		!! IF分岐
		adjustIndentCnt += 1
		autoClosing = "End"
		If line Matches "... THEN":@VM:"... ELSE" Then
			autoClosing = "END"
		End Else If line Matches "... then":@VM:"... else" Then
			autoClosing = "end"
		END
	End Else If lineUC Matches "BEGIN... ...CASE":@VM:"... BEGIN... ...CASE" Then
		!! Switch分岐
		adjustIndentCnt += 1
		autoClosing = "End Case"
		If line Matches "...BEGIN...CASE" Then
			autoClosing = "END CASE"
		End Else If line Matches "...begin...case" Then
			autoClosing = "end case"
		End
	End Else If lineUC Matches "... CASE ..." Then
		!! Case分岐
		adjustIndentCnt += 1
	End Else If lineUC Matches "LOOP":@VM:"... LOOP" Then
		!! ループ
		adjustIndentCnt += 1
		autoClosing = "Repeat"
		If line Matches "...LOOP" Then
			autoClosing = "REPEAT"
		End Else If line Matches "...loop" Then
			autoClosing = "repeat"
		End
	End Else If lineUC Matches "FOR ...":@VM:"... FOR ..." Then
		!! Forループ
		a = line[Index(lineUC,"FOR",1),3]
		pattern = "...'":a:"'...1A0X' '..."
		varName = MatchField(line,pattern,4):MatchField(line,pattern,5)
		If UpCase(varName) = "EACH" Then
			!! EACHが来たらもう一度
			pattern = "...'":a:"'...'":varName:"'...1A0X' '..."
			varName = MatchField(line,pattern,6):MatchField(line,pattern,7)
		End
		If varName Then
			adjustIndentCnt += 1
			If line Matches "...FOR..." Then
				autoClosing = "NEXT ":varName
			End Else If line Matches "...for..." Then
				autoClosing = "next ":varName
			End Else
				autoClosing = "Next ":varName
			End
		End
	End
	
	!! 現在の行
	line = Rec<Y>
	GoSub GetIndentCnt
	
	!! インデント数が同じならスキップ
	If adjustIndentCnt = indentCnt Then Return
	
	!! インデント挿入
	editCmd = ""
	editCmd<1> = Y
	editCmd<2> = 1
	editCmd<3> = Y
	editCmd<4> = indentLen 
	editCmd<5> = Str(IndentCh,adjustIndentCnt)
	editCmd<6> = ""
	
	!! 自動閉じ文挿入
	If autoClosing Then
		
		!! 自動閉じ処理が不要な場合を探す
		For iY = Y+1 To Lines
			line = Rec<iY>
			GoSub GetIndentCnt
			
			!! 開始時のインデントから上がったら抜ける
			If indentCnt < adjustIndentCnt - 1 Then Exit
			
			!! 同一インデントの場合に自動閉じ処理が見つかったら不要である
			If indentCnt = adjustIndentCnt - 1 Then
				If UpCase(line[indentLen,9999]) Matches UpCase(autoClosing):"..." Then
					GoTo Skip.AutoClosing
				End
				Exit
			End
		Next iY
		
		cmd = ""
		cmd<1> = Y+1
		cmd<2> = 1
		cmd<3> = ""
		cmd<4> = ""
		cmd<5> = Str(IndentCh,adjustIndentCnt-1):autoClosing:Char(10)
		cmd<6> = "1"
		editCmd<-1> = cmd
		
	Skip.AutoClosing:
	End
	
	GoSub StackEditCmd
	
	Return

* **************************************************************************
* Act.Tab

Act.Tab:
	
	If BufInfo<BI.BLOCKSTART> Then
		** 一括インデント増やし
		GoSub Act.IncreaseIndent
	End Else
		!! カーソル位置がインデント位置なら自動インデント
		line = Rec<Y>
		GoSub GetIndentCnt
		If X < indentLen Then
			GoSub Act.AutoIndent
		End Else
			editCmd = ""
			editCmd<1> = Y
			editCmd<2> = X
			editCmd<3> = ""
			editCmd<4> = ""
			editCmd<5> = IndentCh
			editCmd<6> = ""
		
			GoSub StackEditCmd
		End
		
	End
	Return

* **************************************************************************
* Act.IncreaseIndent

Act.IncreaseIndent:
	
	editCmd = ""
	If Not(BufInfo<BI.BLOCKSTART>) Then
		blockStart = Y:@VM:1
		blockEnd = Y:@VM:1
	End Else
		GoSub GET.SELECTION.STRING
	End
	
	cnt = blockEnd<1>
	If blockEnd<2> = 1 Then cnt -= 1
	For iY = blockStart<1> To cnt
		cmd = ""
		cmd<1> = iY
		cmd<2> = 1
		cmd<3> = ""
		cmd<4> = ""
		cmd<5> = IndentCh
		cmd<6> = "0"
		editCmd<-1> = cmd
	Next
	
	tmpX = X ; tmpY = Y
	GoSub StackEditCmd
	X = tmpX ; Y = tmpY
	
	BufInfo<BI.BLOCKSTART> = Lower(blockStart)
	BufInfo<BI.BLOCKEND> = Lower(blockEnd)
	
	BufInfo<BI.BLOCKSTART, 2> = 1
	If X > 1 Then
		BufInfo<BI.BLOCKEND, 2> = Len(Rec<BufInfo<BI.BLOCKEND,1>>)
		X = 1
		Y += 1
	End
	keepSelection = True
	
	Return

* **************************************************************************
* Act.DecreaseIndent

Act.DecreaseIndent:

	editCmd = ""
	
	If Not(BufInfo<BI.BLOCKSTART>) Then
					blockStart = Y:@VM:1
					blockEnd = Y:@VM:1
	End Else
		GoSub GET.SELECTION.STRING
	End

	cnt = blockEnd<1>
	If blockEnd<2> = 1 Then cnt -= 1
	cmd = ""
	cmd<5> = ""
	cmd<6> = "0"
	For iY = blockStart<1> To cnt
		iX = 1
		cmd<1> = iY
		cmd<2> = iX
		cmd<3> = iY
		cmd<4> = iX
		If Rec<iY>[iX,1] = Char(9) Then
			cmd<4> += 1
			editCmd<-1> = cmd
		End
		If Rec<iY>[iX,STDINDENT] = Space(STDINDENT) Then
			cmd<4> += STDINDENT
			editCmd<-1> = cmd
		End
	Next

	tmpX = X ; tmpY = Y
	GoSub StackEditCmd
	X = tmpX ; Y = tmpY
		
	!! 選択あり
	BufInfo<BI.BLOCKSTART,2> = 1
	If X <> 1 Then
		X = 1
		Y += 1
	End
	BufInfo<BI.BLOCKEND> = Y:@VM:X
	keepSelection = True
	Return	

* **************************************************************************
* Act.ShiftTab

Act.ShiftTab:
	
	If Not(BufInfo<BI.BLOCKSTART>) Then
		GoSub Act.Tab
		Return
	End
	
	GoSub Act.DecreaseIndent
	
	Return

* **************************************************************************
* Act.InsFMC

Act.InsFMC:
	
	Return
	
* **************************************************************************
* Act.InsVMC

Act.InsVMC:
	
	Return

* **************************************************************************
* Act.InsSMC

Act.InsSMC:
	
	Return

* **************************************************************************
* Act.InsTMC

Act.InsTMC:
	
	Return

* **************************************************************************
* Act.NewLine

Act.NewLine:
	
	editCmd = ""
	
	If BufInfo<BI.BLOCKSTART> Then
		** 選択中
		editCmd<1> = BufInfo<BI.BLOCKEND, 1>
		editCmd<2> = BufInfo<BI.BLOCKEND, 2>
		editCmd<3> = BufInfo<BI.BLOCKSTART, 1>
		editCmd<4> = BufInfo<BI.BLOCKSTART, 2>
	End Else
		editCmd<1> = Y
		editCmd<2> = X
		editCmd<3> = Y
		editCmd<4> = Len(Rec<Y>)+1
	End

	editCmd<5> = CHAR(10)
	editCmd<6> = ""
	
	If Rec<Y>[X,1] >< "" Then
		!! 行の途中での改行処理
		editCmd2 = ""
		editCmd2<1> = Y+1
		editCmd2<2> = 1
		editCmd2<3> = ""
		editCmd2<4> = ""
		editCmd2<5> = Rec<Y>[X,HUGE]
		editCmd2<6> = "1"
		editCmd := @FM:editCmd2
	End
	
	GoSub StackEditCmd

	If BufInfo<BI.PARSETYPE> = PARSE.BASIC Then
		!! 自動インデント処理
		GoSub Act.AutoIndent
	End

	Return

* **************************************************************************
* Act.InsTemplate

Act.InsTemplate:
	Return

* **************************************************************************
* Act.InsCommentOut

Act.InsCommentOut:
	
	StBlock = BufInfo<BI.BLOCKSTART,1>
	EdBlock = BufInfo<BI.BLOCKEND,1>
	If StBlock<1> > EdBlock<1> Then tmp = StBlock; StBlock = EdBlock; EdBlock = tmp
	
	If BufInfo<BI.BLOCKEND,2>=1 Then EdBlock -= 1
	If Not(StBlock) Then
		StBlock = Y
		EdBlock = Y
	End
	editCmd = ""
	For Z = StBlock To EdBlock
		cmd = ""
		cmd<6> = "0"
		If Rec<Z>[1,3] = "!! " Then
			** コメント外す
			cmd<1> = Z
			cmd<2> = 1
			cmd<3> = Z
			cmd<4> = 4
			cmd<5> = ""
		End Else
			** コメント付ける
			cmd<1> = Z
			cmd<2> = 1
			cmd<3> = ""
			cmd<4> = ""
			cmd<5> = "!! "
		End
		editCmd<-1> = cmd
	Next
	GoSub StackEditCmd
	Return

* **************************************************************************
* Act.GoDive

Act.GoDive:
	
	If BufInfo<BI.VALUEFIX> Then Return ;** SubValueまでで終わり
	
	!! 現在のバッファを親にする
	ParentBufNo = CurBuf
	!! アイテム情報は現状を引き継ぐ
	FileName = BufInfo<BI.FILE>
	ItemName = BufInfo<BI.ITEM>
	If BufInfo<BI.FIELDFIX> Then
		!! SubValueにDive
		inY = Y
		GoSub GetDAPos
		DiveValuePos = vPos
		FldInfo = BufInfo<BI.FIELDFIX>
	End Else
		!! ValueにDive
		FldInfo = "F":Y ;** 現在のカーソル行をターゲットにする
	End
	GoSub DoRead
	GoSub DoShowDictInfo
	Redraw = REDRAW.ALL
	Return

* **************************************************************************
* Act.ShowHelp

Act.ShowHelp: 
	GoSub GetWord
	If Word = "" Then
		Return
	End
	HelpText = ""
$IFDEF U2__UNIVERSE
	HelpFiles = "BASIC.HELP.JP|BASIC.HELP|SYS.HELP"
$ELSE
	HelpFiles = ""
$ENDIF
	For HelpNo = 1 To Dcount(HelpFiles,"|")
		Open Field(HelpFiles,"|",HelpNo,1) To HELPFL Then
			Read helpRec From HELPFL, UpCase(Word) Else
				Read helpRec From HELPFL, UpCase(Word):"()" Else
					Read helpRec From HELPFL, Word Else
						helpRec = ""
					End
				End
			End
			If helpRec >< "" Then HelpText<-1> = helpRec
		End
	Next HelpNo
	If HelpText = "" Then
		StatusMessage = "Cannot find help for ": Word ; Redraw.PrintLine = True 
		Return
	End
	Text = HelpText
	GoSub ShowText
	Return

* **************************************************************************
* Act.Reload

Act.Reload:
	
	If IsNew Then Return
	
	FileName = BufInfo<BI.FILE>
	ItemName = BufInfo<BI.ITEM>
	
	!! レコード格納先ファイルのオープン  
	GoSub Common.OpenFile
	
	Read TempRec From FL, ItemName Else TempRec = ""
	Convert CHAR(10):CHAR(13) To '' In TempRec ;** 改行コードが残っていたら自動除外
	
	If TempRec >< StartRec Then
		!! 初めのレコードと違いがある
		If Changed Then
			!! 変更ありなら自分の変更を破棄するか判断させる
			PromptLine = "Record previously Changed by Another, Are you sure you want to destroy your modification? (Y) :"
			GoSub PromptLine
			GoSub GetKey
			If UpCase(C) = "Y" Else Return
		End
		GoSub Common.OpenFile
		GoSub ReadItem
	End

	Redraw = REDRAW.ALL
	
	Return

* **************************************************************************
* Act.Save

Act.Save:
	GoSub SaveItem
	Return

* **************************************************************************
* Act.Compile

Act.Compile:
	
	If Changed Then GoSub CheckSave
	FileName = BufInfo<BI.FILE>
	ItemName = BufInfo<BI.ITEM>
$IFDEF U2__UNIVERSE
	cmdline = "BASIC ":FileName:" ":ItemName
$ELSE
	cmdline = "BASIC ":FileName:" ":ItemName:" CHANGED DEBUGGING"
$ENDIF
	bAutoCommand = @TRUE
	bAutoEditor = @TRUE
	GoSub Act.Exit
	Return

* **************************************************************************
* Act.Action

Act.Action:
	GoSub Action
	Return

* **************************************************************************
* Act.Exit

Act.Exit:
	AllDone = True
	Return

* **************************************************************************
* Act.CloseBuff

Act.CloseBuff:
	
	If Changed And Not(ReadOnly) Then
		PromptLine = "Record has changed - Enter ! to Force Close :"; GoSub PromptLine
		GoSub GetKey
		If C >< "!" Then Return
	End

	FileName = BufInfo<BI.FILE>
	ItemName = BufInfo<BI.ITEM>
	
	!! ロックを外す
	If FileName >< "" And ItemName >< "" Then
		Open FileName To FL Else
			StatusMessage = "Cannot Open ":FileName
			Return
		End
		Release FL,ItemName
	End

	!! 現在のバッファ終了  
	BufInfo<BI.USED> = False
	
	!! lruBuffListからCurBufをすべて削除
	flgs = EqS(lruBuffList,Reuse(CurBuf))
	lruBuffList = IfS(flgs,Reuse(""),lruBuffList)
	lruBuffList = Convert(' ',@FM,Trim(Convert(@FM,' ',lruBuffList)))

	!! 次のバッファ
	Found = lruBuffList<1>
	If Found="" Then
		GoSub Act.Exit
	End Else
		CurBuf = Found
		GoSub ChangeBuf
	End
	Return

* **************************************************************************
* Act.CloseBuff

Act.AllCloseBuf:
	
	If lruBuffList >< "" Then
		PromptLine = "Ara you sure Close all Buffer ? : Enter ! to Force ->"; GoSub PromptLine
		GoSub GetKey
		If C >< "!" Then Return
	End
	
	!! 変更のないバッファを破棄
	Found = False
	For I = 1 To MAXWINDOWS Until Found
		If BufInfos(I)<BI.USED> then
			If BufInfos(I)<BI.CHANGED> And Not(BufInfos(I)<BI.READONLY>) Then
				Found = True
			End Else
				BufInfos(I)<BI.USED> = @FALSE
			End
		End
	Next
	If Found then
		PromptLine = "There are changed items, Ara you sure Close all Buffer ? : Enter ! to Force ->"; GoSub PromptLine
		If C >< "!" Then Return
		!! 強制的にすべて破棄
		For I = 1 To MAXWINDOWS
			BufInfos(I)<BI.USED> = @FALSE
		Next
	End
	
	GoSub Act.Exit
	Return

* **************************************************************************
* Act.ToggleCaseInvert - 大文字<->小文字切り替えフラグの切り替え

Act.ToggleCaseInvert:
	
	bInvert = Not(bInvert)
	Perform "PTERM CASE ":If bInvert Then "INVERT" Else "NOINVERT"
	
	Return


* **************************************************************************
* Act.SwitchTheme

Act.SwitchTheme:

	theme += 1
	If theme > 3 Then theme = 1

Set.Theme:

	crtBuff = ""
	
	Begin Case
		Case theme = 1
		
			themeName = "terminal default"
			crtBuff := ESC:"]R"
		
		Case theme = 2
		
			themeName = "Solarized - dark"

			crtBuff := ESC:"]4;0;#002b36":BEL
			crtBuff := ESC:"]4;10;#073642":BEL
			crtBuff := ESC:"]4;11;#586e75":BEL
			crtBuff := ESC:"]4;8;#657b83":BEL
			crtBuff := ESC:"]4;12;#839496":BEL
			crtBuff := ESC:"]4;7;#93a1a1":BEL
			crtBuff := ESC:"]4;13;#eee8d5":BEL
			crtBuff := ESC:"]4;15;#fdf6e3":BEL
			
			crtBuff := ESC:"]4;3;#b58900":BEL
			crtBuff := ESC:"]4;9;#cb4b16":BEL
			crtBuff := ESC:"]4;1;#dc322f":BEL
			crtBuff := ESC:"]4;14;#d33682":BEL
			crtBuff := ESC:"]4;5;#6c71c4":BEL
			crtBuff := ESC:"]4;4;#268bd2":BEL
			crtBuff := ESC:"]4;6;#2aa198":BEL
			crtBuff := ESC:"]4;2;#859900":BEL
		
			crtBuff := ESC:"]10;#93a1a1":BEL
			crtBuff := ESC:"]11;#002b36":BEL
			crtBuff := ESC:"]4;260;#000000":BEL
			crtBuff := ESC:"]12;#ffffff":BEL
		
		Case theme = 3
			
			themeName = "Solarized - light"
			
			crtBuff := ESC:"]4;0;#fdf6e3":BEL
			crtBuff := ESC:"]4;10;#eee8d5":BEL
			crtBuff := ESC:"]4;11;#93a1a1":BEL
			crtBuff := ESC:"]4;8;#839496":BEL
			crtBuff := ESC:"]4;12;#657b83":BEL
			crtBuff := ESC:"]4;7;#586e75":BEL
			crtBuff := ESC:"]4;13;#073642":BEL
			crtBuff := ESC:"]4;15;#002b36":BEL
			
			crtBuff := ESC:"]4;3;#b58900":BEL
			crtBuff := ESC:"]4;9;#cb4b16":BEL
			crtBuff := ESC:"]4;1;#dc322f":BEL
			crtBuff := ESC:"]4;14;#d33682":BEL
			crtBuff := ESC:"]4;5;#6c71c4":BEL
			crtBuff := ESC:"]4;4;#268bd2":BEL
			crtBuff := ESC:"]4;6;#2aa198":BEL
			crtBuff := ESC:"]4;2;#859900":BEL
		
			crtBuff := ESC:"]10;#586e75":BEL
			crtBuff := ESC:"]11;#fdf6e3":BEL
			crtBuff := ESC:"]4;260;#ffffff":BEL
			crtBuff := ESC:"]12;#000000":BEL
			
	
	End Case

	If noThemePopup Then
		Crt crtBuff:
	End Else
		!! テーマ名の表示
		popupX = Int(@CRTWIDE/2)
		popupY = Int(@CRTHIGH/2) - 3
		crtBuff := ESC:"[":BG.BASE2:";":FG.BASE00:"m"
		crtBuff := @(popupX-12,popupY)  :"--------- Theme ---------"
		crtBuff := @(popupX-12,popupY+1):"|                       |"
		crtBuff := @(popupX-12,popupY+2):"|                       |"
		crtBuff := @(popupX-12,popupY+3):"|                       |"
		crtBuff := @(popupX-12,popupY+4):"-------------------------"
	
		crtBuff := SGR.ALL.OFF
		crtBuff := @(popupX-Int(Len(themeName)/2),popupY+2):themeName
	
		Crt crtBuff:
		GoSub GetKey
		If actNo = A.THEME Then GoTo Act.SwitchTheme

		Redraw = REDRAW.ALL
	End
	
	Return

*-----------------------------------------------------------------------------
*  カーソル位置が単語の途中なら単語の末端へ移動
*  それ以外なら次の単語の先頭位置へ移動
*-----------------------------------------------------------------------------
Move.NextWord:
	!! 単語の終端まで移動
	GoSub GetWord
	If Word Then
		If X # SOW Then
			!! 単語の途中なので単語の末端へ移動
			!! 変数として利用できる "._$%@" も区切りとする
			prev.ch = ""
			Loop
				X += 1
				ch = Convert(Char(9):@FM:@VM:@SVM,Space(4),Line[X,1])
			Until ch = ""
			Until Count("._$%@ =:<>()[]{}/*+-,'\":'"',ch)
			Until ch = UpCase(ch) And prev.ch # UpCase(prev.ch)
				prev.ch = ch
			Repeat
			Return
		End
		Loop
			X += 1
			ch = Convert(Char(9):@FM:@VM:@SVM,Space(4),Line[X,1])
		Until ch = ""
		Until Count(" =:<>()[]{}/*+-,'\":'"',ch)
		Repeat
	End Else
		ch = Convert(Char(9):@FM:@VM:@SVM,Space(4),Line[X,1])
	End
	
	!! 次の単語の先頭を探す
	If Line[X,1] = "" Then Return
	X += 1
	If Line[X,1] = "" Then Return
	prevKwd = Count("=:<>()[]{}/*+-,'\":'"',ch)
	Loop
		ch = Convert(Char(9):@FM:@VM:@SVM,Space(4),Line[X,1])
		If ch = "" Then X-=1; Exit
		kwd = Count("=:<>()[]{}/*+-,", ch)
		If prevKwd And kwd Else
			If ch <> " " Then Exit
		End
		prevKwd = kwd
		X += 1
	Repeat  
		
	Return


*-----------------------------------------------------------------------------
*  カーソル位置が単語の途中なら単語の先頭へ移動
*  それ以外なら前の単語の先頭位置へ移動
*-----------------------------------------------------------------------------
Move.PrevWord:
	GoSub GetWord
	Line = Rec<Y>
	Line.len = Len(Line)
	If Word = "" Or type <> 1 Or X = SOW Or X = Line.len+1 Then
		!! カーソルが単語の開始位置または行の最終にある場合は
		!! 前の単語の先頭位置に移動する（高速移動）
		Line = Line[1,X]
		finX = X
		If X = Line.len+1 Then finX -= 1
		X = 0
		tmpX = 1
		Loop
			GoSub Move.NextWord
			If X >= finX Then Exit ;** 開始位置を超えたら抜ける
			tmpX = X
		Repeat
		X = tmpX ;** 直前の位置が答え
	End Else
		!! カーソルが単語の途中にある場合は
		!! 単語の区切り "._$%@" とキャメルケースを考慮に入れる（低速移動）
		prevX = X
		prev.ch = ""
		Loop
			X -= 1
		Until X = 0
			ch = Convert(Char(9):@FM:@VM:@SVM,Space(4),Line[X,1])
		Until ch = ""
		Until Count("._$%@ =:<>()[]{}/*+-,'\":'"',ch)
			If ch = UpCase(ch) And prev.ch # UpCase(prev.ch) Then
				X -= 1
				Exit
			End
			prev.ch = ch
		Repeat
		X += 1
		If prevX = X Then
			!! カーソルが動かなかった場合は１つ動かして再度ロジックを走らす
			X -= 1
			GoSub Move.PrevWord
		End
	End

	Return

*-----------------------------------------------------------------------------
* 指定の行文字列のインデント数を返す
* Input: line
* Output: indentCnt - インデント数
*         indentLen - インデントの文字列長
*-----------------------------------------------------------------------------
GetIndentCnt:
	
	!! スペースに統一して計算する
	lineLen = Len(line)
	indentCnt = 0
	indentLen = 1
	Loop
		ch = line[indentLen,1]
		If ch > CHAR(32) Or ch = "" Then Exit
		indentLen += 1
		indentCnt += (If ch = Char(9) Then STDTAB Else 1) 
	Repeat
	If indentCnt > 0 Then indentCnt -= indentCnt / STDTAB
	
	Return

*-----------------------------------------------------------------------------
* 指定の行文字列のインデント数を返す
* Input:  dirPath - パス
* Output:    list - @FM区切り
*-----------------------------------------------------------------------------
GetDirList:
$IFNDEF U2__UNIVERSE
  TEMP.PATH = SYSTEM(38):(If OS.GATES Then "\" Else "/"):"SISH.DIR.":@USERNO
	TEMP.PATH.CMD = TEMP.PATH:".cmd"
	TEMP.PATH.OUT = TEMP.PATH:".out"

	OpenSeq TEMP.PATH.CMD Encoding "UTF8" To fp Else Create fp Else Abort "Cannot create temp file -> ":TEMP.PATH
	
	batch = ""
	If OS.GATES Then
		d = Convert("/","\",dirPath)
		batch<-1> = "chcp 65001"
		batch<-1> = "dir /b /a:d ":d:" > ":TEMP.PATH.OUT
		batch<-1> = "echo : >> ":TEMP.PATH.OUT
		batch<-1> = "dir /b /a:-d ":d:" >> ":TEMP.PATH.OUT
		batch = Change(batch,@FM,CHAR(13):CHAR(10))
	End Else
		d = dirPath
		batch<-1> = "ls -F ":d:" 2> /dev/null | grep / > ":TEMP.PATH.OUT
		batch<-1> = "echo : >> ":TEMP.PATH.OUT
		batch<-1> = "ls -F ":d:" 2> /dev/null | grep -v / >> ":TEMP.PATH.OUT
		batch = Change(batch,@FM,CHAR(10))
		!! 実行権限を付与
		TEMP.PATH.CMD = "chmod 744 ":TEMP.PATH.CMD:" && ":TEMP.PATH.CMD
	End

	WriteSeq batch To fp Else Abort "Cannot Write"
	
	WEOFSeq fp
	CloseSeq fp
	
	OS.Execute TEMP.PATH.CMD Silent
	
	list = ""
	OpenSeq TEMP.PATH.OUT Encoding "UTF8" To fp Then
		d = "D"
		Loop
			ReadSeq line From fp Else Exit
			If line[1,1] = ":" Then d = "" Else
				list<-1> = Convert("*/","",line):@VM:d
			End
		Repeat
		CloseSeq fp
	End
$ENDIF
Return

End
*
* Local variables:
* mode: unibasic
* End:
